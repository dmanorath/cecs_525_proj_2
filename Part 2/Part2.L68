00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 2/24/2018 4:37:11 PM

00000000                             1  *=============================================================================
00000000                             2  *   Exception Vector Table in ROM
00000000                             3                  ORG     $0
00000000                             4                  * 00-03 SSP, Reset, bus error, address error
00000000= 00004400 00001000 ...      5                  DC.L    STACK,RESET,BUS_ER,ADD_ER
00000010                             6                  * 04-07 ILLEGAL, zero divide, CHK, TRAPV
00000010= 0000189A 00001B02 ...      7                  DC.L    IL_ER,X_UN,X_UN,X_UN
00000020                             8                  * 08-0F Privilege, Trace, 1010, 1111, 3 Reserved, Uninitialized
00000020= 000018DA 00001B02 ...      9                  DC.L    PRI_ER,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000040                            10                  * 10-17 Uninitialized
00000040= 00001B02 00001B02 ...     11                  DC.L    X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000060                            12                  * 18-1F Uninitialized
00000060= 00001B02 00001B02 ...     13                  DC.L    X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000080                            14                  * 20-2F TRAP Vectors: 0, 14, 15 are initialized
00000080= 00001750 00001B02 ...     15                  DC.L    TRAP_0,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000000A0= 00001B02 00001B02 ...     16                  DC.L    X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,BRKPT,_main
000000C0                            17  * *=============================================================================
000000C0  =00000008                 18  BS              EQU     $08             Back_space
000000C0  =0000000D                 19  CR              EQU     $0D             Carriage_return
000000C0  =0000000A                 20  LF              EQU     $0A             Line_feed
000000C0  =00000020                 21  SPACE           EQU     $20             Space
000000C0  =00000057                 22  WAIT            EQU     'W'             Wait character (to suspend output)
000000C0  =00000001                 23  CTRL_A          EQU     $01             Control_A forces return to monitor
000000C0                            24  *                                       Device addresses
000000C0  =00004400                 25  STACK           EQU     $4400           Stack_pointer
000000C0  =00008001                 26  ACIA            EQU     $8001           Console ACIA control
000000C0  =00004E4E                 27  TRAP_14         EQU     $4E4E           Code for TRAP #14
000000C0  =00000040                 28  MAXCHR          EQU     64              Length of input line buffer
000000C0  =0008000A                 29  COMMAND         EQU     $8000A          Address of FPU command register
000000C0  =00080000                 30  RESPONSE    EQU  $80000         Address of FPU response register
000000C0  =00080010                 31  OPERAND         EQU     $80010          Address of FPU operand register
000000C0                            32  *
000000C0= 00                        33  SIMMODE     DC.B        0               1 for sim mode 0 for board
000000C1  =00004500                 34  DATA            EQU     $4500           Data origin
000000C1                            35  LNBUFF          DS.B    MAXCHR          Input line buffer
00000101  =00000100                 36  BUFFEND         EQU     LNBUFF+MAXCHR-1 End of line buffer
00000102                            37  BUFFPT          DS.L    1               Pointer to line buffer
00000106                            38  PARAMTR         DS.L    1               Last parameter from line buffer
0000010A                            39  ECHO            DS.B    1               When clear this enable input echo
0000010B                            40  STAR            DS.B    1
0000010C                            41  U_CASE          DS.B    1               Flag for upper case conversion
0000010E                            42  UTAB            DS.L    1               Pointer to user command table
00000112                            43  CN_IVEC         DS.L    1               Pointer to console input DCB
00000116                            44  CN_OVEC         DS.L    1               Pointer to console output DCB
0000011A                            45  TSK_T           DS.W    37              Frame for D0-D7, A0-A6, USP, SSP, SW, PC
00000164                            46  BP_TAB          DS.W    24              Breakpoint table
00000194                            47  FIRST           DS.B    512             DCB area
00000394                            48  BUFFER          DS.B    256             256 bytes for I/O buffer
00000494                            49   
00000494                            50  *   This is the main program which assembles a command in the line
00000494                            51  *   buffer, removes leading/embedded spaces and interprets it by matching
00000494                            52  *   it with a command in the user table or the built-in table COMTAB
00000494                            53  *   All variables are specified with respect to A6
00000494                            54   
00000494                            55   
00001000                            56                  ORG     $1000           Monitor Origin
00001000                            57  _RESET
00001000  =00001000                 58  RESET:          EQU     *
00001000  4DF8 4500                 59                  LEA.L   DATA,A6         A6 points to data area
00001004  2D4E 0152                 60                  MOVE.L  A6,TSK_T+56(A6) initialize A6 in the register Frame
00001008  4DF8 4500                 61                  LEA.L   DATA,A6         A6 points to data area
0000100C  42AE 010E                 62                  CLR.L   UTAB(A6)        Reset pointer to user extension table
00001010  422E 010A                 63                  CLR.B   ECHO(A6)        Set automatic character echo
00001014  422E 010B                 64                  CLR.B   STAR(A6)        Clear this flag for a standard echo
00001018  422E 010C                 65                  CLR.B   U_CASE(A6)      Clear case conversion flag (UC<-LC)
0000101C  6100 015E                 66                  BSR     SETACIA         Setup ACIAs
00001020  6100 071C                 67                  BSR     CLR_BPT         Clear break point table
00001024  6100 05BA                 68                  BSR     SET_DCB         Setup DCB table in RAM
00001028  6100 00B0                 69                  BSR     ALUTest
0000102C  6100 0008                 70                  BSR     RamTest
00001030  4287                      71                          CLR.L   D7
00001032  6100 0C00                 72                  BSR     _mainstart
00001036                            73  *===========================================================================
00001036                            74  *   MEM TEST
00001036                            75   
00001036                            76   
00001036                            77  RamTest
00001036  7AFF                      78                  move.l #$FFFFFFFF, d5
00001038  207C 00004000             79                  move.l #$4000, a0
0000103E                            80                  ;bsr    ClearRam
0000103E                            81                  ;bsr    WriteRam
0000103E  6000 008A                 82                  bra     MemTestEnd
00001042                            83    
00001042                            84  ClearRam
00001042  4290                      85                  clr.l   (a0) 
00001044  0C98 00000000             86                  cmpi.l #0,(a0)+
0000104A  6600 0022                 87                  bne     RamClearError
0000104E  B1FC 00005000             88                  cmp.l   #$5000, a0
00001054  66EC                      89                  bne     ClearRam
00001056  4E75                      90                  rts
00001058                            91          
00001058                            92  WriteRam
00001058  2105                      93                  move.l d5, -(a0)
0000105A  0C90 FFFFFFFF             94                  cmpi.l  #$FFFFFFFF, (a0)
00001060  6600 003A                 95                  bne     RamWriteError
00001064  B1FC 00004000             96                  cmp.l   #$4000, a0
0000106A  66EC                      97                  bne     WriteRam
0000106C  4E75                      98                  rts
0000106E                            99     
0000106E                           100  RamClearError
0000106E                           101                  ; exception message
0000106E  5348                     102                  sub     #$01, a0
00001070  49F9 000023B3            103                  lea.l   ramErrorMessage,a4              
00001076  6100 012A                104                  bsr     PSTRING
0000107A  6100 0116                105                  bsr     NEWLINE  
0000107E  103C 000F                106                  move.b  #15,d0
00001082  143C 0010                107                  move.b  #16,d2
00001086  3848                     108                  move    a0,a4
00001088  6100 0118                109                  bsr     PSTRING
0000108C  6100 0104                110                  bsr     NEWLINE         
00001090  5248                     111                  add     #$01,a0
00001092  B1FC 00005000            112                  cmp.l   #$5000, a0
00001098  66A8                     113                  bne     ClearRam
0000109A  4E75                     114                  rts
0000109C                           115     
0000109C                           116  RamWriteError
0000109C                           117                  ; exception message 
0000109C  103C 000E                118                  move.b  #14,d0          
000010A0  49F9 000023B3            119                  lea.l   ramErrorMessage,a4              
000010A6  6100 00FA                120                  bsr     PSTRING
000010AA  6100 00E6                121                  bsr     NEWLINE  
000010AE  103C 000F                122                  move.b  #15,d0
000010B2  143C 0010                123                  move.b  #16,d2
000010B6  3848                     124                  move    a0,a4
000010B8  6100 00E8                125                  bsr     PSTRING
000010BC  6100 00D4                126                  bsr     NEWLINE         
000010C0  B1FC 00004000            127                  cmp.l   #$4000, a0
000010C6  6690                     128                  bne     WriteRam
000010C8  4E75                     129                  rts
000010CA                           130          
000010CA                           131  MemTestEnd
000010CA  49F9 0000239A            132                  lea     MemTestSuccess,a4
000010D0  6100 00D0                133                  bsr     _PSTRING
000010D4  6100 00BC                134                  bsr     _NEWLINE
000010D8  4E75                     135                  rts
000010DA                           136     
000010DA                           137          
000010DA                           138  *============================================================================
000010DA                           139  *   ALU Test
000010DA                           140   
000010DA                           141  ALUTest:
000010DA  720E                     142                  move.l #14, d1
000010DC                           143     
000010DC  6100 0012                144                  bsr     Add
000010E0  6100 001C                145                  bsr     Subtract
000010E4  6100 0026                146                  bsr     Multiply
000010E8  6100 0032                147                  bsr     Divide
000010EC  6000 007E                148                  bra      EndALUTest
000010F0                           149   
000010F0                           150  Add
000010F0  5E81                     151                  add.l  #7, d1
000010F2  0C81 00000015            152                  cmpi.l #21, d1
000010F8  6600 0032                153                  bne     AddingError
000010FC  4E75                     154                  rts
000010FE                           155          
000010FE                           156  Subtract
000010FE  5F81                     157                  sub.l  #7, d1
00001100  0C81 0000000E            158                  cmpi.l  #14, d1
00001106  6600 0034                159                  bne     SubtractingError
0000110A  4E75                     160                  rts
0000110C                           161  Multiply
0000110C  C3FC 0002                162                  muls.w  #2, d1
00001110  0C81 0000001C            163                  cmpi.l  #28, d1
00001116  6600 0034                164                  bne     MultiplicationError
0000111A  4E75                     165                  rts
0000111C                           166     
0000111C                           167  Divide
0000111C  83FC 0002                168                  divs.w  #2, d1
00001120  0C81 0000000E            169                  cmpi.l  #14, d1
00001126  6600 0034                170                  bne     DivisionError
0000112A  4E75                     171                  rts
0000112C                           172     
0000112C                           173  AddingError     
0000112C  49F9 000022EC            174                  lea     addingErrorMessage,a4   
00001132  6100 006E                175                  bsr     _PSTRING
00001136  6100 005A                176                  bsr     _NEWLINE
0000113A  4E75                     177                  rts
0000113C                           178     
0000113C                           179  SubtractingError        
0000113C  49F9 0000230F            180                  lea     subtractingErrorMessage,a4      
00001142  6100 005E                181                  bsr     _PSTRING
00001146  6100 004A                182                  bsr     _NEWLINE
0000114A  4E75                     183                  rts
0000114C                           184     
0000114C                           185  MultiplicationError             
0000114C  49F9 00002337            186                  lea     multiplyingErrorMessage,a4      
00001152  6100 004E                187                  bsr     _PSTRING
00001156  6100 003A                188                  bsr     _NEWLINE
0000115A  4E75                     189                  rts
0000115C                           190     
0000115C                           191  DivisionError           
0000115C  49F9 0000235F            192                  lea     dividingErrorMessage,a4 
00001162  6100 003E                193                  bsr     _PSTRING
00001166  6100 002A                194                  bsr     _NEWLINE
0000116A  4E75                     195                  rts
0000116C                           196   
0000116C                           197  EndALUTest
0000116C  49F9 00002384            198                  lea     finishedALUTest,a4
00001172  6100 002E                199                  bsr     _PSTRING
00001176  6100 001A                200                  bsr     _NEWLINE
0000117A  4E75                     201                  rts
0000117C                           202   
0000117C                           203  *=============================================================================
0000117C                           204  *   Some initialization and basic routines
0000117C                           205   
0000117C  =0000117C                206  SETACIA         EQU     *               Setup ACIA parameters
0000117C  41F9 00008001            207                  LEA.L   ACIA,A0         A0 points to console ACIA
00001182  10BC 0003                208                  MOVE.B  #$03,(A0)       Reset ACIA
00001186  10BC 0019                209                  MOVE.B  #$19,(A0)       Set up ACIA constants (no IRQ,
0000118A  117C 0019 0001           210                  MOVE.B  #$19,1(A0)      8 bit, even parity, 1 stop, no flowctrl
00001190  4E75                     211                  RTS                      Return
00001192                           212  *=============================================================================
00001192                           213  *   Prints a newline carriage return
00001192                           214   
00001192                           215  _NEWLINE
00001192  =00001192                216  NEWLINE         EQU     *               Move cursor to start of newline
00001192  48E7 0008                217                  MOVEM.L A4,-(A7)        Save A4
00001196  49FA 0BD6                218                  LEA.L   CRLF(PC),A4     Point to CR/LF string
0000119A  6106                     219                  BSR.S   PSTRING         Print it
0000119C  4CDF 1000                220                  MOVEM.L (A7)+,A4        Restore A4
000011A0  4E75                     221                  RTS                     Return
000011A2                           222  _PSTRING
000011A2  =000011A2                223  PSTRING         EQU     *               Display the string pointed at by A4
000011A2  2F00                     224                  MOVE.L  D0,-(A7)        Save D0
000011A4  101C                     225  PS1             MOVE.B  (A4)+,D0        Get character to be printed
000011A6  6706                     226                  BEQ.S   PS2             
000011A8  6100 054A                227                  BSR     PUTCHAR         Else print it
000011AC  60F6                     228                  BRA     PS1             Continue
000011AE  201F                     229  PS2             MOVE.L  (A7)+,D0        Restore D0 and exit
000011B0  4E75                     230                  RTS
000011B2                           231   
000011B2  61DE                     232  HEADING         BSR     NEWLINE         Same as PSTRING but with newline
000011B4  61EC                     233                  BSR     PSTRING
000011B6  60DA                     234                  BRA     NEWLINE
000011B8                           235   
000011B8                           236  *=============================================================================
000011B8                           237  *   GETLINE inputs a string of characters into a line buffer
000011B8                           238  *               A3 points to next free entry in line buffer
000011B8                           239  *               A2 points to end of buffer
000011B8                           240  *               A1 points to start of buffer
000011B8                           241  *               D0 holds character to be stored
000011B8                           242  _GETLINE
000011B8  43EE 00C1                243  GETLINE         LEA.L   LNBUFF(A6),A1   A1 points to start of line buffer
000011BC  47D1                     244                  LEA.L   (A1),A3         A3 points to start (initially)
000011BE  45E9 0040                245                  LEA.L   MAXCHR(A1),A2   A2 points to end of buffer
000011C2  6100 04E8                246  GETLN2          BSR     GETCHAR         Get a character
000011C6  B03C 0001                247                  CMP.B   #CTRL_A,D0      If control_A then reject this line
000011CA  671E                     248                  BEQ.S   GETLN5          and get another line
000011CC  B03C 0008                249                  CMP.B   #BS,D0          If back_space then move back pointer
000011D0  660A                     250                  BNE.S   GETLN3          Else skip past wind-back routine
000011D2  B7C9                     251                  CMP.L   A1,A3           First check for empty buffer
000011D4  67EC                     252                  BEQ     GETLN2          If buffer empty then continue
000011D6  47EB FFFF                253                  LEA     -1(A3),A3       Else decrement buffer pointer
000011DA  60E6                     254                  BRA     GETLN2          and continue with next character
000011DC  16C0                     255  GETLN3          MOVE.B  D0,(A3)+        Store character and update pointer
000011DE  B03C 000D                256                  CMP.B   #CR,D0          Test for command terminator
000011E2  6602                     257                  BNE.S   GETLN4          If not CR then skip past exit
000011E4  60AC                     258                  BRA     NEWLINE         Else new line before next operation
000011E6  B7CA                     259  GETLN4          CMP.L   A2,A3           Test for buffer overflow
000011E8  66D8                     260                  BNE     GETLN2          If buffer not full then continue
000011EA  61A6                     261  GETLN5          BSR     NEWLINE         Else move to next line and
000011EC  60CA                     262                  BRA     GETLINE         repeat this routine
000011EE                           263  *=============================================================================
000011EE                           264  *  GETPASS  inputs a string of characters into a line buffer
000011EE                           265  *               A3 points to next free entry in line buffer
000011EE                           266  *               A2 points to end of buffer
000011EE                           267  *               A1 points to start of buffer
000011EE                           268  *               D0 holds character to be stored
000011EE                           269  *
000011EE                           270  _GETPASS
000011EE  43EE 00C1                271  GETPASS     LEA.L       LNBUFF(A6),A1  A1 points to start of password buffer
000011F2  47D1                     272              LEA.L       (A1),A3         A3 points to start (initially)
000011F4  45E9 0040                273              LEA.L       MAXCHR(A1),A2  A2 points to end of buffer
000011F8  6100 002E                274  GETPS2      BSR         GETSTAR         Get a character
000011FC  B03C 0001                275              CMP.B       #CTRL_A,D0      If control_A then reject this line
00001200  6720                     276              BEQ.S       GETPS5          and get another line
00001202  B03C 0008                277              CMP.B       #BS,D0          If back_space then move back pointer
00001206  660A                     278              BNE.S       GETPS3          Else skip past wind-back routine
00001208  B7C9                     279              CMP.L       A1,A3           First check for empty buffer
0000120A  67EC                     280              BEQ         GETPS2          If buffer empty then continue
0000120C  47EB FFFF                281              LEA         -1(A3),A3       Else decrement buffer pointer
00001210  60E6                     282              BRA         GETPS2          and continue with next character
00001212  16C0                     283  GETPS3      MOVE.B   D0,(A3)+           Store character and update pointer
00001214  B03C 000D                284              CMP.B       #CR,D0          Test for command terminator
00001218  6604                     285              BNE.S       GETPS4          If not CR then skip past exit
0000121A  6000 FF76                286              BRA         NEWLINE         Else new line before next operation
0000121E  B7CA                     287  GETPS4      CMP.L       A2,A3           Test for buffer overflow
00001220  66D6                     288              BNE         GETPS2          If buffer not full then continue
00001222  6100 FF6E                289  GETPS5      BSR         NEWLINE         Else move to next line and
00001226  60C6                     290              BRA         GETPASS         repeat this routine
00001228                           291           
00001228                           292  *************************************************************************
00001228                           293  *
00001228                           294  *  GETSTAR gets a character from the console device
00001228                           295  *  This is the main input routine and uses the device whose name 
00001228                           296  *  is stored in CN_IVEC. Changing this name redirects input.
00001228                           297   
00001228  2F08                     298  GETSTAR     MOVE.L  A0,-(A7)            Save working register
0000122A  206E 0112                299              MOVE.L  CN_IVEC(A6),A0  A0 points to name of console DCB
0000122E  6100 04D4                300              BSR.L   IO_OPEN             Open console (get DCB address in A0)
00001232  0807 0003                301              BTST    #3,D7               D7(3) set if open error
00001236  6636                     302              BNE.S   PASSCH3             If error then exit now
00001238  6100 03F0                303              BSR         IO_REQ          Else execute I/O transaction
0000123C  C03C 007F                304              AND.B   #$7F,D0             Strip msb of input
00001240  4A2E 010C                305              TST.B   U_CASE(A6)          Test for upper -> lower case conversion
00001244  660A                     306              BNE.S   PASSCH2             If flag not zero do not convert case
00001246  0800 0006                307              BTST        #6,D0           Test input for lower case
0000124A  6704                     308              BEQ.S   PASSCH2             If upper case then skip conversion
0000124C  C03C 00DF                309              AND.B   #%11011111,D0   Else clear bit 5 for upper case conv
00001250                           310   
00001250  43F8 00C0                311  PASSCH2     LEA.L       SIMMODE,A1
00001254  1E11                     312              MOVE.B   (A1),D7
00001256                           313   
00001256                           314           if.l d7 <eq> #1 then.s
0000125E  6100 0012                315                  BSR.L   PUTSTAR         Echo the input
00001262  6100 001C                316                  BSR.L   PUTSTARS
00001266                           317           else
0000126A  6100 0014                318                  BSR.L   PUTSTARS
0000126E                           319           endi
0000126E                           320          
0000126E  205F                     321  PASSCH3     MOVE.L  (A7)+,A0            Restore working register
00001270  4E75                     322              RTS                         and return
00001272                           323   
00001272                           324  *************************************************************************
00001272                           325  *
00001272                           326  *  PUTSTAR removes a character to the console device so password is not shown
00001272                           327  *  The name of the output device is in CN_OVEC.
00001272                           328  *
00001272  3F00                     329  PUTSTAR     MOVE.W   D0,-(A7)           Save D0
00001274                           330                  ;MOVE.B   #$2A,D0       Load * into D0
00001274  103C 0008                331                  move.B  #$8,D0
00001278  6100 047A                332                  BSR   PUTCHAR           Print the character
0000127C  301F                     333                  MOVE.W   (A7)+,D0       Restore D0
0000127E  4E75                     334                  RTS
00001280                           335  *************************************************************************
00001280                           336  *
00001280                           337  *  PUTSTARS adds a * to the console device for each character of password
00001280                           338  *  The name of the output device is in CN_OVEC.
00001280                           339  *        
00001280  3F00                     340  PUTSTARS    MOVE.W   D0,-(A7)           Save D0
00001282  103C 002A                341                  MOVE.B   #$2A,D0        Load * into D0
00001286                           342                  ;move.B  #$8,D0
00001286  6100 046C                343                  BSR     PUTCHAR         Print the character
0000128A  301F                     344                  MOVE.W  (A7)+,D0        Restore D0
0000128C  4E75                     345                  RTS
0000128E                           346          
0000128E                           347  * *==============================================================================
0000128E                           348  *
0000128E                           349  *   TIDY        cleans up the line buffer by removing leading spaces and multiple
0000128E                           350  *               spaces between parameters. At the end of TIDY, BUFFPT points to
0000128E                           351  *               the first parameter following the command.
0000128E                           352  *               A0 = pointer to line buffer. A1 = pointer to cleaned up buffer
0000128E                           353  _TIDY
0000128E  41EE 00C1                354  TIDY            LEA.L   LNBUFF(A6),A0   A0 points to line buffer
00001292  43D0                     355                  LEA.L   (A0),A1         A1 points to start of line buffer
00001294  1018                     356  TIDY1           MOVE.B  (A0)+,D0        Read character from line buffer
00001296  B03C 0020                357                  CMP.B   #SPACE,D0       Repeat until the first non-space
0000129A  67F8                     358                  BEQ     TIDY1           character is found
0000129C  41E8 FFFF                359                  LEA.L   -1(A0),A0       Move pointer back to first char
000012A0  1018                     360  TIDY2           MOVE.B  (A0)+,D0        Move the string left to remove
000012A2  12C0                     361                  MOVE.B  D0,(A1)+        any leading spaces
000012A4  B03C 0020                362                  CMP.B   #SPACE,D0       Test for embedded space
000012A8  660A                     363                  BNE.S   TIDY4           If not space then test for EOL
000012AA  0C18 0020                364  TIDY3           CMP.B   #SPACE,(A0)+    If space skip multiple embedded
000012AE  67FA                     365                  BEQ     TIDY3           spaces
000012B0  41E8 FFFF                366                  LEA.L   -1(A0),A0       Move back pointer
000012B4  B03C 000D                367  TIDY4           CMP.B   #CR,D0          Test for end_of_line (EOL)
000012B8  66E6                     368                  BNE     TIDY2           If not EOL then read next char
000012BA  41EE 00C1                369                  LEA.L   LNBUFF(A6),A0   Restore buffer pointer
000012BE  0C10 000D                370  TIDY5           CMP.B   #CR,(A0)        Test for EOL
000012C2  6706                     371                  BEQ.S   TIDY6           If EOL then exit
000012C4  0C18 0020                372                  CMP.B   #SPACE,(A0)+    Test for delimiter
000012C8  66F4                     373                  BNE     TIDY5           Repeat until delimiter or EOL
000012CA  2D48 0102                374  TIDY6           MOVE.L  A0,BUFFPT(A6)   Update buffer pointer
000012CE  4E75                     375                  RTS
000012D0                           376   
000012D0                           377  * *==============================================================================
000012D0                           378  *
000012D0                           379  *   EXECUTE matches the first command in the line buffer with the
000012D0                           380  *               commands in a command table. An external table pointed at by
000012D0                           381  *               UTAB is searched first and then the in-built table, COMTAB.
000012D0                           382  _EXECUTE
000012D0  4AAE 010E                383  EXECUTE         TST.L   UTAB(A6)        Test pointer to user table
000012D4  670C                     384                  BEQ.S   EXEC1           If clear then try built-in table
000012D6  266E 010E                385                  MOVE.L  UTAB(A6),A3     Else pick up pointer to user table
000012DA  6120                     386                  BSR.S   SEARCH          Look for command in user table
000012DC  6404                     387                  BCC.S   EXEC1           If not found then try internal table
000012DE  2653                     388                  MOVE.L  (A3),A3         Else get absolute address of command
000012E0  4ED3                     389                  JMP     (A3)            from user table and execute it
000012E2                           390  *
000012E2  47FA 09D2                391  EXEC1           LEA.L   COMTAB(PC),A3   Try built-in command table
000012E6  6114                     392                  BSR.S   SEARCH          Look for command in built-in table
000012E8  6508                     393                  BCS.S   EXEC2           If found then execute command
000012EA  49FA 0B93                394                  LEA.L   ERMES2(PC),A4   Else print "invalid command"
000012EE  6000 FEB2                395                  BRA.L   PSTRING         and return
000012F2  2653                     396  EXEC2           MOVE.L  (A3),A3         Get the relative command address
000012F4  49FA 09C0                397                  LEA.L   COMTAB(PC),A4   pointed at by A3 and add it to
000012F8  D7CC                     398                  ADD.L   A4,A3           the PC to generate the actual
000012FA  4ED3                     399                  JMP     (A3)            command address. Then execute it.
000012FC                           400  *
000012FC  =000012FC                401  SEARCH          EQU     *               Match the command in the line buffer
000012FC  4280                     402                  CLR.L   D0              with command table pointed at by A3
000012FE  1013                     403                  MOVE.B  (A3),D0         Get the first character in the
00001300  6734                     404                  BEQ.S   SRCH7           current entry. If zero then exit
00001302  49F3 0006                405                  LEA.L   6(A3,D0.W),A4   Else calculate address of next entry
00001306  122B 0001                406                  MOVE.B  1(A3),D1        Get number of characters to match
0000130A  4BEE 00C1                407                  LEA.L   LNBUFF(A6),A5   A5 points to command in line buffer
0000130E  142B 0002                408                  MOVE.B  2(A3),D2        Get first character in this entry
00001312  B41D                     409                  CMP.B   (A5)+,D2        from the table and match with buffer
00001314  6704                     410                  BEQ.S   SRCH3           If match then try rest of string
00001316  264C                     411  SRCH2           MOVE.L  A4,A3           Else get address of next entry
00001318  60E2                     412                  BRA      SEARCH          and try the next entry in the table
0000131A  5301                     413  SRCH3           SUB.B   #1,D1           One less character to match
0000131C  670E                     414                  BEQ.S   SRCH6           If match counter zero then all done
0000131E  47EB 0003                415                  LEA.L   3(A3),A3        Else point to next character in table
00001322  141B                     416  SRCH4           MOVE.B  (A3)+,D2        Now match a pair of characters
00001324  B41D                     417                  CMP.B   (A5)+,D2
00001326  66EE                     418                  BNE     SRCH2           If no match then try next entry
00001328  5301                     419                  SUB.B   #1,D1           Else decrement match counter and
0000132A  66F6                     420                  BNE     SRCH4           repeat until no chars left to match
0000132C  47EC FFFC                421  SRCH6           LEA.L   -4(A4),A3       Calculate address of command entry
00001330  003C 0001                422                  OR.B    #1,CCR          point. Mark carry flag as success
00001334  4E75                     423                  RTS                     and return
00001336  023C 00FE                424  SRCH7           AND.B   #$FE,CCR        Fail - clear carry to indicate
0000133A  4E75                     425                  RTS                     command not found and return
0000133C                           426   *=============================================================================
0000133C                           427  *   Basic input routines
0000133C                           428  *   HEX =  Get one   hexadecimal character  into D0
0000133C                           429  *   BYTE   =  Get two   hexadecimal characters into D0
0000133C                           430  *   WORD   =  Get four  hexadecimal characters into D0
0000133C                           431  *   LONGWD =  Get eight hexadecimal characters into D0
0000133C                           432  *   PARAM  =  Get a longword from the line buffer into D0
0000133C                           433  *   Bit 0 of D7 is set to indicate a hexadecimal input error
0000133C                           434   
0000133C  6100 036E                435  HEX             BSR     GETCHAR         Get a character from input device
00001340  0400 0030                436                  SUB.B   #$30,D0         Convert to binary
00001344  6B0E                     437                  BMI.S   NOT_HEX         If less than $30 then exit with error
00001346  B03C 0009                438                  CMP.B   #$09,D0         Else test for number (0 to 9)
0000134A  6F0C                     439                  BLE.S   HEX_OK          If number then exit - success
0000134C  5F00                     440                  SUB.B   #$07,D0         Else convert letter to hex
0000134E  B03C 000F                441                  CMP.B   #$0F,D0         If character in range "A" to "F"
00001352  6F04                     442                  BLE.S   HEX_OK          then exit successfully
00001354  8E3C 0001                443  NOT_HEX         OR.B    #1,D7           Else set error flag
00001358  4E75                     444  HEX_OK          RTS                     and return
0000135A                           445   
0000135A  2F01                     446  BYTE            MOVE.L  D1,-(A7)        Save D1
0000135C  61DE                     447                  BSR     HEX             Get first hex character
0000135E  E900                     448                  ASL.B   #4,D0           Move it to MS nybble position
00001360  1200                     449                  MOVE.B  D0,D1           Save MS nybble in D1
00001362  61D8                     450                  BSR     HEX             Get second hex character
00001364  D001                     451                  ADD.B   D1,D0           Merge MS and LS nybbles
00001366  221F                     452          MOVE.L  (A7)+,D1        Restore D1
00001368  4E75                     453          RTS
0000136A                           454   
0000136A  61EE                     455  WORD    BSR     BYTE              Get upper order byte
0000136C  E140                     456          ASL.W   #8,D0           Move it to MS position
0000136E  60EA                     457          BRA     BYTE            Get LS byte and return
00001370                           458  *
00001370  61F8                     459  LONGWD  BSR     WORD            Get upper order word
00001372  4840                     460          SWAP    D0              Move it to MS position
00001374  60F4                     461          BRA     WORD            Get lower order word and return
00001376                           462   
00001376                           463  *=============================================================================
00001376                           464  *   PARAM reads a parameter from the line buffer and puts it in both
00001376                           465  *   PARAMTR(A6) and D0. Bit 1 of D7 is set on error.
00001376                           466   
00001376  2F01                     467  PARAM   MOVE.L  D1,-(A7)        Save D1
00001378  4281                     468          CLR.L   D1              Clear input accumulator
0000137A  206E 0102                469          MOVE.L  BUFFPT(A6),A0   A0 points to parameter in buffer
0000137E  1018                     470  PARAM1  MOVE.B  (A0)+,D0        Read character from line buffer
00001380  B03C 0020                471          CMP.B   #SPACE,D0       Test for delimiter
00001384  6720                     472          BEQ.S   PARAM4          The permitted delimiter is a
00001386  B03C 000D                473          CMP.B   #CR,D0          space or a carriage return
0000138A  671A                     474          BEQ.S   PARAM4          Exit on either space or C/R
0000138C  E981                     475          ASL.L   #4,D1           Shift accumulated result 4 bits left
0000138E  0400 0030                476          SUB.B   #$30,D0         Convert new character to hex
00001392  6B1E                     477          BMI.S   PARAM5          If less than $30 then not-hex
00001394  B03C 0009                478          CMP.B   #$09,D0         If less than 10
00001398  6F08                     479          BLE.S   PARAM3          then continue
0000139A  5F00                     480          SUB.B   #$07,D0            Else assume $A - $F
0000139C  B03C 000F                481          CMP.B   #$0F,D0         If more than $F
000013A0  6E10                     482          BGT.S   PARAM5          then exit to error on not-hex
000013A2  D200                     483  PARAM3  ADD.B   D0,D1           Add latest nybble to total in D1
000013A4  60D8                     484          BRA     PARAM1          Repeat until delimiter found
000013A6  2D48 0102                485  PARAM4  MOVE.L  A0,BUFFPT(A6)   Save pointer in memory
000013AA  2D41 0106                486          MOVE.L  D1,PARAMTR(A6)  Save parameter in memory
000013AE  2001                     487          MOVE.L  D1,D0           Put parameter in D0 for return
000013B0  6004                     488          BRA.S   PARAM6          Return without error
000013B2  8E3C 0002                489  PARAM5  OR.B    #2,D7          Set error flag before return
000013B6  221F                     490  PARAM6  MOVE.L  (A7)+,D1        Restore working register
000013B8  4E75                     491          RTS                     Return with error
000013BA                           492  *============================================================================
000013BA                           493  *
000013BA                           494  *   Output routines
000013BA                           495  *   OUT1X   = print one   hexadecimal character
000013BA                           496  *   OUT2X   = print two   hexadecimal characters
000013BA                           497  *   OUT4X   = print four  hexadecimal characters
000013BA                           498  *   OUT8X   = print eight hexadecimal characters
000013BA                           499  *   In each case, the data to be printed is in D0
000013BA                           500   
000013BA  3F00                     501  OUT1X   MOVE.W  D0,-(A7)        Save D0
000013BC  C03C 000F                502          AND.B   #$0F,D0         Mask off MS nybble
000013C0  0600 0030                503          ADD.B   #$30,D0         Convert to ASCII
000013C4  B03C 0039                504          CMP.B   #$39,D0         ASCII = HEX + $30
000013C8  6302                     505          BLS.S   OUT1X1          If ASCII <= $39 then print and exit
000013CA  5E00                     506          ADD.B   #$07,D0         Else ASCII := HEX + 7
000013CC  6100 0326                507  OUT1X1  BSR     PUTCHAR         Print the character
000013D0  301F                     508          MOVE.W  (A7)+,D0        Restore D0
000013D2  4E75                     509          RTS
000013D4                           510  *
000013D4  E818                     511  OUT2X   ROR.B   #4,D0           Get MS nybble in LS position
000013D6  61E2                     512          BSR     OUT1X           Print MS nybble
000013D8  E918                     513             ROL.B   #4,D0        Restore LS nybble
000013DA  60DE                     514          BRA     OUT1X           Print LS nybble and return
000013DC                           515  *
000013DC  E058                     516  OUT4X   ROR.W   #8,D0           Get MS byte in LS position
000013DE  61F4                     517          BSR     OUT2X           Print MS byte
000013E0  E158                     518          ROL.W   #8,D0           Restore LS byte
000013E2  60F0                     519          BRA     OUT2X           Print LS byte and return
000013E4                           520  *
000013E4  4840                     521  OUT8X   SWAP    D0              Get MS word in LS position
000013E6  61F4                     522          BSR     OUT4X           Print MS word
000013E8  4840                     523          SWAP    D0              Restore LS word
000013EA  60F0                     524          BRA     OUT4X           Print LS word and return
000013EC                           525   *=============================================================================
000013EC                           526  *   JUMP causes execution to begin at the address in the line buffer
000013EC                           527   
000013EC  6188                     528  JUMP    BSR     PARAM           Get address from buffer
000013EE  4A07                     529          TST.B   D7              Test for input error
000013F0  6608                     530          BNE.S   JUMP1           If error flag not zero then exit
000013F2  4A80                     531          TST.L   D0              Else test for missing address
000013F4  6704                     532          BEQ.S   JUMP1           field. If no address then exit
000013F6  2040                     533          MOVE.L  D0,A0           Put jump address in A0 and call the
000013F8  4ED0                     534          JMP     (A0)            subroutine. User to supply RTS!!
000013FA  49FA 0A65                535  JUMP1   LEA.L   ERMES1(PC),A4   Here for error - display error
000013FE  6000 FDA2                536          BRA     PSTRING         message and return
00001402                           537   *=============================================================================
00001402                           538  *   Display the contents of a memory location and modify it
00001402                           539   
00001402  6100 FF72                540  MEMORY  BSR     PARAM           Get start address from line buffer
00001406  4A07                     541          TST.B   D7              Test for input error
00001408  6634                     542          BNE.S   MEM3            If error then exit
0000140A  2640                     543          MOVE.L  D0,A3           A3 points to location to be opened
0000140C  6100 FD84                544  MEM1    BSR     NEWLINE
00001410  612E                     545          BSR.S   ADR_DAT         Print current address and contents
00001412  6140                     546          BSR.S   PSPACE          update pointer, A3, and O/P space
00001414  6100 0296                547          BSR     GETCHAR         Input char to decide next action
00001418  B03C 000D                548          CMP.B   #CR,D0          If carriage return then exit
0000141C  6720                     549          BEQ.S   MEM3            Exit
0000141E  B03C 002D                550          CMP.B   #'-',D0         If "-" then move back
00001422  6606                     551          BNE.S   MEM2            Else skip wind-back procedure
00001424  47EB FFFC                552          LEA.L   -4(A3),A3       Move pointer back 2+2
00001428  60E2                     553          BRA     MEM1            Repeat until carriage return
0000142A  B03C 0020                554  MEM2    CMP.B   #SPACE,D0       Test for space (= new entry)
0000142E  66DC                     555          BNE.S   MEM1            If not space then repeat
00001430  6100 FF38                556          BSR     WORD            Else get new word to store
00001434  4A07                     557          TST.B   D7              Test for input error
00001436  6606                     558          BNE.S   MEM3            If error then exit
00001438  3740 FFFE                559          MOVE.W  D0,-2(A3)       Store new word
0000143C  60CE                     560          BRA     MEM1            Repeat until carriage return
0000143E  4E75                     561  MEM3    RTS
00001440                           562   
00001440  2F00                     563  ADR_DAT MOVE.L  D0,-(A7)        Print the contents of A3 and the
00001442  200B                     564          MOVE.L  A3,D0           word pointed at by A3.
00001444  619E                     565          BSR     OUT8X           and print current address
00001446  610C                     566          BSR.S   PSPACE          Insert delimiter
00001448  3013                     567          MOVE.W  (A3),D0         Get data at this address in D0
0000144A  6190                     568          BSR     OUT4X           and print it
0000144C  47EB 0002                569          LEA.L   2(A3),A3        Point to next address to display
00001450  201F                     570          MOVE.L  (A7)+,D0        Restore D0
00001452  4E75                     571          RTS
00001454                           572   
00001454  1F00                     573  PSPACE  MOVE.B  D0,-(A7)        Print a single space
00001456  103C 0020                574          MOVE.B  #SPACE,D0
0000145A  6100 0298                575          BSR     PUTCHAR
0000145E  101F                     576          MOVE.B  (A7)+,D0
00001460  4E75                     577          RTS
00001462                           578   *=============================================================================
00001462                           579  *   LOAD        Loads data formatted in hexadecimal "S" format from Port 2
00001462                           580  *               NOTE - I/O is automatically redirected to the aux port for
00001462                           581  *               loader functions. S1 or S2 records accepted
00001462                           582  _LOAD
00001462  2F2E 0116                583  LOAD    MOVE.L  CN_OVEC(A6),-(A7)   Save current output device name
00001466  2F2E 0112                584          MOVE.L  CN_IVEC(A6),-(A7)   Save current input device name
0000146A  522E 010A                585          ADD.B   #1,ECHO(A6)             Turn off character echo
0000146E  6100 FD22                586          BSR     NEWLINE                 Send newline to host
00001472  6100 015A                587          BSR     DELAY                   Wait for host to "settle"
00001476  6100 0156                588          BSR     DELAY
0000147A  286E 0102                589          MOVE.L  BUFFPT(A6),A4           Any string in the line buffer is
0000147E  101C                     590  LOAD1   MOVE.B  (A4)+,D0                transmitted to the host computer
00001480  6100 0272                591          BSR     PUTCHAR                 before the loading begins
00001484  B03C 000D                592          CMP.B   #CR,D0                  Read from the buffer until EOL
00001488  66F4                     593          BNE     LOAD1
0000148A  6100 FD06                594          BSR     NEWLINE                 Send newline before loading
0000148E  6100 021C                595  LOAD2   BSR     GETCHAR                 Records from the host must begin
00001492  B03C 0053                596          CMP.B   #'S',D0                 with S1/S2 (data) or S9/S8 (term)
00001496  66F6                     597          BNE.S   LOAD2                   Repeat GETCHAR until char = "S"
00001498  6100 0212                598          BSR     GETCHAR                 Get character after "S"
0000149C  B03C 0039                599          CMP.B   #'9',D0                 Test for the two terminators S9/S8
000014A0  6706                     600          BEQ.S   LOAD3                   If S9 record then exit else test
000014A2  B03C 0038                601          CMP.B   #'8',D0                 for S8 terminator. Fall through to
000014A6  662A                     602          BNE.S   LOAD6                   exit on S8 else continue search
000014A8  =000014A8                603  LOAD3   EQU     *                       Exit point from LOAD
000014A8  2D5F 0112                604          MOVE.L  (A7)+,CN_IVEC(A6)   Clean up by restoring input device
000014AC  2D5F 0116                605          MOVE.L  (A7)+,CN_OVEC(A6)   and output device name
000014B0  422E 010A                606          CLR.B   ECHO(A6)                Restore input character echo
000014B4  0807 0000                607          BTST    #0,D7                   Test for input errors
000014B8  6708                     608          BEQ.S   LOAD4                   If no I/P error then look at checksum
000014BA  49FA 09A5                609          LEA.L   ERMES1(PC),A4           Else point to error message
000014BE  6100 FCE2                610          BSR     PSTRING                 Print it
000014C2  0807 0003                611  LOAD4   BTST    #3,D7                   Test for checksum error
000014C6  6708                     612          BEQ.S   LOAD5                   If clear then exit
000014C8  49FA 09C7                613          LEA.L   ERMES3(PC),A4           Else point to error message
000014CC  6100 FCD4                614          BSR     PSTRING                 Print it and return
000014D0  4E75                     615  LOAD5   RTS
000014D2                           616   
000014D2  B03C 0031                617  LOAD6   CMP.B   #'1',D0                 Test for S1 record
000014D6  671E                     618          BEQ.S   LOAD6A                  If S1 record then read it
000014D8  B03C 0032                619          CMP.B   #'2',D0                 Else test for S2 record
000014DC  66B0                     620          BNE.S   LOAD2                   Repeat until valid header found
000014DE  4203                     621          CLR.B   D3                      Read the S2 byte count and address,
000014E0  613C                     622          BSR.S   LOAD8                   clear the checksum
000014E2  5900                     623          SUB.B   #4,D0                   Calculate size of data field
000014E4  1400                     624          MOVE.B  D0,D2                   D2 contains data bytes to read
000014E6  4280                     625          CLR.L   D0                      Clear address accumulator
000014E8  6134                     626          BSR.S   LOAD8                   Read most sig byte of address
000014EA  E180                     627          ASL.L   #8,D0                   Move it one byte left
000014EC  6130                     628          BSR.S   LOAD8                   Read the middle byte of address
000014EE  E180                     629          ASL.L   #8,D0                   Move it one byte left
000014F0  612C                     630          BSR.S   LOAD8                   Read least sig byte of address
000014F2  2440                     631          MOVE.L  D0,A2                   A2 points to destination of record
000014F4  6012                     632          BRA.S   LOAD7                   Skip past S1 header loader
000014F6  4203                     633  LOAD6A  CLR.B   D3                      S1 record found - clear checksum
000014F8  6124                     634          BSR.S   LOAD8                   Get byte and update checksum
000014FA  5700                     635          SUB.B   #3,D0                   Subtract 3 from record length
000014FC  1400                     636          MOVE.B  D0,D2                 Save byte count in D2
000014FE  4280                     637          CLR.L   D0                      Clear address accumulator
00001500  611C                     638          BSR.S   LOAD8                   Get MS byte of load address
00001502  E180                     639          ASL.L   #8,D0                   Move it to MS position
00001504  6118                     640          BSR.S   LOAD8                   Get LS byte in D2
00001506  2440                     641          MOVE.L  D0,A2                   A2 points to destination of data
00001508  6114                     642  LOAD7   BSR.S   LOAD8                   Get byte of data for loading
0000150A  14C0                     643          MOVE.B  D0,(A2)+                Store it
0000150C  5302                     644          SUB.B   #1,D2                   Decrement byte counter
0000150E  66F8                     645          BNE     LOAD7                   Repeat until count = 0
00001510  610C                     646          BSR.S   LOAD8                   Read checksum
00001512  5203                     647          ADD.B   #1,D3                   Add 1 to total checksum
00001514  6700 FF78                648          BEQ     LOAD2                   If zero then start next record
00001518  8E3C 0008                649          OR.B    #%00001000,D7           Else set checksum error bit,
0000151C  608A                     650          BRA     LOAD3                   restore I/O devices and return
0000151E                           651  *
0000151E  6100 FE3A                652  LOAD8   BSR     BYTE                    Get a byte
00001522  D600                     653          ADD.B   D0,D3                   Update checksum
00001524  4E75                     654          RTS                             and return
00001526                           655   *=============================================================================
00001526                           656  *   DUMP        Transmit S1 formatted records to host computer
00001526                           657  *               A3 = Starting address of data block
00001526                           658  *               A2 = End address of data block
00001526                           659  *               D1 = Checksum, D2 = current record length
00001526                           660   
00001526  6100 0096                661  DUMP    BSR     RANGE                   Get start and end address
0000152A  4A07                     662          TST.B   D7                      Test for input error
0000152C  6708                     663          BEQ.S   DUMP1                   If no error then continue
0000152E  49FA 0931                664          LEA.L   ERMES1(PC),A4           Else point to error message,
00001532  6000 FC6E                665          BRA     PSTRING                 print it and return
00001536  B08B                     666  DUMP1   CMP.L   A3,D0                   Compare start and end addresses
00001538  6A08                     667          BPL.S   DUMP2                   If positive then start < end
0000153A  49FA 09A5                668          LEA.L   ERMES7(PC),A4           Else print error message
0000153E  6000 FC62                669          BRA     PSTRING                 and return
00001542  2F2E 0116                670  DUMP2   MOVE.L  CN_OVEC(A6),-(A7)   Save name of current output device
00001546  2D7C 00001D5C 0116       671          MOVE.L  #DCB2,CN_OVEC(A6)   Set up Port as output device
0000154E  6100 FC42                672          BSR     NEWLINE                 Send newline to host and wait
00001552  617A                     673          BSR.S   DELAY
00001554  286E 0102                674          MOVE.L  BUFFPT(A6),A4           Before dumping, send any string
00001558  101C                     675  DUMP3   MOVE.B  (A4)+,D0                in the input buffer to the host
0000155A  6100 0198                676          BSR     PUTCHAR                 Repeat
0000155E  B03C 000D                677          CMP.B   #CR,D0                  Transmit char from buffer to host
00001562  66F4                     678          BNE     DUMP3                   Until char = C/R
00001564  6100 FC2C                679          BSR     NEWLINE
00001568  6164                     680          BSR.S   DELAY                   Allow time for host to settle
0000156A  528A                     681          ADDQ.L  #1,A2                   A2 contains length of record + 1
0000156C  240A                     682  DUMP4   MOVE.L  A2,D2            D2 points to end address
0000156E  948B                     683          SUB.L   A3,D2                   D2 contains bytes left to print
00001570  B4BC 00000011            684          CMP.L   #17,D2                  If this is not a full record of 16
00001576  6502                     685          BCS.S   DUMP5                   then load D2 with record size
00001578  7410                     686          MOVEQ   #16,D2                  Else preset byte count to 16
0000157A  49FA 07FD                687  DUMP5   LEA.L   HEADER(PC),A4           Point to record header
0000157E  6100 FC22                688          BSR     PSTRING                 Print header
00001582  4201                     689          CLR.B   D1                      Clear checksum
00001584  1002                     690          MOVE.B  D2,D0                   Move record length to output register
00001586  5600                     691          ADD.B   #3,D0                   Length includes address + count
00001588  612E                     692          BSR.S   DUMP7                   Print number of bytes in record
0000158A  200B                     693          MOVE.L  A3,D0                   Get start address to be printed
0000158C  E158                     694          ROL.W   #8,D0            Get MS byte in LS position
0000158E  6128                     695          BSR.S   DUMP7                   Print MS byte of address
00001590  E058                     696          ROR.W   #8,D0                   Restore LS byte
00001592  6124                     697          BSR.S   DUMP7                   Print LS byte of address
00001594  101B                     698  DUMP6   MOVE.B  (A3)+,D0                Get data byte to be printed
00001596  6120                     699          BSR.S   DUMP7                   Print it
00001598  5302                     700          SUB.B   #1,D2                   Decrement byte count
0000159A  66F8                     701          BNE     DUMP6                   Repeat until all this record printed
0000159C  4601                     702          NOT.B   D1                      Complement checksum
0000159E  1001                     703          MOVE.B  D1,D0                   Move to output register
000015A0  6116                     704          BSR.S   DUMP7                   Print checksum
000015A2  6100 FBEE                705          BSR     NEWLINE
000015A6  B7CA                     706          CMP.L   A2,A3                   Have all records been printed?
000015A8  66C2                     707          BNE     DUMP4                   Repeat until all done
000015AA  49FA 07D3                708          LEA.L   TAIL(PC),A4             Point to message tail (S9 record)
000015AE  6100 FBF2                709          BSR     PSTRING                 Print it
000015B2  2D5F 0116                710          MOVE.L  (A7)+,CN_OVEC(A6)   Restore name of output device
000015B6  4E75                     711          RTS                             and return
000015B8                           712   
000015B8  D200                     713  DUMP7   ADD.B   D0,D1                 Update checksum, transmit byte
000015BA  6000 FE18                714          BRA     OUT2X                   to host and return
000015BE                           715   
000015BE  =000015BE                716  RANGE   EQU     *                       Get the range of addresses to be
000015BE  4207                     717          CLR.B   D7                      transmitted from the buffer
000015C0  6100 FDB4                718          BSR     PARAM                 Get starting address
000015C4  2640                     719          MOVE.L  D0,A3                   Set up start address in A3
000015C6  6100 FDAE                720          BSR     PARAM                   Get end address
000015CA  2440                     721          MOVE.L  D0,A2                   Set up end address in A2
000015CC  4E75                     722          RTS
000015CE                           723   
000015CE  =000015CE                724  DELAY   EQU     *                       Provide a time delay for the host
000015CE  48E7 8008                725          MOVEM.L D0/A4,-(A7)             to settle. Save working registers
000015D2  203C 00004000            726          MOVE.L  #$4000,D0               Set up delay constant
000015D8  5380                     727  DELAY1  SUB.L   #1,D0                   Count down      (8 clk cycles)
000015DA  66FC                     728          BNE     DELAY1                  Repeat until zero  (10 clk cycles)
000015DC  4CDF 1001                729          MOVEM.L (A7)+,D0/A4             Restore working registers
000015E0                           730   *=============================================================================
000015E0                           731  *   This routine sets up the system DCBs in RAM using the information
000015E0                           732  *   stored in ROM at address DCB_LST. This is called at initialization.
000015E0                           733  *   CN_IVEC contains the name "DCB1" and IO_VEC the name "DCB2"
000015E0                           734   
000015E0  48E7 F0F0                735  SET_DCB MOVEM.L A0-A3/D0-D3,-(A7)   Save all working registers
000015E4  41EE 0194                736          LEA.L   FIRST(A6),A0            Pointer to first DCB destination in RAM
000015E8  43FA 0760                737          LEA.L   DCB_LST(PC),A1          A1 points to DCB info block in ROM
000015EC  303C 0001                738          MOVE.W  #1,D0                   2 DCBs to set up
000015F0  323C 000F                739  ST_DCB1 MOVE.W  #15,D1                  16 bytes to move per DCB header
000015F4  10D9                     740  ST_DCB2 MOVE.B  (A1)+,(A0)+             Move the 16 bytes of a DCB header
000015F6  51C9 FFFC                741          DBRA    D1,ST_DCB2              from ROM to RAM
000015FA  3619                     742          MOVE.W  (A1)+,D3                Get size of parameter block (bytes)
000015FC  3083                     743          MOVE.W  D3,(A0)                 Store size in DCB in RAM
000015FE  41F0 3002                744          LEA.L   2(A0,D3.W),A0           A0 points to tail of DCB in RAM
00001602  47E8 0004                745          LEA.L   4(A0),A3                A3 contains address of next DCB in RAM
00001606  208B                     746          MOVE.L  A3,(A0)                 Store pointer to next DCB in this DCB
00001608  41D3                     747          LEA.L   (A3),A0                 A0 now points at next DCB in RAM
0000160A  51C8 FFE4                748          DBRA    D0,ST_DCB1              Repeat until all DCBs set up
0000160E  47EB FFFC                749          LEA.L   -4(A3),A3               Adjust A3 to point to last DCB pointer
00001612  4293                     750          CLR.L   (A3)                    and force last pointer to zero
00001614  2D7C 00001D4A 0112       751          MOVE.L  #DCB1,CN_IVEC(A6)   Set up vector to console input DCB
0000161C  2D7C 00001D5C 0116       752          MOVE.L  #DCB2,CN_OVEC(A6)   Set up vector to console output DCB
00001624  4CDF 0F0F                753          MOVEM.L (A7)+,A0-A3/D0-D3   Restore registers
00001628  4E75                     754          RTS
0000162A                           755   *=============================================================================
0000162A                           756  *   IO_REQ handles all input/output transactions. A0 points to DCB on
0000162A                           757  *   entry. IO_REQ calls the device driver whose address is in the DCB.
0000162A                           758   
0000162A  48E7 00C0                759  IO_REQ  MOVEM.L A0-A1,-(A7)     Save working registers
0000162E  43E8 0008                760          LEA.L   8(A0),A1        A1 points to device handler field in DCB
00001632  2251                     761          MOVE.L  (A1),A1         A1 contains device handler address
00001634  4E91                     762          JSR     (A1)            Call device handler
00001636  4CDF 0300                763          MOVEM.L (A7)+,A0-A1     Restore working registers
0000163A  4E75                     764          RTS
0000163C                           765   *=============================================================================
0000163C                           766  *   CON_IN handles input from the console device
0000163C                           767  *   This is the device driver used by DCB1. Exit with input in D0
0000163C                           768   
0000163C  48E7 4040                769  CON_IN  MOVEM.L D1/A1,-(A7)     Save working registers
00001640  43E8 000C                770          LEA.L   12(A0),A1       Get pointer to ACIA from DCB
00001644  2251                     771          MOVE.L  (A1),A1         Get address of ACIA in A1
00001646  4228 0013                772          CLR.B   19(A0)          Clear logical error in DCB
0000164A  1211                     773  CON_I1  MOVE.B  (A1),D1         Read ACIA status
0000164C  0801 0000                774          BTST    #0,D1           Test RDRF
00001650  67F8                     775          BEQ     CON_I1          Repeat until RDRF true
00001652  1141 0012                776          MOVE.B  D1,18(A0)       Store physical status in DCB
00001656  C23C 00F4                777          AND.B   #%011110100,D1  Mask to input error bits
0000165A  6706                     778          BEQ.S   CON_I2          If no error then skip update
0000165C  117C 0001 0013           779          MOVE.B  #1,19(A0)       Else update logical error
00001662  1029 0002                780  CON_I2  MOVE.B  2(A1),D0        Read input from ACIA
00001666  4CDF 0202                781          MOVEM.L (A7)+,A1/D1     Restore working registers
0000166A  4E75                     782          RTS
0000166C                           783   *=============================================================================
0000166C                           784  *   This is the device driver used by DCB2. Output in D0
0000166C                           785  *   The output can be halted or suspended
0000166C                           786   
0000166C  48E7 6040                787  CON_OUT MOVEM.L A1/D1-D2,-(A7)  Save working registers
00001670  43E8 000C                788          LEA.L   12(A0),A1       Get pointer to ACIA from DCB
00001674  2251                     789          MOVE.L  (A1),A1         Get address of ACIA in A1
00001676  4228 0013                790          CLR.B   19(A0)          Clear logical error in DCB
0000167A  1211                     791  CON_OT1 MOVE.B  (A1),D1         Read ACIA status
0000167C  0801 0000                792          BTST    #0,D1           Test RDRF bit (any input?)
00001680  6716                     793          BEQ.S   CON_OT3         If no input then test output status
00001682  1429 0002                794          MOVE.B  2(A1),D2        Else read the input
00001686  C43C 005F                795          AND.B   #%01011111,D2   Strip parity and bit 5
0000168A  B43C 0057                796          CMP.B   #WAIT,D2        and test for a wait condition
0000168E  6608                     797          BNE.S   CON_OT3         If not wait then ignore and test O/P
00001690  1411                     798  CON_OT2 MOVE.B  (A1),D2         Else read ACIA status register
00001692  0802 0000                799          BTST    #0,D2           and poll ACIA until next char received
00001696  67F8                     800          BEQ     CON_OT2
00001698  0801 0001                801  CON_OT3 BTST    #1,D1           Repeat
0000169C  67DC                     802          BEQ     CON_OT1         until ACIA Tx ready
0000169E  1141 0012                803          MOVE.B  D1,18(A0)       Store status in DCB physical error
000016A2  1340 0002                804          MOVE.B  D0,2(A1)        Transmit output
000016A6  4CDF 0206                805          MOVEM.L (A7)+,A1/D1-D2  Restore working registers
000016AA  4E75                     806          RTS
000016AC                           807   
000016AC                           808   *============================================================================
000016AC                           809  *   GETCHAR gets a character from the console device
000016AC                           810  *   This is the main input routine and uses the device whose name
000016AC                           811  *   is stored in CN_IVEC. Changing this name redirects input.
000016AC                           812   
000016AC  2F08                     813  GETCHAR MOVE.L  A0,-(A7)        Save working register
000016AE  206E 0112                814          MOVE.L  CN_IVEC(A6),A0  A0 points to name of console DCB
000016B2  6150                     815          BSR.S   IO_OPEN         Open console (get DCB address in A0)
000016B4  0807 0003                816          BTST    #3,D7           D7(3) set if open error
000016B8  6636                     817          BNE.S   GETCH3          If error then exit now
000016BA  6100 FF6E                818          BSR     IO_REQ          Else execute I/O transaction
000016BE  C03C 007F                819          AND.B   #$7F,D0         Strip msb of input
000016C2  4A2E 010C                820          TST.B   U_CASE(A6)      Test for upper -> lower case conversion
000016C6  660A                     821          BNE.S   GETCH2          If flag not zero do not convert case
000016C8  0800 0006                822          BTST    #6,D0           Test input for lower case
000016CC  6704                     823          BEQ.S   GETCH2          If upper case then skip conversion
000016CE  C03C 00DF                824          AND.B   #%11011111,D0   Else clear bit 5 for upper case conv
000016D2  4A2E 010A                825  GETCH2  TST.B   ECHO(A6)        Do we need to echo the input?
000016D6  6618                     826          BNE.S   GETCH3          If ECHO not zero then no echo
000016D8  4A2E 010B                827          TST.B   STAR(A6)        Test if echoing an * for a password
000016DC  6700 0010                828          BEQ     SKIP            Branch to standard echo if not a password
000016E0  3F00                     829          MOVE    D0,-(A7)        Save input char to stack
000016E2  103C 002A                830          MOVE.B  #42,D0          load an * char
000016E6  610C                     831          BSR.S   PUTCHAR         Echo the *
000016E8  301F                     832          MOVE    (A7)+,D0        Retrieve the input char from stack
000016EA  6000 0004                833          BRA     GETCH3          Goto exit
000016EE  6104                     834  SKIP    BSR.S   PUTCHAR         Else echo the input
000016F0  205F                     835  GETCH3  MOVE.L  (A7)+,A0        Restore working register
000016F2  4E75                     836          RTS                     and return
000016F4                           837   *=============================================================================
000016F4                           838  *   PUTCHAR sends a character to the console device
000016F4                           839  *   The name of the output device is in CN_OVEC.
000016F4                           840   
000016F4  2F08                     841  PUTCHAR MOVE.L  A0,-(A7)        Save working register
000016F6  206E 0116                842          MOVE.L  CN_OVEC(A6),A0  A0 points to name of console output
000016FA  6108                     843          BSR.S   IO_OPEN         Open console (Get address of DCB)
000016FC  6100 FF2C                844          BSR     IO_REQ          Perform output with DCB pointed at by A0
00001700  205F                     845          MOVE.L  (A7)+,A0        Restore working register
00001702  4E75                     846          RTS
00001704                           847   *=============================================================================
00001704                           848  *   Open - opens a DCB for input or output. IO_OPEN converts the
00001704                           849  *   name pointed at by A0 into the address of the DCB pointed at
00001704                           850  *   by A0. Bit 3 of D7 is set to zero if DCB not found
00001704                           851   
00001704  48E7 F870                852  IO_OPEN MOVEM.L A1-A3/D0-D4,-(A7)   Save working registers
00001708  43EE 0194                853          LEA.L   FIRST(A6),A1            A1 points to first DCB in chain in RAM
0000170C  45D1                     854  OPEN1   LEA.L   (A1),A2                 A2 = temp copy of pointer to DCB
0000170E  47D0                     855          LEA.L   (A0),A3                 A3 = temp copy of pointer to DCB name
00001710  303C 0007                856          MOVE.W  #7,D0               Up to 8 chars of DCB name to match
00001714  181A                     857  OPEN2   MOVE.B  (A2)+,D4                Compare DCB name with string
00001716  B81B                     858          CMP.B   (A3)+,D4
00001718  6608                     859          BNE.S   OPEN3                   If no match try next DCB
0000171A  51C8 FFF8                860          DBRA    D0,OPEN2                Else repeat until all chars matched
0000171E  41D1                     861          LEA.L   (A1),A0                 Success - move this DCB address to A0
00001720  6016                     862          BRA.S   OPEN4                   and return
00001722  =00001722                863  OPEN3   EQU     *                       Fail - calculate address of next DCB
00001722  3229 0010                864          MOVE.W  16(A1),D1               Get parameter block size of DCB
00001726  43F1 1012                865          LEA.L   18(A1,D1.W),A1          A1 points to pointer to next DCB
0000172A  2251                     866          MOVE.L  (A1),A1                 A1 now points to next DCB
0000172C  B3FC 00000000            867          CMP.L   #0,A1                   Test for end of DCB chain
00001732  66D8                     868          BNE     OPEN1                   If not end of chain then try next DCB
00001734  8E3C 0008                869          OR.B    #8,D7                   Else set error flag and return
00001738  4CDF 0E1F                870  OPEN4   MOVEM.L (A7)+,A1-A3/D0-D4   Restore working registers
0000173C  4E75                     871          RTS
0000173E                           872   *=============================================================================
0000173E                           873  *   This subroutine clears the breakpoint table in ram
0000173E                           874   
0000173E  303C 0007                875  CLR_BPT MOVE.W  #7,D0           Clear the breakpoint table
00001742  41EE 0164                876          LEA.L   BP_TAB(A6),A0   Point to table
00001746  4298                     877  LBPT    CLR.L   (A0)+           Clear an address entry
00001748  4258                     878          CLR.W   (A0)+           Clear the corresponding data
0000174A  51C8 FFFA                879          DBRA    D0,LBPT         Repeat until all 8 cleared
0000174E  4E75                     880          RTS
00001750                           881   *=============================================================================
00001750  =00001750                882  TRAP_0  EQU     *               User links to  MODWARE via TRAP #0
00001750  B23C 0000                883          CMP.B   #0,D1           D1 = 0 = Get character
00001754  6606                     884          BNE.S   FUNC1
00001756  6100 FF54                885          BSR     GETCHAR
0000175A  4E73                     886          RTE
0000175C  B23C 0001                887  FUNC1   CMP.B   #1,D1           D1 = 1 = Print character
00001760  6604                     888          BNE.S   FUNC2
00001762  6190                     889          BSR     PUTCHAR
00001764  4E73                     890          RTE
00001766  B23C 0002                891  FUNC2   CMP.B   #2,D1           D1 = 2 = Newline
0000176A  6606                     892          BNE.S   FUNC3
0000176C  6100 FA24                893          BSR     NEWLINE
00001770  4E73                     894          RTE
00001772  B23C 0003                895  FUNC3   CMP.B   #3,D1           D1 = 3 = Get parameter from buffer
00001776  6606                     896          BNE.S   FUNC4
00001778  6100 FBFC                897          BSR     PARAM
0000177C  4E73                     898          RTE
0000177E  B23C 0004                899  FUNC4   CMP.B   #4,D1           D1 = 4 = Print string pointed at by A4
00001782  6606                     900          BNE.S   FUNC5
00001784  6100 FA1C                901          BSR     PSTRING
00001788  4E73                     902          RTE
0000178A  B23C 0005                903  FUNC5   CMP.B   #5,D1           D1 = 5 = Get a hex character
0000178E  6606                     904          BNE.S   FUNC6
00001790  6100 FBAA                905          BSR     HEX
00001794  4E73                     906          RTE
00001796  B23C 0006                907  FUNC6   CMP.B   #6,D1           D1 = 6 = Get a hex byte
0000179A  6606                     908          BNE.S   FUNC7
0000179C  6100 FBBC                909          BSR     BYTE
000017A0  4E73                     910          RTE
000017A2  B23C 0007                911  FUNC7   CMP.B   #7,D1           D1 = 7 = Get a word
000017A6  6606                     912          BNE.S   FUNC8
000017A8  6100 FBC0                913          BSR     WORD
000017AC  4E73                     914          RTE
000017AE  B23C 0008                915  FUNC8   CMP.B   #8,D1           D1 = 8 = Get a longword
000017B2  6606                     916          BNE.S   FUNC9
000017B4  6100 FBBA                917          BSR     LONGWD
000017B8  4E73                     918          RTE
000017BA  B23C 0009                919  FUNC9   CMP.B   #9,D1           D1 = 9 = Output hex byte
000017BE  6606                     920          BNE.S   FUNC10
000017C0  6100 FC12                921          BSR     OUT2X
000017C4  4E73                     922          RTE
000017C6  B23C 000A                923  FUNC10  CMP.B   #10,D1          D1 = 10 = Output hex word
000017CA  6606                     924          BNE.S   FUNC11
000017CC  6100 FC0E                925          BSR     OUT4X
000017D0  4E73                     926          RTE
000017D2  B23C 000B                927  FUNC11  CMP.B   #11,D1          D1 = 11 = Output hex longword
000017D6  6606                     928          BNE.S   FUNC12
000017D8  6100 FC0A                929          BSR     OUT8X
000017DC  4E73                     930          RTE
000017DE  B23C 000C                931  FUNC12  CMP.B   #12,D1          D1 = 12 = Print a space
000017E2  6606                     932          BNE.S   FUNC13
000017E4  6100 FC6E                933          BSR     PSPACE
000017E8  4E73                     934          RTE
000017EA  B23C 000D                935  FUNC13  CMP.B   #13,D1          D1 = 13 = Get a line of text into
000017EE  6606                     936          BNE.S   FUNC14          the line buffer
000017F0  6100 F9C6                937          BSR     GETLINE
000017F4  4E73                     938          RTE
000017F6  B23C 000E                939  FUNC14  CMP.B   #14,D1          D1 = 14 = Tidy up the line in the
000017FA  6606                     940          BNE.S   FUNC15          line buffer by removing leading
000017FC  6100 FA90                941          BSR     TIDY            leading and multiple embedded spaces
00001800  4E73                     942          RTE
00001802  B23C 000F                943  FUNC15  CMP.B   #15,D1          D1 = 15 = Execute the command in
00001806  6606                     944          BNE.S   FUNC16          the line buffer
00001808  6100 FAC6                945          BSR     EXECUTE
0000180C  4E73                     946          RTE
0000180E  B23C 0010                947  FUNC16  CMP.B   #16,D1          D1 = 16 = Call RESTORE to transfer
00001812  6606                     948          BNE.S   FUNC17          the registers in TSK_T to the 68000
00001814  6100 017C                949          BSR     RESTORE         and therefore execute a program
00001818  4E73                     950          RTE
0000181A  4E73                     951  FUNC17  RTE
0000181C                           952   *=============================================================================
0000181C                           953  *   Display exception frame (D0 - D7, A0 - A6, USP, SSP, SR, PC)
0000181C                           954  *   EX_DIS prints registers saved after a breakpoint or exception
0000181C                           955  *   The registers are saved in TSK_T
0000181C                           956   
0000181C  4BEE 011A                957  EX_DIS  LEA.L   TSK_T(A6),A5    A5 points to display frame
00001820  49FA 057E                958          LEA.L   MES3(PC),A4     Point to heading
00001824  6100 F98C                959          BSR     HEADING         and print it
00001828  3C3C 0007                960          MOVE.W  #7,D6           8 pairs of registers to display
0000182C  4205                     961          CLR.B   D5              D5 is the line counter
0000182E  1005                     962  EX_D1   MOVE.B  D5,D0           Put current register number in D0
00001830  6100 FB88                963          BSR     OUT1X           and print it
00001834  6100 FC1E                964          BSR     PSPACE          and a space
00001838  5205                     965          ADD.B   #1,D5           Update counter for next pair
0000183A  2015                     966          MOVE.L  (A5),D0         Get data register to be displayed
0000183C  6100 FBA6                967          BSR     OUT8X           from the frame and print it
00001840  49FA 057C                968          LEA.L   MES4(PC),A4     Print string of spaces
00001844  6100 F95C                969          BSR.L   PSTRING         between data and address registers
00001848  202D 0020                970          MOVE.L  32(A5),D0       Get address register to be displayed
0000184C  6100 FB96                971          BSR     OUT8X           which is 32 bytes on from data reg
00001850  6100 F940                972          BSR     NEWLINE
00001854  4BED 0004                973          LEA.L   4(A5),A5        Point to next pair (ie Di, Ai)
00001858  51CE FFD4                974          DBRA    D6,EX_D1        Repeat until all displayed
0000185C  4BED 0020                975          LEA.L   32(A5),A5       Adjust pointer by 8 longwords
00001860  6100 F930                976          BSR     NEWLINE         to point to SSP
00001864  49FA 0531                977          LEA.L   MES2A(PC),A4    Point to "SS ="
00001868  6100 F938                978          BSR     PSTRING         Print it
0000186C  201D                     979          MOVE.L  (A5)+,D0        Get SSP from frame
0000186E  6100 FB74                980          BSR     OUT8X           and display it
00001872  6100 F91E                981          BSR     NEWLINE
00001876  49FA 050D                982          LEA.L   MES1(PC),A4     Point to 'SR ='
0000187A  6100 F926                983          BSR     PSTRING         Print it
0000187E  301D                     984          MOVE.W  (A5)+,D0        Get status register
00001880  6100 FB5A                985          BSR     OUT4X           Display status
00001884  6100 F90C                986          BSR     NEWLINE
00001888  49FA 0504                987          LEA.L   MES2(PC),A4     Point to 'PC ='
0000188C  6100 F914                988          BSR     PSTRING         Print it
00001890  201D                     989          MOVE.L  (A5)+,D0        Get PC
00001892  6100 FB50                990          BSR     OUT8X           Display PC
00001896  6000 F8FA                991          BRA     NEWLINE         Newline and return
0000189A                           992   *=============================================================================
0000189A                           993  *   Exception handling routines
0000189A                           994   
0000189A  =0000189A                995  IL_ER   EQU     *               Illegal instruction exception
0000189A  2F0C                     996          MOVE.L  A4,-(A7)        Save A4
0000189C  49FA 0547                997          LEA.L   MES10(PC),A4    Point to heading
000018A0  6100 F910                998          BSR     HEADING         Print it
000018A4  285F                     999          MOVE.L  (A7)+,A4        Restore A4
000018A6  4EB9 00001940           1000          JSR     GROUP2          Save registers in display frame
000018AC  6100 FF6E               1001          BSR     EX_DIS          Display registers saved in frame
000018B0  4E73                    1002          RTE
000018B2                          1003          *BRA    _main           Return to monitor
000018B2                          1004  *
000018B2  =000018B2               1005  BUS_ER  EQU     *               Bus error (group 1) exception
000018B2  2F0C                    1006          MOVE.L  A4,-(A7)        Save A4
000018B4  49FA 050F               1007          LEA.L   MES8(PC),A4     Point to heading
000018B8  6100 F8F8               1008          BSR     HEADING         Print it
000018BC  285F                    1009          MOVE.L  (A7)+,A4        Restore A4
000018BE  6100 FF5C               1010          BSR     EX_DIS          Display registers saved in frame
000018C2  6000 0382               1011          BRA     _main           Return to monitor
000018C6                          1012  *
000018C6  =000018C6               1013  ADD_ER  EQU     *               Address error (group 1) exception
000018C6  2F0C                    1014          MOVE.L  A4,-(A7)        Save A4
000018C8  49FA 0509               1015          LEA.L   MES9(PC),A4     Point to heading
000018CC  6100 F8E4               1016          BSR     HEADING         Print it
000018D0  285F                    1017          MOVE.L  (A7)+,A4        Restore A4
000018D2  6100 FF48               1018          BSR     EX_DIS        Display registers saved in frame
000018D6                          1019          
000018D6  6000 036E               1020          BRA     _main           Return to monitor
000018DA                          1021  *
000018DA  =000018DA               1022  PRI_ER  EQU     *               Privilege violation error
000018DA  2F0C                    1023          MOVE.L  A4,-(A7)        Save A4
000018DC  49FA 0610               1024          LEA.L   ERMES8(PC),A4   Point to heading
000018E0  6100 F8D0               1025          BSR     HEADING         Print it
000018E4  285F                    1026          MOVE.L  (A7)+,A4        Restore A4
000018E6  6100 FF34               1027          BSR     EX_DIS          Display registers saved in frame
000018EA                          1028          
000018EA  6000 035A               1029          BRA     _main           Return to monitor
000018EE                          1030  *
000018EE  =000018EE               1031  BRKPT   EQU     *                       Deal with breakpoint
000018EE  48E7 FFFE               1032          MOVEM.L D0-D7/A0-A6,-(A7)   Save all registers
000018F2  6100 0180               1033          BSR     BR_CLR                  Clear breakpoints in code
000018F6  4CDF 7FFF               1034          MOVEM.L (A7)+,D0-D7/A0-A6   Restore registers
000018FA  6144                    1035          BSR.S   GROUP2                  Treat as group 2 exception
000018FC  49FA 04FD               1036          LEA.L   MES11(PC),A4            Point to heading
00001900  6100 F8B0               1037          BSR     HEADING                 Print it
00001904  6100 FF16               1038          BSR     EX_DIS                  Display saved registers
00001908                          1039         
00001908  6000 033C               1040          BRA     _main                   Return to monitor
0000190C                          1041   *=============================================================================
0000190C                          1042  *   GROUP1 is called by address and bus error exceptions
0000190C                          1043  *   These are "turned into group 2" exceptions (eg TRAP)
0000190C                          1044  *   by modifying the stack frame saved by a group 1 exception
0000190C                          1045   
0000190C  48E7 8080               1046  GROUP1  MOVEM.L D0/A0,-(A7)             Save working registers
00001910  206F 0012               1047          MOVE.L  18(A7),A0           Get PC from group 1 stack frame
00001914  302F 000E               1048          MOVE.W  14(A7),D0               Get instruction from stack frame
00001918  B060                    1049          CMP.W   -(A0),D0                Now backtrack to find the "correct PC"
0000191A  670E                    1050          BEQ.S   GROUP1A                 by matching the op-code on the stack
0000191C  B060                    1051          CMP.W   -(A0),D0                with the code in the region of the
0000191E  670A                    1052          BEQ.S   GROUP1A                 PC on the stack
00001920  B060                    1053          CMP.W   -(A0),D0
00001922  6706                    1054          BEQ.S   GROUP1A
00001924  B060                    1055          CMP.W   -(A0),D0
00001926  6702                    1056          BEQ.S   GROUP1A
00001928  5588                    1057          SUBQ.L  #2,A0
0000192A  2F48 0012               1058  GROUP1A MOVE.L  A0,18(A7)               Restore modified PC to stack frame
0000192E  4CDF 0101               1059          MOVEM.L (A7)+,D0/A0         Restore working registers
00001932  4FEF 0008               1060          LEA.L   8(A7),A7                Adjust stack pointer to group 1 type
00001936  6108                    1061          BSR.S   GROUP2                  Now treat as group 1 exception
00001938  6100 FEE2               1062          BSR     EX_DIS                  Display contents of exception frame
0000193C  6000 0308               1063          BRA     _main                   Exit to monitor - no RTE from group 2
00001940                          1064  *
00001940  =00001940               1065  GROUP2  EQU     *                       Deal with group 2 exceptions
00001940  48E7 FFFF               1066          MOVEM.L A0-A7/D0-D7,-(A7)   Save all registers on the stack
00001944  303C 000E               1067          MOVE.W  #14,D0                  Transfer D0 - D7, A0 - A6 from
00001948  41EE 011A               1068          LEA.L   TSK_T(A6),A0            the stack to the display frame
0000194C  20DF                    1069  GROUP2A MOVE.L  (A7)+,(A0)+             Move a register from stack to frame
0000194E  51C8 FFFC               1070          DBRA    D0,GROUP2A              and repeat until D0-D7/A0-A6 moved
00001952  4E6A                    1071          MOVE.L  USP,A2                  Get the user stack pointer and put it
00001954  20CA                    1072          MOVE.L  A2,(A0)+                in the A7 position in the frame
00001956  201F                    1073          MOVE.L  (A7)+,D0                Now transfer the SSP to the frame,
00001958  0480 0000000A           1074          SUB.L   #10,D0                  remembering to account for the
0000195E  20C0                    1075          MOVE.L  D0,(A0)+                data pushed on the stack to this point
00001960  225F                    1076          MOVE.L  (A7)+,A1                Copy TOS (return address) to A1
00001962  30DF                    1077          MOVE.W  (A7)+,(A0)+             Move SR to display frame
00001964  201F                    1078          MOVE.L  (A7)+,D0                Get PC in D0
00001966  5580                    1079          SUBQ.L  #2,D0                   Move back to current instruction
00001968  20C0                    1080          MOVE.L  D0,(A0)+                Put adjusted PC in display frame
0000196A  4ED1                    1081          JMP     (A1)                    Return from subroutine
0000196C                          1082   *=============================================================================
0000196C                          1083  *   GO executes a program either from a supplied address or
0000196C                          1084  *   by using the data in the display frame
0000196C                          1085  _GO
0000196C  6100 FA08               1086  GO      BSR     PARAM                   Get entry address (if any)
00001970  4A07                    1087          TST.B   D7                      Test for error in input
00001972  6708                    1088          BEQ.S   GO1                     If D7 zero then OK
00001974  49FA 04EB               1089          LEA.L   ERMES1(PC),A4           Else point to error message,
00001978  6000 F828               1090          BRA     PSTRING                 print it and return
0000197C  4A80                    1091  GO1     TST.L   D0                      If no address entered then get
0000197E  670A                    1092          BEQ.S   GO2                     address from display frame
00001980  2D40 0160               1093          MOVE.L  D0,TSK_T+70(A6)         Else save address in display frame
00001984  3D7C 0700 015E          1094          MOVE.W  #$0700,TSK_T+68(A6) Store dummy status in frame
0000198A  6006                    1095  GO2     BRA.S   RESTORE                 Restore volatile environment and go
0000198C                          1096  *
0000198C  6100 007A               1097  GB      BSR     BR_SET                  Same as go but presets breakpoints
00001990  60DA                    1098          BRA.S   GO                      Execute program
00001992                          1099   *=============================================================================
00001992                          1100  *   RESTORE moves the volatile environment from the display
00001992                          1101  *   frame and transfers it to the 68000's registers. This
00001992                          1102  *   re-runs a program suspended after an exception
00001992                          1103   
00001992  47EE 011A               1104  RESTORE LEA.L   TSK_T(A6),A3    A3 points to display frame
00001996  47EB 004A               1105          LEA.L   74(A3),A3       A3 now points to end of frame + 4
0000199A  4FEF 0004               1106          LEA.L   4(A7),A7        Remove return address from stack
0000199E  303C 0024               1107          MOVE.W  #36,D0          Counter for 37 words to be moved
000019A2  3F23                    1108  REST1   MOVE.W  -(A3),-(A7)     Move word from display frame to stack
000019A4  51C8 FFFC               1109          DBRA    D0,REST1        Repeat until entire frame moved
000019A8  4CDF 00FF               1110          MOVEM.L (A7)+,D0-D7     Restore old data registers from stack
000019AC  4CDF 7F00               1111          MOVEM.L (A7)+,A0-A6     Restore old address registers
000019B0  4FEF 0008               1112          LEA.L   8(A7),A7        Except SSP/USP - so adjust stack
000019B4  4E73                    1113          RTE                     Return from exception to run program
000019B6                          1114  *
000019B6  =000019B6               1115  TRACE   EQU     *               TRACE exception (rudimentary version)
000019B6  287A 0451               1116          MOVE.L  MES12(PC),A4    Point to heading
000019BA  6100 F7F6               1117          BSR     HEADING         Print it
000019BE  6100 FF4C               1118          BSR     GROUP1          Save volatile environment
000019C2  6100 FE58               1119          BSR     EX_DIS          Display it
000019C6  6000 027E               1120          BRA     _main           Return to monitor
000019CA                          1121   *=============================================================================
000019CA                          1122  *   Breakpoint routines: BR_GET gets the address of a breakpoint and
000019CA                          1123  *   puts it in the breakpoint table. It does not plant it in the code.
000019CA                          1124  *   BR_SET plants all breakpoints in the code. NOBR removes one or all
000019CA                          1125  *   breakpoints from the table. KILL removes breakpoints from the code.
000019CA                          1126   
000019CA  6100 F9AA               1127  BR_GET  BSR     PARAM           Get breakpoint address in table
000019CE  4A07                    1128          TST.B   D7              Test for input error
000019D0  6708                    1129          BEQ.S   BR_GET1         If no error then continue
000019D2  49FA 048D               1130          LEA.L   ERMES1(PC),A4   Else display error
000019D6  6000 F7CA               1131          BRA     PSTRING         and return
000019DA  47EE 0164               1132  BR_GET1 LEA.L   BP_TAB(A6),A3   A6 points to breakpoint table
000019DE  2A40                    1133          MOVE.L  D0,A5           Save new BP address in A5
000019E0  2C00                    1134          MOVE.L  D0,D6           and in D6 because D0 gets corrupted
000019E2  3A3C 0007               1135          MOVE.W  #7,D5           Eight entries to test
000019E6  201B                    1136  BR_GET2 MOVE.L  (A3)+,D0        Read entry from breakpoint table
000019E8  660C                    1137          BNE.S   BR_GET3         If not zero display existing BP
000019EA  4A86                    1138          TST.L   D6              Only store a non-zero breakpoint
000019EC  6710                    1139          BEQ.S   BR_GET4
000019EE  274D FFFC               1140          MOVE.L  A5,-4(A3)       Store new breakpoint in table
000019F2  3695                    1141          MOVE.W  (A5),(A3)       Save code at BP address in table
000019F4  4286                    1142          CLR.L   D6              Clear D6 to avoid repetition
000019F6  6100 F9EC               1143  BR_GET3 BSR     OUT8X           Display this breakpoint
000019FA  6100 F796               1144          BSR     NEWLINE
000019FE  47EB 0002               1145  BR_GET4 LEA.L   2(A3),A3        Step past stored op-code
00001A02  51CD FFE2               1146          DBRA    D5,BR_GET2      Repeat until all entries tested
00001A06  4E75                    1147          RTS                     Return
00001A08                          1148  *
00001A08  =00001A08               1149  BR_SET  EQU     *               Plant any breakpoints in user code
00001A08  41EE 0164               1150          LEA.L   BP_TAB(A6),A0   A0 points to BP table
00001A0C  45EE 0160               1151          LEA.L   TSK_T+70(A6),A2 A2 points to PC in display frame
00001A10  2452                    1152          MOVE.L  (A2),A2         Now A2 contains value of PC
00001A12  303C 0007               1153          MOVE.W  #7,D0           Up to eight entries to plant
00001A16  2218                    1154  BR_SET1 MOVE.L  (A0)+,D1        Read breakpoint address from table
00001A18  670A                    1155          BEQ.S   BR_SET2         If zero then skip planting
00001A1A  B28A                    1156          CMP.L   A2,D1           Don't want to plant BP at current PC
00001A1C  6706                    1157          BEQ.S   BR_SET2         location, so skip planting if same
00001A1E  2241                    1158          MOVE.L  D1,A1           Transfer BP address to address reg
00001A20  32BC 4E4E               1159          MOVE.W  #TRAP_14,(A1)   Plant op-code for TRAP #14 in code
00001A24  41E8 0002               1160  BR_SET2 LEA.L   2(A0),A0        Skip past op-code field in table
00001A28  51C8 FFEC               1161          DBRA    D0,BR_SET1      Repeat until all entries tested
00001A2C  4E75                    1162          RTS
00001A2E                          1163  *
00001A2E  =00001A2E               1164  NOBR    EQU     *               Clear one or all breakpoints
00001A2E  6100 F946               1165          BSR     PARAM           Get BP address (if any)
00001A32  4A07                    1166          TST.B   D7              Test for input error
00001A34  6708                    1167          BEQ.S   NOBR1           If no error then skip abort
00001A36  49FA 0429               1168          LEA.L   ERMES1(PC),A4   Point to error message
00001A3A  6000 F766               1169          BRA     PSTRING         Display it and return
00001A3E  4A80                    1170  NOBR1   TST.L   D0              Test for null address (clear all)
00001A40  6720                    1171          BEQ.S   NOBR4           If no address then clear all entries
00001A42  2240                    1172          MOVE.L  D0,A1           Else just clear breakpoint in A1
00001A44  41EE 0164               1173          LEA.L   BP_TAB(A6),A0   A0 points to BP table
00001A48  303C 0007               1174          MOVE.W  #7,D0           Up to eight entries to test
00001A4C  2218                    1175  NOBR2   MOVE.L  (A0)+,D1        Get entry and
00001A4E  41E8 0002               1176          LEA.L   2(A0),A0        skip past op-code field
00001A52  B289                    1177          CMP.L   A1,D1           Is this the one?
00001A54  6706                    1178          BEQ.S   NOBR3          If so go and clear entry
00001A56  51C8 FFF4               1179          DBRA    D0,NOBR2        Repeat until all tested
00001A5A  4E75                    1180          RTS
00001A5C  42A8 FFFA               1181  NOBR3   CLR.L   -6(A0)          Clear address in BP table
00001A60  4E75                    1182          RTS
00001A62  41EE 0164               1183  NOBR4   LEA.L   BP_TAB(A6),A0   Clear all 8 entries in BP table
00001A66  303C 0007               1184          MOVE.W  #7,D0           Eight entries to clear
00001A6A  4298                    1185  NOBR5   CLR.L   (A0)+           Clear breakpoint address
00001A6C  4258                    1186          CLR.W   (A0)+           Clear op-code field
00001A6E  51C8 FFFA               1187          DBRA    D0,NOBR5        Repeat until all done
00001A72  4E75                    1188          RTS
00001A74                          1189  *
00001A74  =00001A74               1190  BR_CLR  EQU     *               Remove breakpoints from code
00001A74  41EE 0164               1191          LEA.L   BP_TAB(A6),A0   A0 points to breakpoint table
00001A78  303C 0007               1192          MOVE.W  #7,D0           Up to eight entries to clear
00001A7C  2218                    1193  BR_CLR1 MOVE.L  (A0)+,D1        Get address of BP in D1
00001A7E  2241                    1194          MOVE.L  D1,A1           and put copy in A1
00001A80  4A81                    1195          TST.L   D1              Test this breakpoint
00001A82  6702                    1196          BEQ.S   BR_CLR2         If zero then skip BP clearing
00001A84  3290                    1197          MOVE.W  (A0),(A1)       Else restore op-code
00001A86  41E8 0002               1198  BR_CLR2 LEA.L   2(A0),A0        Skip past op-code field
00001A8A  51C8 FFF0               1199          DBRA    D0,BR_CLR1      Repeat until all tested
00001A8E  4E75                    1200          RTS
00001A90                          1201   *=============================================================================
00001A90                          1202  *   REG_MOD modifies a register in the display frame. The command
00001A90                          1203  *   format is REG <reg> <value>. E.g. REG D3 1200
00001A90                          1204   
00001A90  4281                    1205  REG_MOD CLR.L   D1              D1 to hold name of register
00001A92  41EE 0102               1206          LEA.L   BUFFPT(A6),A0   A0 contains address of buffer pointer
00001A96  2050                    1207          MOVE.L  (A0),A0         A0 now points to next char in buffer
00001A98  1218                    1208          MOVE.B  (A0)+,D1        Put first char of name in D1
00001A9A  E159                    1209          ROL.W   #8,D1            Move char one place left
00001A9C  1218                    1210          MOVE.B  (A0)+,D1        Get second char in D1
00001A9E  41E8 0001               1211          LEA.L   1(A0),A0        Move pointer past space in buffer
00001AA2  2D48 0102               1212          MOVE.L  A0,BUFFPT(A6)   Update buffer pointer
00001AA6  4282                    1213          CLR.L   D2              D2 is the character pair counter
00001AA8  41FA 038E               1214          LEA.L   REGNAME(PC),A0  A0 points to string of character pairs
00001AAC  43D0                    1215          LEA.L   (A0),A1         A1 also points to string
00001AAE  B258                    1216  REG_MD1 CMP.W   (A0)+,D1        Compare a char pair with input
00001AB0  6712                    1217          BEQ.S   REG_MD2         If match then exit loop
00001AB2  5282                    1218          ADD.L   #1,D2           Else increment match counter
00001AB4  B4BC 00000013           1219          CMP.L   #19,D2          Test for end of loop
00001ABA  66F2                    1220          BNE     REG_MD1         Continue until all pairs matched
00001ABC  49FA 03A3               1221          LEA.L   ERMES1(PC),A4   If here then error
00001AC0  6000 F6E0               1222          BRA     PSTRING         Display error and return
00001AC4  43EE 011A               1223  REG_MD2 LEA.L   TSK_T(A6),A1    A1 points to display frame
00001AC8  E582                    1224          ASL.L   #2,D2           Multiply offset by 4 (4 bytes/entry)
00001ACA  B4BC 00000048           1225          CMP.L   #72,D2          Test for address of PC
00001AD0  6602                    1226          BNE.S   REG_MD3         If not PC then all is OK
00001AD2  5582                    1227          SUB.L   #2,D2           else dec PC pointer as Sr is a word
00001AD4  45F1 2000               1228  REG_MD3 LEA.L   (A1,D2),A2      Calculate address of entry in disptable
00001AD8  2012                    1229          MOVE.L  (A2),D0         Get old contents
00001ADA  6100 F908               1230          BSR     OUT8X           Display them
00001ADE  6100 F6B2               1231           BSR     NEWLINE
00001AE2  6100 F892               1232          BSR     PARAM           Get new data
00001AE6  4A07                    1233          TST.B   D7              Test for input error
00001AE8  6708                    1234          BEQ.S   REG_MD4         If no error then go and store data
00001AEA  49FA 0375               1235          LEA.L   ERMES1(PC),A4   Else point to error message
00001AEE  6000 F6B2               1236          BRA     PSTRING         print it and return
00001AF2  B4BC 00000044           1237  REG_MD4 CMP.L   #68,D2          If this address is the SR then
00001AF8  6704                    1238          BEQ.S   REG_MD5         we have only a word to store
00001AFA  2480                    1239          MOVE.L  D0,(A2)         Else store new data in display frame
00001AFC  4E75                    1240          RTS
00001AFE  3480                    1241  REG_MD5 MOVE.W  D0,(A2)         Store SR (one word)
00001B00  4E75                    1242          RTS
00001B02                          1243   *=============================================================================
00001B02  =00001B02               1244  X_UN    EQU     *               Uninitialized exception vector routine
00001B02  49FA 03C3               1245          LEA.L   ERMES6(PC),A4   Point to error message
00001B06  6100 F69A               1246          BSR     PSTRING         Display it
00001B0A  6100 FD10               1247          BSR     EX_DIS          Display registers
00001B0E  6000 0136               1248           BRA     _main          Abort
00001B12                          1249   *=============================================================================
00001B12                          1250  *   LOGON subroutine is called upon RESET
00001B12                          1251  *   If successful, returns with no effect
00001B12                          1252  *   Upon failure, RESETs
00001B12                          1253  _LOGON
00001B12  =00001B12               1254  LOGON   EQU     *
00001B12  48E7 E018               1255          MOVEM.L D0-D2/A3-A4,-(A7)   Save registers to stack
00001B16  4285                    1256          CLR.L   D5              Clear attempt count
00001B18  7000                    1257          MOVE.L  #0, D0
00001B1A  4282                    1258  LOG1    CLR.L   D2              Clear user match
00001B1C  4287                    1259          CLR.L   D7              Clear error flag
00001B1E  B03C 0003               1260          CMP.b   #3,D0           if too many attempts
00001B22  6700 004A               1261          BEQ     LOGF                    goto failure
00001B26  6100 F66A               1262          BSR     NEWLINE
00001B2A  49FA 06A2               1263          LEA.L   LOGM(PC),A4
00001B2E  6100 F672               1264          BSR     PSTRING
00001B32  6100 F684               1265          BSR     GETLINE
00001B36  6100 F756               1266          BSR     TIDY
00001B3A  47FA 069F               1267          LEA.L   USERNA(PC),A3   Load username into A3
00001B3E  6100 003E               1268          BSR     LSCH            Sets D1 if we have match
00001B42  2401                    1269          MOVE.L  D1,D2           Save user match in D2
00001B44  4287                    1270          CLR.L   D7              Clear error flag
00001B46  6100 F64A               1271          BSR     NEWLINE
00001B4A                          1272  *       MOVE.L  #1,STAR(A6)     Set STAR ECHO
00001B4A  49FA 0698               1273          LEA.L   PASSM(PC),A4
00001B4E  6100 F652               1274          BSR     PSTRING
00001B52  6100 F69A               1275          BSR     GETPASS
00001B56                          1276  *       CLR.L   STAR(A6)        Clear STAR ECHO
00001B56  47FA 0697               1277          LEA.L   PASS(PC),A3     Load password into A3
00001B5A  6100 0022               1278          BSR     LSCH            Sets D1 if we have a match
00001B5E  D282                    1279          ADD.L   D2,D1           Add two match flags together
00001B60  B2BC 00000002           1280          CMP.L   #2,D1           If both are set
00001B66  6700 0010               1281          BEQ     LOGS            Success
00001B6A  5200                    1282          ADD.b   #1,D0           Else increment attempt count
00001B6C  60AC                    1283          BRA     LOG1            And loop
00001B6E  49FA 0686               1284  LOGF    LEA.L   LOGINERROR(PC),A4
00001B72  6100 F62E               1285          BSR     PSTRING
00001B76  609A                    1286          BRA     LOGON                           
00001B78  4CDF 1807               1287  LOGS    MOVEM.L (A7)+,D0-D2/A3-A4   Restore registers from stack
00001B7C  4E75                    1288          RTS                     Return on success
00001B7E                          1289   
00001B7E                          1290   *============================================================================
00001B7E                          1291  *   LOGON helper subroutine
00001B7E                          1292  *   INPUT:  A3 = start address of string to compare against
00001B7E                          1293  *   OUTPUT: D1 = 1 if strings match, 0 otherwise
00001B7E                          1294  _LSCH
00001B7E  48E7 8008               1295  LSCH    MOVEM.L D0/A4,-(A7)     Save registers to stack
00001B82  49EE 00C1               1296          LEA.L   LNBUFF(A6),A4   Load line buffer into A4
00001B86  4281                    1297          CLR.L   D1              Preemptively clear user match
00001B88  101B                    1298  LSCH0   MOVE.B  (A3)+,D0        Get character of username
00001B8A  4A40                    1299          TST     D0              Test for null
00001B8C  6700 000A               1300          BEQ     LSCHS           Success on NULL
00001B90  B01C                    1301          CMP.B   (A4)+,D0        Compare with input char
00001B92  6600 0006               1302          BNE     LSCHF           Fail on mismatch
00001B96  60F0                    1303          BRA     LSCH0           Loop
00001B98  7201                    1304  LSCHS   MOVE.L  #1,D1           Set user match
00001B9A  4CDF 1001               1305  LSCHF   MOVEM.L (A7)+,D0/A4     Restore registers from stack
00001B9E  4E75                    1306          RTS
00001BA0                          1307   *=============================================================================
00001BA0                          1308  *   HELP prints a description of each command in COMTAB
00001BA0                          1309  _HELP
00001BA0  =00001BA0               1310  HELP    EQU     *
00001BA0  6100 F5F0               1311          BSR     NEWLINE
00001BA4  49FA 035E               1312          LEA.L   HEJU(PC),A4
00001BA8  6100 F5F8               1313          BSR     PSTRING
00001BAC  6100 F5E4               1314          BSR     NEWLINE
00001BB0  49FA 038B               1315          LEA.L   HEME(PC),A4
00001BB4  6100 F5EC               1316          BSR     PSTRING
00001BB8  6100 F5D8               1317          BSR     NEWLINE
00001BBC  49FA 03B2               1318          LEA.L   HELO(PC),A4
00001BC0  6100 F5E0               1319          BSR     PSTRING
00001BC4  6100 F5CC               1320          BSR     NEWLINE
00001BC8  49FA 03D9               1321          LEA.L   HEDU(PC),A4
00001BCC  6100 F5D4               1322          BSR     PSTRING
00001BD0  6100 F5C0               1323          BSR     NEWLINE
00001BD4  49FA 040E               1324          LEA.L   HENO(PC),A4
00001BD8  6100 F5C8               1325          BSR     PSTRING
00001BDC  6100 F5B4               1326          BSR     NEWLINE
00001BE0  49FA 0444               1327          LEA.L   HEDI(PC),A4
00001BE4  6100 F5BC               1328          BSR     PSTRING
00001BE8  6100 F5A8               1329          BSR     NEWLINE
00001BEC  49FA 0477               1330          LEA.L   HEGO(PC),A4
00001BF0  6100 F5B0               1331          BSR     PSTRING
00001BF4  6100 F59C               1332          BSR     NEWLINE
00001BF8  49FA 04A1               1333          LEA.L   HEBR(PC),A4
00001BFC  6100 F5A4               1334          BSR     PSTRING
00001C00  6100 F590               1335          BSR     NEWLINE
00001C04  49FA 04D5               1336          LEA.L   HEPL(PC),A4
00001C08  6100 F598               1337          BSR     PSTRING
00001C0C  6100 F584               1338          BSR     NEWLINE
00001C10  49FA 04F2               1339          LEA.L   HEKI(PC),A4
00001C14  6100 F58C               1340          BSR     PSTRING
00001C18  6100 F578               1341          BSR     NEWLINE
00001C1C  49FA 0510               1342          LEA.L   HEGB(PC),A4
00001C20  6100 F580               1343          BSR     PSTRING
00001C24  6100 F56C               1344          BSR     NEWLINE
00001C28  49FA 0537               1345          LEA.L   HERE(PC),A4
00001C2C  6100 F574               1346          BSR     PSTRING
00001C30  6000 0014               1347          BRA     _main
00001C34                          1348         
00001C34                          1349  *===========================================================================
00001C34                          1350  *       MAIN FUNCTION
00001C34                          1351   
00001C34                          1352  _mainstart:
00001C34                          1353  ; //test();
00001C34                          1354  ; LOGON();
00001C34  4EB8 1B12               1355         jsr      _LOGON
00001C38                          1356  ; //logon();
00001C38                          1357  ; banner();
00001C38  4EB9 00001C58           1358         jsr      _banner
00001C3E                          1359  ; command();
00001C3E  4EB9 00001C46           1360         jsr      _command
00001C44  4E75                    1361         rts
00001C46                          1362  ; }
00001C46                          1363  ; void command(){
00001C46                          1364  _main
00001C46                          1365  _command:
00001C46                          1366  ; while(1){
00001C46                          1367  command_1:
00001C46                          1368  ; GETLINE();
00001C46  4EB8 1192               1369         jsr      _NEWLINE
00001C4A  4EB8 11B8               1370         jsr      _GETLINE
00001C4E                          1371  ; TIDY();
00001C4E  4EB8 128E               1372         jsr      _TIDY
00001C52                          1373  ; EXECUTE();
00001C52  4EB8 12D0               1374         jsr      _EXECUTE
00001C56                          1375             ;jsr          _NEWLINE
00001C56  60EE                    1376         bra      command_1
00001C58                          1377  ; }
00001C58                          1378  ; }
00001C58                          1379  ; /*void logon(){
00001C58                          1380  ; /*char* userName = "STUDENT";
00001C58                          1381  ; char* pass = "CECS525";
00001C58                          1382  ; sendmsg(&USERMSG);            //get user name
00001C58                          1383  ; while(buffer != 13){
00001C58                          1384  ; *buffer = getchar();
00001C58                          1385  ; sendchar(*buffer);
00001C58                          1386  ; buffer = buffer + 1;
00001C58                          1387  ; }
00001C58                          1388  ; //check user name
00001C58                          1389  ; while(*buffer != 0){
00001C58                          1390  ; if(*buffer != *userName){
00001C58                          1391  ; break;
00001C58                          1392  ; }
00001C58                          1393  ; else{
00001C58                          1394  ; buffer = buffer + 1;
00001C58                          1395  ; userName = userName + 1;
00001C58                          1396  ; }
00001C58                          1397  ; }
00001C58                          1398  ; }
00001C58                          1399  ; void debug(){
00001C58                          1400  ; _A4 = DEBUG;
00001C58                          1401  ; PSTRING();
00001C58                          1402  ; NEWLINE();
00001C58                          1403  ; sendchar('*');
00001C58                          1404  ; GETLINE();
00001C58                          1405  ; _A4 = _A0;
00001C58                          1406  ; PSTRING();
00001C58                          1407  ; NEWLINE();
00001C58                          1408  ; _A4 = _A1;
00001C58                          1409  ; PSTRING();
00001C58                          1410  ; NEWLINE();
00001C58                          1411  ; _A4 = DEBUGEND;
00001C58                          1412  ; PSTRING();
00001C58                          1413  ; NEWLINE();
00001C58                          1414  ; }*/
00001C58                          1415  ; void banner(){
00001C58                          1416  _banner:
00001C58  48E7 0030               1417         movem.l   A2/A3,-(A7)
00001C5C  45F9 00001192           1418         lea      _NEWLINE.L,A2
00001C62  47F9 000011A2           1419         lea      _PSTRING.L,A3
00001C68                          1420  ; _A4 = BANNER;
00001C68  41F9 0000221E           1421         lea      tinywa1_1.L,A0
00001C6E  2848                    1422         move.l   A0,A4
00001C70                          1423  ; PSTRING();
00001C70  4E93                    1424         jsr      (A3)
00001C72                          1425  ; NEWLINE();
00001C72  4E92                    1426         jsr      (A2)
00001C74                          1427  ; _A4 = MODIFY;
00001C74  41F9 00002237           1428         lea      tinywa1_2.L,A0
00001C7A  2848                    1429         move.l   A0,A4
00001C7C                          1430  ; PSTRING();
00001C7C  4E93                    1431         jsr      (A3)
00001C7E                          1432  ; NEWLINE();
00001C7E  4E92                    1433         jsr      (A2)
00001C80                          1434  ; _A4 = MODIFY2;
00001C80  41F9 00002264           1435         lea      tinywa1_3.L,A0
00001C86  2848                    1436         move.l   A0,A4
00001C88                          1437  ; PSTRING();
00001C88  4E93                    1438         jsr      (A3)
00001C8A                          1439  ; NEWLINE();
00001C8A  4E92                    1440         jsr      (A2)
00001C8C                          1441  ; _A4 = WHY;
00001C8C  41F9 0000227C           1442         lea      tinywa1_4.L,A0
00001C92  2848                    1443         move.l   A0,A4
00001C94                          1444  ; PSTRING();
00001C94  4E93                    1445         jsr      (A3)
00001C96                          1446  ; NEWLINE();
00001C96  4E92                    1447         jsr      (A2)
00001C98                          1448  ; _A4 = WHERE;
00001C98  41F9 000022B3           1449         lea      tinywa1_5.L,A0
00001C9E  2848                    1450         move.l   A0,A4
00001CA0                          1451  ; PSTRING();
00001CA0  4E93                    1452         jsr      (A3)
00001CA2                          1453  ; NEWLINE();
00001CA2  4E92                    1454         jsr      (A2)
00001CA4                          1455  ; _A4 = ADDRE;
00001CA4  41F9 000022CC           1456         lea      tinywa1_6.L,A0
00001CAA  2848                    1457         move.l   A0,A4
00001CAC                          1458  ; PSTRING();
00001CAC  4E93                    1459         jsr      (A3)
00001CAE                          1460  ; NEWLINE();
00001CAE  4E92                    1461         jsr      (A2)
00001CB0  4CDF 0C00               1462         movem.l   (A7)+,A2/A3
00001CB4  4E75                    1463         rts
00001CB6                          1464  ; }
00001CB6                          1465   *=============================================================================
00001CB6                          1466  *   COMTAB  is the built-in command table. All entries are made up of
00001CB6                          1467  *               a string length + number of characters to match + the string
00001CB6                          1468  *           plus the address of the command relative to COMTAB
00001CB6                          1469   
00001CB6= 04 04                   1470  COMTAB  DC.B    4,4             HELP lists commands with discriptions
00001CB8= 48 45 4C 50             1471             DC.B    'HELP'
00001CBC= FFFFFEEA                1472          DC.L    HELP-COMTAB
00001CC0= 04 04                   1473          DC.B    4,4             JUMP <address> causes execution to
00001CC2= 4A 55 4D 50             1474          DC.B    'JUMP'          begin at <address>
00001CC6= FFFFF736                1475          DC.L    JUMP-COMTAB
00001CCA= 08 03                   1476          DC.B    8,3             MEMORY <address> examines contents of
00001CCC= 4D 45 4D 4F 52 59 ...   1477          DC.B    'MEMORY  '      <address> and allows them to be changed
00001CD4= FFFFF74C                1478          DC.L    MEMORY-COMTAB
00001CD8= 04 02                   1479          DC.B    4,2             LOAD <string> loads S1/S2 records
00001CDA= 4C 4F 41 44             1480          DC.B    'LOAD'          from the host. <string> is sent to host
00001CDE= FFFFF7AC                1481          DC.L    LOAD-COMTAB
00001CE2= 04 02                   1482          DC.B    4,2             DUMP <string> sends S1 records to the
00001CE4= 44 55 4D 50             1483          DC.B    'DUMP'          host and is preceeded by <string>.
00001CE8= FFFFF870                1484          DC.L    DUMP-COMTAB
00001CEC= 04 02                   1485          DC.B    4,2             NOBR <address> removes the breakpoint
00001CEE= 4E 4F 42 52             1486          DC.B    'NOBR'          at <address> from the BP table. If
00001CF2= FFFFFD78                1487          DC.L    NOBR-COMTAB     no address is given all BPs are removed.
00001CF6= 04 02                   1488          DC.B    4,2             DISP displays the contents of the
00001CF8= 44 49 53 50             1489          DC.B    'DISP'          pseudo registers in TSK_T.
00001CFC= FFFFFB66                1490          DC.L    EX_DIS-COMTAB
00001D00= 04 02                   1491          DC.B    4,2             GO <address> starts program execution
00001D02= 47 4F 20 20             1492          DC.B    'GO  '          at <address> and loads regs from TSK_T
00001D06= FFFFFCB6                1493          DC.L    GO-COMTAB
00001D0A= 04 02                   1494          DC.B    4,2             BRGT puts a breakpoint in the BP
00001D0C= 42 52 47 54             1495          DC.B    'BRGT'          table - but not in the code
00001D10= FFFFFD14                1496          DC.L    BR_GET-COMTAB
00001D14= 04 02                   1497          DC.B    4,2             PLAN puts the breakpoints in the code
00001D16= 50 4C 41 4E             1498          DC.B    'PLAN'
00001D1A= FFFFFD52                1499          DC.L    BR_SET-COMTAB
00001D1E= 04 04                   1500          DC.B    4,4              KILL removes breakpoints from the code
00001D20= 4B 49 4C 4C             1501          DC.B    'KILL'
00001D24= FFFFFDBE                1502          DC.L    BR_CLR-COMTAB
00001D28= 04 02                   1503          DC.B    4,2             GB <address> sets breakpoints and
00001D2A= 47 42 20 20             1504          DC.B    'GB  '          then calls GO.
00001D2E= FFFFFCD6                1505          DC.L    GB-COMTAB
00001D32= 04 03                   1506          DC.B    4,3             REG <reg> <value> loads <value>
00001D34= 52 45 47 20             1507          DC.B    'REG '          into <reg> in TASK_T. Used to preset
00001D38= FFFFFDDA                1508          DC.L    REG_MOD-COMTAB  registers before a GO or GB
00001D3C= 05 05                   1509          DC.B    5,5             REG <reg> <value> loads <value>
00001D3E= 52 45 53 45 54          1510          DC.B    'RESET'         into <reg> in TASK_T. Used to preset
00001D44= FFFFF34A                1511          DC.L    RESET-COMTAB  registers before a GO or GB
00001D48= 00 00                   1512          DC.B    0,0
00001D4A                          1513   *=============================================================================
00001D4A                          1514  *   This is a list of the information needed to setup the DCBs
00001D4A                          1515   
00001D4A  =00001D4A               1516  DCB_LST EQU     *
00001D4A= 43 4F 4E 5F 49 4E ...   1517  DCB1    DC.B    'CON_IN  '      Device name (8 bytes)
00001D52= 0000163C 00008001       1518          DC.L    CON_IN,ACIA     Address of driver routine, device
00001D5A= 0002                    1519          DC.W    2               Number of words in parameter field
00001D5C= 43 4F 4E 5F 4F 55 ...   1520  DCB2    DC.B    'CON_OUT '
00001D64= 0000166C 00008001       1521          DC.L    CON_OUT,ACIA
00001D6C= 0002                    1522          DC.W    2
00001D6E                          1523   *=============================================================================
00001D6E                          1524  *   DCB structure
00001D6E                          1525  *
00001D6E                          1526  *               -----------------------
00001D6E                          1527  *       0 ->   | DCB  name           |
00001D6E                          1528  *               |---------------------|
00001D6E                          1529  *       8 ->   | Device driver          |
00001D6E                          1530  *               |---------------------|
00001D6E                          1531  *      12 ->   | Device address         |
00001D6E                          1532  *               |---------------------|
00001D6E                          1533  *      16 ->   |Size of param block  |
00001D6E                          1534  *              |---------------------| ---
00001D6E                          1535  *      18 ->   |        Status          |   |
00001D6E                          1536  *               | logical  | physical |   | S
00001D6E                          1537  *               |---------------------|   |
00001D6E                          1538  *               .                       .   .
00001D6E                          1539  *               |---------------------| ---
00001D6E                          1540  *    18+S ->   | Pointer to next DCB |
00001D6E                          1541  *
00001D6E                          1542  *=============================================================================
00001D6E                          1543  *   All strings and other fixed parameters here
00001D6E                          1544   
00001D6E= 0D 0A 54 53 32 4D ...   1545  CRLF    DC.B    CR,LF,'TS2MON >',0
00001D79= 0D 0A 53 31 00 00       1546  HEADER  DC.B    CR,LF,'S','1',0,0
00001D7F= 53 39 20 20 00 00       1547  TAIL    DC.B    'S9  ',0,0
00001D85= 20 53 52 20 20 3D ...   1548  MES1    DC.B    ' SR  =  ',0
00001D8E= 20 50 43 20 20 3D ...   1549  MES2    DC.B    ' PC  =  ',0
00001D97= 20 53 53 20 20 3D ...   1550  MES2A   DC.B    ' SS  =  ',0
00001DA0= 20 20 44 61 74 61 ...   1551  MES3    DC.B    '  Data reg       Address reg',0,0
00001DBE= 20 20 20 20 09 00 00    1552  MES4    DC.B    '       ',0,0
00001DC5= 42 75 73 20 65 72 ...   1553  MES8    DC.B    'Bus error   ',0,0
00001DD3= 41 64 64 72 65 73 ...   1554  MES9    DC.B    'Address error   ',0,0
00001DE5= 49 6C 6C 65 67 61 ...   1555  MES10   DC.B    'Illegal instruction ',0,0
00001DFB= 42 72 65 61 6B 70 ...   1556  MES11   DC.B    'Breakpoint  ',0,0
00001E09= 54 72 61 63 65 20 ...   1557  MES12   DC.B    'Trace   ',0
00001E12= 44 69 76 69 73 69 ...   1558  MES13   DC.B    'Division by Zero',0
00001E23= 50 72 69 76 69 6C ...   1559  MES14   DC.B    'Priviledge Violation',0
00001E38= 44 30 44 31 44 32 ...   1560  REGNAME DC.B    'D0D1D2D3D4D5D6D7'
00001E48= 41 30 41 31 41 32 ...   1561          DC.B    'A0A1A2A3A4A5A6A7'
00001E58= 53 53 53 52             1562          DC.B    'SSSR'
00001E5C= 50 43 20 20 00          1563          DC.B    'PC  ',0
00001E61= 4E 6F 6E 2D 76 61 ...   1564  ERMES1  DC.B    'Non-valid hexadecimal input  ',0
00001E7F= 49 6E 76 61 6C 69 ...   1565  ERMES2  DC.B    'Invalid command  ',0
00001E91= 4C 6F 61 64 69 6E ...   1566  ERMES3  DC.B    'Loading error',0
00001E9F= 54 61 62 6C 65 20 ...   1567  ERMES4  DC.B    'Table full  ',0,0
00001EAD= 42 72 65 61 6B 70 ...   1568  ERMES5  DC.B    'Breakpoint not active   ',0,0
00001EC7= 55 6E 69 6E 69 74 ...   1569  ERMES6  DC.B    'Uninitialized exception ',0,0
00001EE1= 20 52 61 6E 67 65 ...   1570  ERMES7  DC.B    ' Range error',0
00001EEE= 50 72 69 76 69 6C ...   1571  ERMES8  DC.B    'Privilege violation ',0,0
00001F04= 28 4A 55 4D 50 29 ...   1572  HEJU    DC.B    '(JUMP) <address> causes execution to begin at <address>',0,0
00001F3D= 28 4D 45 4D 29 4F ...   1573  HEME    DC.B    '(MEM)ORY <address> examines contents of <address>',0,0
00001F70= 28 4C 4F 29 41 44 ...   1574  HELO    DC.B    '(LO)AD <string> loads S1/S2 records from the host',0,0
00001FA3= 28 44 55 29 4D 50 ...   1575  HEDU    DC.B    '(DU)MP <string> sends S1 records to host preceeded by <string>',0,0,0
00001FE4= 28 4E 4F 29 42 52 ...   1576  HENO    DC.B    '(NO)BR <address> removes the breakpoint at <address> from the BP',0,0
00002026= 28 44 49 29 53 50 ...   1577  HEDI    DC.B    '(DI)SP displays the contents of the pseudo registers in TSK_T',0,0
00002065= 28 47 4F 29 20 3C ...   1578  HEGO    DC.B    '(GO) <address> starts program execution at <address>',0,0
0000209B= 28 42 52 29 47 54 ...   1579  HEBR    DC.B    '(BR)GT puts a breakpoint in the BP table - but not in the code',0,0
000020DB= 28 50 4C 29 41 4E ...   1580  HEPL    DC.B    '(PL)AN puts the breakpoints in the code',0,0
00002104= 28 4B 49 4C 4C 29 ...   1581  HEKI    DC.B    '(KILL) removes breakpoints from the code',0,0
0000212E= 28 47 42 29 20 3C ...   1582  HEGB    DC.B    '(GB) <address> sets breakpoints and then calls GO',0,0
00002161= 28 52 45 47 29 20 ...   1583  HERE    DC.B    '(REG) <reg> <value> view or preloads <value> into <reg>',0,0
0000219A= 46 50 55 20 4D 61 ...   1584  NAN     DC.B    'FPU Math Error: Result is Not a Number or Infinity',0,0
000021CE= 55 53 45 52 20 4E ...   1585  LOGM    DC.B    'USER NAME: ',0,0
000021DB= 50 52 4F 4A 45 43 ...   1586  USERNA  DC.B    'PROJECT2',0
000021E4= 50 41 53 53 57 4F ...   1587  PASSM   DC.B    'PASSWORD: ',0
000021EF= 47 52 4F 55 50 34 00    1588  PASS    DC.B    'GROUP4',0
000021F6= 46 61 69 6C 65 64 ...   1589  LOGINERROR DC.B 'Failed to logon 3 times, going to reset',0
0000221E                          1590   
0000221E                          1591  tinywa1_1:
0000221E= 54 53 42 55 47 20 ...   1592          DC.B    84,83,66,85,71,32,50,32,86,101,114,115,105,111
0000222C= 6E 20 32 33 2E 30 ...   1593          DC.B    110,32,50,51,46,48,55,46,56,54,0
00002237                          1594  tinywa1_2:
00002237= 4D 6F 64 69 66 69 ...   1595         DC.B     77,111,100,105,102,105,101,100,32,98,121,32
00002243= 45 75 67 65 6E 65 ...   1596         DC.B     69,117,103,101,110,101,32,65,46,32,82,111,99
00002250= 6B 65 79 20 4A 72 ...   1597         DC.B     107,101,121,32,74,114,46,32,79,99,116,46,49
0000225D= 38 2E 32 30 30 39 00    1598         DC.B     56,46,50,48,48,57,0
00002264                          1599  tinywa1_3:
00002264= 61 6E 64 20 47 72 ...   1600         DC.B     97,110,100,32,71,114,111,117,112,32,49,32,83
00002271= 65 70 2E 31 38 2E ...   1601         DC.B     101,112,46,49,56,46,50,48,49,55,0
0000227C                          1602  tinywa1_4:
0000227C= 66 6F 72 20 75 73 ...   1603         DC.B     102,111,114,32,117,115,101,32,119,105,116,104
00002288= 20 74 68 65 20 4D ...   1604         DC.B     32,116,104,101,32,77,54,56,48,48,48,32,77,105
00002296= 6E 69 6D 61 6C 20 ...   1605         DC.B     110,105,109,97,108,32,67,111,109,112,117,116
000022A2= 65 72 20 43 6F 6E ...   1606         DC.B     101,114,32,67,111,110,102,105,103,117,114,97
000022AE= 74 69 6F 6E 00          1607         DC.B     116,105,111,110,0
000022B3                          1608  tinywa1_5:
000022B3= 55 6E 69 76 65 72 ...   1609         DC.B     85,110,105,118,101,114,115,105,116,121,32,111
000022BF= 66 20 4C 6F 75 69 ...   1610         DC.B     102,32,76,111,117,105,115,118,105,108,108,101
000022CB= 00                      1611          DC.B    0
000022CC                          1612  tinywa1_6:
000022CC= 43 45 43 53 20 35 ...   1613         DC.B     67,69,67,83,32,53,50,53,44,32,119,119,119,46
000022DA= 63 73 2E 6C 6F 75 ...   1614         DC.B     99,115,46,108,111,117,105,115,118,105,108,108
000022E6= 65 2E 65 64 75 00       1615         DC.B     101,46,101,100,117,0
000022EC                          1616           
000022EC                          1617  addingErrorMessage      
000022EC= 0D 0A                   1618          DC.B     CR,LF
000022EE= 41 4C 55 20 54 65 ...   1619          DC.B     'ALU Test Error:',CR,LF
000022FF= 41 64 64 69 6E 67 ...   1620          DC.B     'Adding error.',CR,LF,0
0000230F                          1621                  
0000230F                          1622  subtractingErrorMessage 
0000230F= 0D 0A                   1623          DC.B     CR,LF
00002311= 41 4C 55 20 54 65 ...   1624          DC.B     'ALU Test Error:',CR,LF
00002322= 53 75 62 74 72 61 ...   1625          DC.B     'Subtracting error.',CR,LF,0
00002337                          1626                  
00002337                          1627  multiplyingErrorMessage 
00002337= 0D 0A                   1628          DC.B      CR,LF
00002339= 41 4C 55 20 54 65 ...   1629          DC.B      'ALU Test Error:',CR,LF
0000234A= 4D 75 6C 74 69 70 ...   1630          DC.B      'Multiplying error.',CR,LF,0
0000235F                          1631                  
0000235F                          1632  dividingErrorMessage    
0000235F= 0D 0A                   1633          DC.B      CR,LF
00002361= 41 4C 55 20 54 65 ...   1634          DC.B      'ALU Test Error:',CR,LF
00002372= 44 69 76 69 64 69 ...   1635          DC.B      'Dividing error.',CR,LF,0
00002384                          1636                  
00002384                          1637  finishedALUTest
00002384= 0D 0A                   1638          DC.B      CR,LF
00002386= 41 4C 55 20 54 45 ...   1639          DC.B      'ALU TEST COMPLETE',CR,LF,0
0000239A                          1640                  
0000239A                          1641  MemTestSuccess
0000239A= 0D 0A                   1642          DC.B      CR,LF
0000239C= 4D 45 4D 4F 52 59 ...   1643          DC.B      'MEMORY TEST COMPLETE',CR,LF,0
000023B3                          1644                  
000023B3                          1645  ramErrorMessage 
000023B3= 0D 0A                   1646          DC.B      CR,LF
000023B5= 54 68 65 72 65 20 ...   1647          DC.B      'There was an error reading/writing in Ram at address: ',CR,LF,0
000023EE                          1648          
000023EE                          1649   
000023EE                          1650  _chr:
000023EE= 01                      1651          DC.B    1
000023EF                          1652        
000023EF                          1653          END     RESET

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ACIA                8001
ADD                 10F0
ADDINGERROR         112C
ADDINGERRORMESSAGE  22EC
ADD_ER              18C6
ADR_DAT             1440
ALUTEST             10DA
BP_TAB              164
BRKPT               18EE
BR_CLR              1A74
BR_CLR1             1A7C
BR_CLR2             1A86
BR_GET              19CA
BR_GET1             19DA
BR_GET2             19E6
BR_GET3             19F6
BR_GET4             19FE
BR_SET              1A08
BR_SET1             1A16
BR_SET2             1A24
BS                  8
BUFFEND             100
BUFFER              394
BUFFPT              102
BUS_ER              18B2
BYTE                135A
CLEARRAM            1042
CLR_BPT             173E
CN_IVEC             112
CN_OVEC             116
COMMAND             8000A
COMMAND_1           1C46
COMTAB              1CB6
CON_I1              164A
CON_I2              1662
CON_IN              163C
CON_OT1             167A
CON_OT2             1690
CON_OT3             1698
CON_OUT             166C
CR                  D
CRLF                1D6E
CTRL_A              1
DATA                4500
DCB1                1D4A
DCB2                1D5C
DCB_LST             1D4A
DELAY               15CE
DELAY1              15D8
DIVIDE              111C
DIVIDINGERRORMESSAGE  235F
DIVISIONERROR       115C
DUMP                1526
DUMP1               1536
DUMP2               1542
DUMP3               1558
DUMP4               156C
DUMP5               157A
DUMP6               1594
DUMP7               15B8
ECHO                10A
ENDALUTEST          116C
ERMES1              1E61
ERMES2              1E7F
ERMES3              1E91
ERMES4              1E9F
ERMES5              1EAD
ERMES6              1EC7
ERMES7              1EE1
ERMES8              1EEE
EXEC1               12E2
EXEC2               12F2
EXECUTE             12D0
EX_D1               182E
EX_DIS              181C
FINISHEDALUTEST     2384
FIRST               194
FUNC1               175C
FUNC10              17C6
FUNC11              17D2
FUNC12              17DE
FUNC13              17EA
FUNC14              17F6
FUNC15              1802
FUNC16              180E
FUNC17              181A
FUNC2               1766
FUNC3               1772
FUNC4               177E
FUNC5               178A
FUNC6               1796
FUNC7               17A2
FUNC8               17AE
FUNC9               17BA
GB                  198C
GETCH2              16D2
GETCH3              16F0
GETCHAR             16AC
GETLINE             11B8
GETLN2              11C2
GETLN3              11DC
GETLN4              11E6
GETLN5              11EA
GETPASS             11EE
GETPS2              11F8
GETPS3              1212
GETPS4              121E
GETPS5              1222
GETSTAR             1228
GO                  196C
GO1                 197C
GO2                 198A
GROUP1              190C
GROUP1A             192A
GROUP2              1940
GROUP2A             194C
HEADER              1D79
HEADING             11B2
HEBR                209B
HEDI                2026
HEDU                1FA3
HEGB                212E
HEGO                2065
HEJU                1F04
HEKI                2104
HELO                1F70
HELP                1BA0
HEME                1F3D
HENO                1FE4
HEPL                20DB
HERE                2161
HEX                 133C
HEX_OK              1358
IL_ER               189A
IO_OPEN             1704
IO_REQ              162A
JUMP                13EC
JUMP1               13FA
LBPT                1746
LF                  A
LNBUFF              C1
LOAD                1462
LOAD1               147E
LOAD2               148E
LOAD3               14A8
LOAD4               14C2
LOAD5               14D0
LOAD6               14D2
LOAD6A              14F6
LOAD7               1508
LOAD8               151E
LOG1                1B1A
LOGF                1B6E
LOGINERROR          21F6
LOGM                21CE
LOGON               1B12
LOGS                1B78
LONGWD              1370
LSCH                1B7E
LSCH0               1B88
LSCHF               1B9A
LSCHS               1B98
MAXCHR              40
MEM1                140C
MEM2                142A
MEM3                143E
MEMORY              1402
MEMTESTEND          10CA
MEMTESTSUCCESS      239A
MES1                1D85
MES10               1DE5
MES11               1DFB
MES12               1E09
MES13               1E12
MES14               1E23
MES2                1D8E
MES2A               1D97
MES3                1DA0
MES4                1DBE
MES8                1DC5
MES9                1DD3
MULTIPLICATIONERROR  114C
MULTIPLY            110C
MULTIPLYINGERRORMESSAGE  2337
NAN                 219A
NEWLINE             1192
NOBR                1A2E
NOBR1               1A3E
NOBR2               1A4C
NOBR3               1A5C
NOBR4               1A62
NOBR5               1A6A
NOT_HEX             1354
OPEN1               170C
OPEN2               1714
OPEN3               1722
OPEN4               1738
OPERAND             80010
OUT1X               13BA
OUT1X1              13CC
OUT2X               13D4
OUT4X               13DC
OUT8X               13E4
PARAM               1376
PARAM1              137E
PARAM3              13A2
PARAM4              13A6
PARAM5              13B2
PARAM6              13B6
PARAMTR             106
PASS                21EF
PASSCH2             1250
PASSCH3             126E
PASSM               21E4
PRI_ER              18DA
PS1                 11A4
PS2                 11AE
PSPACE              1454
PSTRING             11A2
PUTCHAR             16F4
PUTSTAR             1272
PUTSTARS            1280
RAMCLEARERROR       106E
RAMERRORMESSAGE     23B3
RAMTEST             1036
RAMWRITEERROR       109C
RANGE               15BE
REGNAME             1E38
REG_MD1             1AAE
REG_MD2             1AC4
REG_MD3             1AD4
REG_MD4             1AF2
REG_MD5             1AFE
REG_MOD             1A90
RESET               1000
RESPONSE            80000
REST1               19A2
RESTORE             1992
SEARCH              12FC
SETACIA             117C
SET_DCB             15E0
SIMMODE             C0
SKIP                16EE
SPACE               20
SRCH2               1316
SRCH3               131A
SRCH4               1322
SRCH6               132C
SRCH7               1336
STACK               4400
STAR                10B
ST_DCB1             15F0
ST_DCB2             15F4
SUBTRACT            10FE
SUBTRACTINGERROR    113C
SUBTRACTINGERRORMESSAGE  230F
TAIL                1D7F
TIDY                128E
TIDY1               1294
TIDY2               12A0
TIDY3               12AA
TIDY4               12B4
TIDY5               12BE
TIDY6               12CA
TINYWA1_1           221E
TINYWA1_2           2237
TINYWA1_3           2264
TINYWA1_4           227C
TINYWA1_5           22B3
TINYWA1_6           22CC
TRACE               19B6
TRAP_0              1750
TRAP_14             4E4E
TSK_T               11A
USERNA              21DB
UTAB                10E
U_CASE              10C
WAIT                57
WORD                136A
WRITERAM            1058
X_UN                1B02
_00000000           126A
_00000001           126E
_BANNER             1C58
_CHR                23EE
_COMMAND            1C46
_EXECUTE            12D0
_GETLINE            11B8
_GETPASS            11EE
_GO                 196C
_HELP               1BA0
_LOAD               1462
_LOGON              1B12
_LSCH               1B7E
_MAIN               1C46
_MAINSTART          1C34
_NEWLINE            1192
_PSTRING            11A2
_RESET              1000
_TIDY               128E
