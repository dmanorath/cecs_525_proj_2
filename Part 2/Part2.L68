00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 2/24/2018 3:46:39 PM

00000000                             1  *=============================================================================
00000000                             2  *   Exception Vector Table in ROM
00000000                             3                  ORG     $0
00000000                             4                  * 00-03 SSP, Reset, bus error, address error
00000000= 00004400 00001000 ...      5                  DC.L    STACK,RESET,BUS_ER,ADD_ER
00000010                             6                  * 04-07 ILLEGAL, zero divide, CHK, TRAPV
00000010= 0000189A 00001B04 ...      7                  DC.L    IL_ER,X_UN,X_UN,X_UN
00000020                             8                  * 08-0F Privilege, Trace, 1010, 1111, 3 Reserved, Uninitialized
00000020= 000018DC 00001B04 ...      9                  DC.L    PRI_ER,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000040                            10                  * 10-17 Uninitialized
00000040= 00001B04 00001B04 ...     11                  DC.L    X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000060                            12                  * 18-1F Uninitialized
00000060= 00001B04 00001B04 ...     13                  DC.L    X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000080                            14                  * 20-2F TRAP Vectors: 0, 14, 15 are initialized
00000080= 00001750 00001B04 ...     15                  DC.L    TRAP_0,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000000A0= 00001B04 00001B04 ...     16                  DC.L    X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,BRKPT,_main
000000C0                            17  * *=============================================================================
000000C0  =00000008                 18  BS              EQU     $08             Back_space
000000C0  =0000000D                 19  CR              EQU     $0D             Carriage_return
000000C0  =0000000A                 20  LF              EQU     $0A             Line_feed
000000C0  =00000020                 21  SPACE           EQU     $20             Space
000000C0  =00000057                 22  WAIT            EQU     'W'             Wait character (to suspend output)
000000C0  =00000001                 23  CTRL_A          EQU     $01             Control_A forces return to monitor
000000C0                            24  *                                       Device addresses
000000C0  =00004400                 25  STACK           EQU     $4400           Stack_pointer
000000C0  =00008001                 26  ACIA            EQU     $8001           Console ACIA control
000000C0  =00004E4E                 27  TRAP_14         EQU     $4E4E           Code for TRAP #14
000000C0  =00000040                 28  MAXCHR          EQU     64              Length of input line buffer
000000C0  =0008000A                 29  COMMAND         EQU     $8000A          Address of FPU command register
000000C0  =00080000                 30  RESPONSE    EQU  $80000         Address of FPU response register
000000C0  =00080010                 31  OPERAND         EQU     $80010          Address of FPU operand register
000000C0                            32  *
000000C0= 00                        33  SIMMODE     DC.B        0               1 for sim mode 0 for board
000000C1  =00004500                 34  DATA            EQU     $4500           Data origin
000000C1                            35  LNBUFF          DS.B    MAXCHR          Input line buffer
00000101  =00000100                 36  BUFFEND         EQU     LNBUFF+MAXCHR-1 End of line buffer
00000102                            37  BUFFPT          DS.L    1               Pointer to line buffer
00000106                            38  PARAMTR         DS.L    1               Last parameter from line buffer
0000010A                            39  ECHO            DS.B    1               When clear this enable input echo
0000010B                            40  STAR            DS.B    1
0000010C                            41  U_CASE          DS.B    1               Flag for upper case conversion
0000010E                            42  UTAB            DS.L    1               Pointer to user command table
00000112                            43  CN_IVEC         DS.L    1               Pointer to console input DCB
00000116                            44  CN_OVEC         DS.L    1               Pointer to console output DCB
0000011A                            45  TSK_T           DS.W    37              Frame for D0-D7, A0-A6, USP, SSP, SW, PC
00000164                            46  BP_TAB          DS.W    24              Breakpoint table
00000194                            47  FIRST           DS.B    512             DCB area
00000394                            48  BUFFER          DS.B    256             256 bytes for I/O buffer
00000494                            49   
00000494                            50  *   This is the main program which assembles a command in the line
00000494                            51  *   buffer, removes leading/embedded spaces and interprets it by matching
00000494                            52  *   it with a command in the user table or the built-in table COMTAB
00000494                            53  *   All variables are specified with respect to A6
00000494                            54   
00000494                            55   
00001000                            56                  ORG     $1000           Monitor Origin
00001000                            57  _RESET
00001000  =00001000                 58  RESET:          EQU     *
00001000  4DF8 4500                 59                  LEA.L   DATA,A6         A6 points to data area
00001004  2D4E 0152                 60                  MOVE.L  A6,TSK_T+56(A6) initialize A6 in the register Frame
00001008  4DF8 4500                 61                  LEA.L   DATA,A6         A6 points to data area
0000100C  42AE 010E                 62                  CLR.L   UTAB(A6)        Reset pointer to user extension table
00001010  422E 010A                 63                  CLR.B   ECHO(A6)        Set automatic character echo
00001014  422E 010B                 64                  CLR.B   STAR(A6)        Clear this flag for a standard echo
00001018  422E 010C                 65                  CLR.B   U_CASE(A6)      Clear case conversion flag (UC<-LC)
0000101C  6100 015E                 66                  BSR     SETACIA         Setup ACIAs
00001020  6100 071C                 67                  BSR     CLR_BPT         Clear break point table
00001024  6100 05BA                 68                  BSR     SET_DCB         Setup DCB table in RAM
00001028  6100 00B0                 69                  BSR     ALUTest
0000102C  6100 0008                 70                  BSR     RamTest
00001030  4287                      71                          CLR.L   D7
00001032  6100 0C04                 72                  BSR     _mainstart
00001036                            73  *===========================================================================
00001036                            74  *   MEM TEST
00001036                            75   
00001036                            76   
00001036                            77  RamTest
00001036  7AFF                      78                  move.l #$FFFFFFFF, d5
00001038  207C 00004000             79                  move.l #$4000, a0
0000103E                            80                  ;bsr    ClearRam
0000103E                            81                  ;bsr    WriteRam
0000103E  6000 008A                 82                  bra     MemTestEnd
00001042                            83    
00001042                            84  ClearRam
00001042  4290                      85                  clr.l   (a0) 
00001044  0C98 00000000             86                  cmpi.l #0,(a0)+
0000104A  6600 0022                 87                  bne     RamClearError
0000104E  B1FC 00005000             88                  cmp.l   #$5000, a0
00001054  66EC                      89                  bne     ClearRam
00001056  4E75                      90                  rts
00001058                            91          
00001058                            92  WriteRam
00001058  2105                      93                  move.l d5, -(a0)
0000105A  0C90 FFFFFFFF             94                  cmpi.l  #$FFFFFFFF, (a0)
00001060  6600 003A                 95                  bne     RamWriteError
00001064  B1FC 00004000             96                  cmp.l   #$4000, a0
0000106A  66EC                      97                  bne     WriteRam
0000106C  4E75                      98                  rts
0000106E                            99     
0000106E                           100  RamClearError
0000106E                           101                  ; exception message
0000106E  5348                     102                  sub     #$01, a0
00001070  49F9 000023B7            103                  lea.l   ramErrorMessage,a4              
00001076  6100 012A                104                  bsr     PSTRING
0000107A  6100 0116                105                  bsr     NEWLINE  
0000107E  103C 000F                106                  move.b  #15,d0
00001082  143C 0010                107                  move.b  #16,d2
00001086  3848                     108                  move    a0,a4
00001088  6100 0118                109                  bsr     PSTRING
0000108C  6100 0104                110                  bsr     NEWLINE         
00001090  5248                     111                  add     #$01,a0
00001092  B1FC 00005000            112                  cmp.l   #$5000, a0
00001098  66A8                     113                  bne     ClearRam
0000109A  4E75                     114                  rts
0000109C                           115     
0000109C                           116  RamWriteError
0000109C                           117                  ; exception message 
0000109C  103C 000E                118                  move.b  #14,d0          
000010A0  49F9 000023B7            119                  lea.l   ramErrorMessage,a4              
000010A6  6100 00FA                120                  bsr     PSTRING
000010AA  6100 00E6                121                  bsr     NEWLINE  
000010AE  103C 000F                122                  move.b  #15,d0
000010B2  143C 0010                123                  move.b  #16,d2
000010B6  3848                     124                  move    a0,a4
000010B8  6100 00E8                125                  bsr     PSTRING
000010BC  6100 00D4                126                  bsr     NEWLINE         
000010C0  B1FC 00004000            127                  cmp.l   #$4000, a0
000010C6  6690                     128                  bne     WriteRam
000010C8  4E75                     129                  rts
000010CA                           130          
000010CA                           131  MemTestEnd
000010CA  49F9 0000239E            132                  lea     MemTestSuccess,a4
000010D0  6100 00D0                133                  bsr     _PSTRING
000010D4  6100 00BC                134                  bsr     _NEWLINE
000010D8  4E75                     135                  rts
000010DA                           136     
000010DA                           137          
000010DA                           138  *============================================================================
000010DA                           139  *   ALU Test
000010DA                           140   
000010DA                           141  ALUTest:
000010DA  720E                     142                  move.l #14, d1
000010DC                           143     
000010DC  6100 0012                144                  bsr     Add
000010E0  6100 001C                145                  bsr     Subtract
000010E4  6100 0026                146                  bsr     Multiply
000010E8  6100 0032                147                  bsr     Divide
000010EC  6000 007E                148                  bra      EndALUTest
000010F0                           149   
000010F0                           150  Add
000010F0  5E81                     151                  add.l  #7, d1
000010F2  0C81 00000015            152                  cmpi.l #21, d1
000010F8  6600 0032                153                  bne     AddingError
000010FC  4E75                     154                  rts
000010FE                           155          
000010FE                           156  Subtract
000010FE  5F81                     157                  sub.l  #7, d1
00001100  0C81 0000000E            158                  cmpi.l  #14, d1
00001106  6600 0034                159                  bne     SubtractingError
0000110A  4E75                     160                  rts
0000110C                           161  Multiply
0000110C  C3FC 0002                162                  muls.w  #2, d1
00001110  0C81 0000001C            163                  cmpi.l  #28, d1
00001116  6600 0034                164                  bne     MultiplicationError
0000111A  4E75                     165                  rts
0000111C                           166     
0000111C                           167  Divide
0000111C  83FC 0002                168                  divs.w  #2, d1
00001120  0C81 0000000E            169                  cmpi.l  #14, d1
00001126  6600 0034                170                  bne     DivisionError
0000112A  4E75                     171                  rts
0000112C                           172     
0000112C                           173  AddingError     
0000112C  49F9 000022F0            174                  lea     addingErrorMessage,a4   
00001132  6100 006E                175                  bsr     _PSTRING
00001136  6100 005A                176                  bsr     _NEWLINE
0000113A  4E75                     177                  rts
0000113C                           178     
0000113C                           179  SubtractingError        
0000113C  49F9 00002313            180                  lea     subtractingErrorMessage,a4      
00001142  6100 005E                181                  bsr     _PSTRING
00001146  6100 004A                182                  bsr     _NEWLINE
0000114A  4E75                     183                  rts
0000114C                           184     
0000114C                           185  MultiplicationError             
0000114C  49F9 0000233B            186                  lea     multiplyingErrorMessage,a4      
00001152  6100 004E                187                  bsr     _PSTRING
00001156  6100 003A                188                  bsr     _NEWLINE
0000115A  4E75                     189                  rts
0000115C                           190     
0000115C                           191  DivisionError           
0000115C  49F9 00002363            192                  lea     dividingErrorMessage,a4 
00001162  6100 003E                193                  bsr     _PSTRING
00001166  6100 002A                194                  bsr     _NEWLINE
0000116A  4E75                     195                  rts
0000116C                           196   
0000116C                           197  EndALUTest
0000116C  49F9 00002388            198                  lea     finishedALUTest,a4
00001172  6100 002E                199                  bsr     _PSTRING
00001176  6100 001A                200                  bsr     _NEWLINE
0000117A  4E75                     201                  rts
0000117C                           202   
0000117C                           203  *=============================================================================
0000117C                           204  *   Some initialization and basic routines
0000117C                           205   
0000117C  =0000117C                206  SETACIA         EQU     *               Setup ACIA parameters
0000117C  41F9 00008001            207                  LEA.L   ACIA,A0         A0 points to console ACIA
00001182  10BC 0003                208                  MOVE.B  #$03,(A0)       Reset ACIA
00001186  10BC 0019                209                  MOVE.B  #$19,(A0)       Set up ACIA constants (no IRQ,
0000118A  117C 0019 0001           210                  MOVE.B  #$19,1(A0)      8 bit, even parity, 1 stop, no flowctrl
00001190  4E75                     211                  RTS                      Return
00001192                           212  *=============================================================================
00001192                           213  *   Prints a newline carriage return
00001192                           214   
00001192                           215  _NEWLINE
00001192  =00001192                216  NEWLINE         EQU     *               Move cursor to start of newline
00001192  48E7 0008                217                  MOVEM.L A4,-(A7)        Save A4
00001196  49FA 0BDA                218                  LEA.L   CRLF(PC),A4     Point to CR/LF string
0000119A  6106                     219                  BSR.S   PSTRING         Print it
0000119C  4CDF 1000                220                  MOVEM.L (A7)+,A4        Restore A4
000011A0  4E75                     221                  RTS                     Return
000011A2                           222  _PSTRING
000011A2  =000011A2                223  PSTRING         EQU     *               Display the string pointed at by A4
000011A2  2F00                     224                  MOVE.L  D0,-(A7)        Save D0
000011A4  101C                     225  PS1             MOVE.B  (A4)+,D0        Get character to be printed
000011A6  6706                     226                  BEQ.S   PS2             
000011A8  6100 054A                227                  BSR     PUTCHAR         Else print it
000011AC  60F6                     228                  BRA     PS1             Continue
000011AE  201F                     229  PS2             MOVE.L  (A7)+,D0        Restore D0 and exit
000011B0  4E75                     230                  RTS
000011B2                           231   
000011B2  61DE                     232  HEADING         BSR     NEWLINE         Same as PSTRING but with newline
000011B4  61EC                     233                  BSR     PSTRING
000011B6  60DA                     234                  BRA     NEWLINE
000011B8                           235   
000011B8                           236  *=============================================================================
000011B8                           237  *   GETLINE inputs a string of characters into a line buffer
000011B8                           238  *               A3 points to next free entry in line buffer
000011B8                           239  *               A2 points to end of buffer
000011B8                           240  *               A1 points to start of buffer
000011B8                           241  *               D0 holds character to be stored
000011B8                           242  _GETLINE
000011B8  43EE 00C1                243  GETLINE         LEA.L   LNBUFF(A6),A1   A1 points to start of line buffer
000011BC  47D1                     244                  LEA.L   (A1),A3         A3 points to start (initially)
000011BE  45E9 0040                245                  LEA.L   MAXCHR(A1),A2   A2 points to end of buffer
000011C2  6100 04E8                246  GETLN2          BSR     GETCHAR         Get a character
000011C6  B03C 0001                247                  CMP.B   #CTRL_A,D0      If control_A then reject this line
000011CA  671E                     248                  BEQ.S   GETLN5          and get another line
000011CC  B03C 0008                249                  CMP.B   #BS,D0          If back_space then move back pointer
000011D0  660A                     250                  BNE.S   GETLN3          Else skip past wind-back routine
000011D2  B7C9                     251                  CMP.L   A1,A3           First check for empty buffer
000011D4  67EC                     252                  BEQ     GETLN2          If buffer empty then continue
000011D6  47EB FFFF                253                  LEA     -1(A3),A3       Else decrement buffer pointer
000011DA  60E6                     254                  BRA     GETLN2          and continue with next character
000011DC  16C0                     255  GETLN3          MOVE.B  D0,(A3)+        Store character and update pointer
000011DE  B03C 000D                256                  CMP.B   #CR,D0          Test for command terminator
000011E2  6602                     257                  BNE.S   GETLN4          If not CR then skip past exit
000011E4  60AC                     258                  BRA     NEWLINE         Else new line before next operation
000011E6  B7CA                     259  GETLN4          CMP.L   A2,A3           Test for buffer overflow
000011E8  66D8                     260                  BNE     GETLN2          If buffer not full then continue
000011EA  61A6                     261  GETLN5          BSR     NEWLINE         Else move to next line and
000011EC  60CA                     262                  BRA     GETLINE         repeat this routine
000011EE                           263  *=============================================================================
000011EE                           264  *  GETPASS  inputs a string of characters into a line buffer
000011EE                           265  *               A3 points to next free entry in line buffer
000011EE                           266  *               A2 points to end of buffer
000011EE                           267  *               A1 points to start of buffer
000011EE                           268  *               D0 holds character to be stored
000011EE                           269  *
000011EE                           270  _GETPASS
000011EE  43EE 00C1                271  GETPASS     LEA.L       LNBUFF(A6),A1  A1 points to start of password buffer
000011F2  47D1                     272              LEA.L       (A1),A3         A3 points to start (initially)
000011F4  45E9 0040                273              LEA.L       MAXCHR(A1),A2  A2 points to end of buffer
000011F8  6100 002E                274  GETPS2      BSR         GETSTAR         Get a character
000011FC  B03C 0001                275              CMP.B       #CTRL_A,D0      If control_A then reject this line
00001200  6720                     276              BEQ.S       GETPS5          and get another line
00001202  B03C 0008                277              CMP.B       #BS,D0          If back_space then move back pointer
00001206  660A                     278              BNE.S       GETPS3          Else skip past wind-back routine
00001208  B7C9                     279              CMP.L       A1,A3           First check for empty buffer
0000120A  67EC                     280              BEQ         GETPS2          If buffer empty then continue
0000120C  47EB FFFF                281              LEA         -1(A3),A3       Else decrement buffer pointer
00001210  60E6                     282              BRA         GETPS2          and continue with next character
00001212  16C0                     283  GETPS3      MOVE.B   D0,(A3)+           Store character and update pointer
00001214  B03C 000D                284              CMP.B       #CR,D0          Test for command terminator
00001218  6604                     285              BNE.S       GETPS4          If not CR then skip past exit
0000121A  6000 FF76                286              BRA         NEWLINE         Else new line before next operation
0000121E  B7CA                     287  GETPS4      CMP.L       A2,A3           Test for buffer overflow
00001220  66D6                     288              BNE         GETPS2          If buffer not full then continue
00001222  6100 FF6E                289  GETPS5      BSR         NEWLINE         Else move to next line and
00001226  60C6                     290              BRA         GETPASS         repeat this routine
00001228                           291           
00001228                           292  *************************************************************************
00001228                           293  *
00001228                           294  *  GETSTAR gets a character from the console device
00001228                           295  *  This is the main input routine and uses the device whose name 
00001228                           296  *  is stored in CN_IVEC. Changing this name redirects input.
00001228                           297   
00001228  2F08                     298  GETSTAR     MOVE.L  A0,-(A7)            Save working register
0000122A  206E 0112                299              MOVE.L  CN_IVEC(A6),A0  A0 points to name of console DCB
0000122E  6100 04D4                300              BSR.L   IO_OPEN             Open console (get DCB address in A0)
00001232  0807 0003                301              BTST    #3,D7               D7(3) set if open error
00001236  6636                     302              BNE.S   PASSCH3             If error then exit now
00001238  6100 03F0                303              BSR         IO_REQ          Else execute I/O transaction
0000123C  C03C 007F                304              AND.B   #$7F,D0             Strip msb of input
00001240  4A2E 010C                305              TST.B   U_CASE(A6)          Test for upper -> lower case conversion
00001244  660A                     306              BNE.S   PASSCH2             If flag not zero do not convert case
00001246  0800 0006                307              BTST        #6,D0           Test input for lower case
0000124A  6704                     308              BEQ.S   PASSCH2             If upper case then skip conversion
0000124C  C03C 00DF                309              AND.B   #%11011111,D0   Else clear bit 5 for upper case conv
00001250                           310   
00001250  43F8 00C0                311  PASSCH2     LEA.L       SIMMODE,A1
00001254  1E11                     312              MOVE.B   (A1),D7
00001256                           313   
00001256                           314           if.l d7 <eq> #1 then.s
0000125E  6100 0012                315                  BSR.L   PUTSTAR         Echo the input
00001262  6100 001C                316                  BSR.L   PUTSTARS
00001266                           317           else
0000126A  6100 0014                318                  BSR.L   PUTSTARS
0000126E                           319           endi
0000126E                           320          
0000126E  205F                     321  PASSCH3     MOVE.L  (A7)+,A0            Restore working register
00001270  4E75                     322              RTS                         and return
00001272                           323   
00001272                           324  *************************************************************************
00001272                           325  *
00001272                           326  *  PUTSTAR removes a character to the console device so password is not shown
00001272                           327  *  The name of the output device is in CN_OVEC.
00001272                           328  *
00001272  3F00                     329  PUTSTAR     MOVE.W   D0,-(A7)           Save D0
00001274                           330                  ;MOVE.B   #$2A,D0       Load * into D0
00001274  103C 0008                331                  move.B  #$8,D0
00001278  6100 047A                332                  BSR   PUTCHAR           Print the character
0000127C  301F                     333                  MOVE.W   (A7)+,D0       Restore D0
0000127E  4E75                     334                  RTS
00001280                           335  *************************************************************************
00001280                           336  *
00001280                           337  *  PUTSTARS adds a * to the console device for each character of password
00001280                           338  *  The name of the output device is in CN_OVEC.
00001280                           339  *        
00001280  3F00                     340  PUTSTARS    MOVE.W   D0,-(A7)           Save D0
00001282  103C 002A                341                  MOVE.B   #$2A,D0        Load * into D0
00001286                           342                  ;move.B  #$8,D0
00001286  6100 046C                343                  BSR     PUTCHAR         Print the character
0000128A  301F                     344                  MOVE.W  (A7)+,D0        Restore D0
0000128C  4E75                     345                  RTS
0000128E                           346          
0000128E                           347  * *==============================================================================
0000128E                           348  *
0000128E                           349  *   TIDY        cleans up the line buffer by removing leading spaces and multiple
0000128E                           350  *               spaces between parameters. At the end of TIDY, BUFFPT points to
0000128E                           351  *               the first parameter following the command.
0000128E                           352  *               A0 = pointer to line buffer. A1 = pointer to cleaned up buffer
0000128E                           353  _TIDY
0000128E  41EE 00C1                354  TIDY            LEA.L   LNBUFF(A6),A0   A0 points to line buffer
00001292  43D0                     355                  LEA.L   (A0),A1         A1 points to start of line buffer
00001294  1018                     356  TIDY1           MOVE.B  (A0)+,D0        Read character from line buffer
00001296  B03C 0020                357                  CMP.B   #SPACE,D0       Repeat until the first non-space
0000129A  67F8                     358                  BEQ     TIDY1           character is found
0000129C  41E8 FFFF                359                  LEA.L   -1(A0),A0       Move pointer back to first char
000012A0  1018                     360  TIDY2           MOVE.B  (A0)+,D0        Move the string left to remove
000012A2  12C0                     361                  MOVE.B  D0,(A1)+        any leading spaces
000012A4  B03C 0020                362                  CMP.B   #SPACE,D0       Test for embedded space
000012A8  660A                     363                  BNE.S   TIDY4           If not space then test for EOL
000012AA  0C18 0020                364  TIDY3           CMP.B   #SPACE,(A0)+    If space skip multiple embedded
000012AE  67FA                     365                  BEQ     TIDY3           spaces
000012B0  41E8 FFFF                366                  LEA.L   -1(A0),A0       Move back pointer
000012B4  B03C 000D                367  TIDY4           CMP.B   #CR,D0          Test for end_of_line (EOL)
000012B8  66E6                     368                  BNE     TIDY2           If not EOL then read next char
000012BA  41EE 00C1                369                  LEA.L   LNBUFF(A6),A0   Restore buffer pointer
000012BE  0C10 000D                370  TIDY5           CMP.B   #CR,(A0)        Test for EOL
000012C2  6706                     371                  BEQ.S   TIDY6           If EOL then exit
000012C4  0C18 0020                372                  CMP.B   #SPACE,(A0)+    Test for delimiter
000012C8  66F4                     373                  BNE     TIDY5           Repeat until delimiter or EOL
000012CA  2D48 0102                374  TIDY6           MOVE.L  A0,BUFFPT(A6)   Update buffer pointer
000012CE  4E75                     375                  RTS
000012D0                           376   
000012D0                           377  * *==============================================================================
000012D0                           378  *
000012D0                           379  *   EXECUTE matches the first command in the line buffer with the
000012D0                           380  *               commands in a command table. An external table pointed at by
000012D0                           381  *               UTAB is searched first and then the in-built table, COMTAB.
000012D0                           382  _EXECUTE
000012D0  4AAE 010E                383  EXECUTE         TST.L   UTAB(A6)        Test pointer to user table
000012D4  670C                     384                  BEQ.S   EXEC1           If clear then try built-in table
000012D6  266E 010E                385                  MOVE.L  UTAB(A6),A3     Else pick up pointer to user table
000012DA  6120                     386                  BSR.S   SEARCH          Look for command in user table
000012DC  6404                     387                  BCC.S   EXEC1           If not found then try internal table
000012DE  2653                     388                  MOVE.L  (A3),A3         Else get absolute address of command
000012E0  4ED3                     389                  JMP     (A3)            from user table and execute it
000012E2                           390  *
000012E2  47FA 09D6                391  EXEC1           LEA.L   COMTAB(PC),A3   Try built-in command table
000012E6  6114                     392                  BSR.S   SEARCH          Look for command in built-in table
000012E8  6508                     393                  BCS.S   EXEC2           If found then execute command
000012EA  49FA 0B97                394                  LEA.L   ERMES2(PC),A4   Else print "invalid command"
000012EE  6000 FEB2                395                  BRA.L   PSTRING         and return
000012F2  2653                     396  EXEC2           MOVE.L  (A3),A3         Get the relative command address
000012F4  49FA 09C4                397                  LEA.L   COMTAB(PC),A4   pointed at by A3 and add it to
000012F8  D7CC                     398                  ADD.L   A4,A3           the PC to generate the actual
000012FA  4ED3                     399                  JMP     (A3)            command address. Then execute it.
000012FC                           400  *
000012FC  =000012FC                401  SEARCH          EQU     *               Match the command in the line buffer
000012FC  4280                     402                  CLR.L   D0              with command table pointed at by A3
000012FE  1013                     403                  MOVE.B  (A3),D0         Get the first character in the
00001300  6734                     404                  BEQ.S   SRCH7           current entry. If zero then exit
00001302  49F3 0006                405                  LEA.L   6(A3,D0.W),A4   Else calculate address of next entry
00001306  122B 0001                406                  MOVE.B  1(A3),D1        Get number of characters to match
0000130A  4BEE 00C1                407                  LEA.L   LNBUFF(A6),A5   A5 points to command in line buffer
0000130E  142B 0002                408                  MOVE.B  2(A3),D2        Get first character in this entry
00001312  B41D                     409                  CMP.B   (A5)+,D2        from the table and match with buffer
00001314  6704                     410                  BEQ.S   SRCH3           If match then try rest of string
00001316  264C                     411  SRCH2           MOVE.L  A4,A3           Else get address of next entry
00001318  60E2                     412                  BRA      SEARCH          and try the next entry in the table
0000131A  5301                     413  SRCH3           SUB.B   #1,D1           One less character to match
0000131C  670E                     414                  BEQ.S   SRCH6           If match counter zero then all done
0000131E  47EB 0003                415                  LEA.L   3(A3),A3        Else point to next character in table
00001322  141B                     416  SRCH4           MOVE.B  (A3)+,D2        Now match a pair of characters
00001324  B41D                     417                  CMP.B   (A5)+,D2
00001326  66EE                     418                  BNE     SRCH2           If no match then try next entry
00001328  5301                     419                  SUB.B   #1,D1           Else decrement match counter and
0000132A  66F6                     420                  BNE     SRCH4           repeat until no chars left to match
0000132C  47EC FFFC                421  SRCH6           LEA.L   -4(A4),A3       Calculate address of command entry
00001330  003C 0001                422                  OR.B    #1,CCR          point. Mark carry flag as success
00001334  4E75                     423                  RTS                     and return
00001336  023C 00FE                424  SRCH7           AND.B   #$FE,CCR        Fail - clear carry to indicate
0000133A  4E75                     425                  RTS                     command not found and return
0000133C                           426   *=============================================================================
0000133C                           427  *   Basic input routines
0000133C                           428  *   HEX =  Get one   hexadecimal character  into D0
0000133C                           429  *   BYTE   =  Get two   hexadecimal characters into D0
0000133C                           430  *   WORD   =  Get four  hexadecimal characters into D0
0000133C                           431  *   LONGWD =  Get eight hexadecimal characters into D0
0000133C                           432  *   PARAM  =  Get a longword from the line buffer into D0
0000133C                           433  *   Bit 0 of D7 is set to indicate a hexadecimal input error
0000133C                           434   
0000133C  6100 036E                435  HEX             BSR     GETCHAR         Get a character from input device
00001340  0400 0030                436                  SUB.B   #$30,D0         Convert to binary
00001344  6B0E                     437                  BMI.S   NOT_HEX         If less than $30 then exit with error
00001346  B03C 0009                438                  CMP.B   #$09,D0         Else test for number (0 to 9)
0000134A  6F0C                     439                  BLE.S   HEX_OK          If number then exit - success
0000134C  5F00                     440                  SUB.B   #$07,D0         Else convert letter to hex
0000134E  B03C 000F                441                  CMP.B   #$0F,D0         If character in range "A" to "F"
00001352  6F04                     442                  BLE.S   HEX_OK          then exit successfully
00001354  8E3C 0001                443  NOT_HEX         OR.B    #1,D7           Else set error flag
00001358  4E75                     444  HEX_OK          RTS                     and return
0000135A                           445   
0000135A  2F01                     446  BYTE            MOVE.L  D1,-(A7)        Save D1
0000135C  61DE                     447                  BSR     HEX             Get first hex character
0000135E  E900                     448                  ASL.B   #4,D0           Move it to MS nybble position
00001360  1200                     449                  MOVE.B  D0,D1           Save MS nybble in D1
00001362  61D8                     450                  BSR     HEX             Get second hex character
00001364  D001                     451                  ADD.B   D1,D0           Merge MS and LS nybbles
00001366  221F                     452          MOVE.L  (A7)+,D1        Restore D1
00001368  4E75                     453          RTS
0000136A                           454   
0000136A  61EE                     455  WORD    BSR     BYTE              Get upper order byte
0000136C  E140                     456          ASL.W   #8,D0           Move it to MS position
0000136E  60EA                     457          BRA     BYTE            Get LS byte and return
00001370                           458  *
00001370  61F8                     459  LONGWD  BSR     WORD            Get upper order word
00001372  4840                     460          SWAP    D0              Move it to MS position
00001374  60F4                     461          BRA     WORD            Get lower order word and return
00001376                           462   
00001376                           463  *=============================================================================
00001376                           464  *   PARAM reads a parameter from the line buffer and puts it in both
00001376                           465  *   PARAMTR(A6) and D0. Bit 1 of D7 is set on error.
00001376                           466   
00001376  2F01                     467  PARAM   MOVE.L  D1,-(A7)        Save D1
00001378  4281                     468          CLR.L   D1              Clear input accumulator
0000137A  206E 0102                469          MOVE.L  BUFFPT(A6),A0   A0 points to parameter in buffer
0000137E  1018                     470  PARAM1  MOVE.B  (A0)+,D0        Read character from line buffer
00001380  B03C 0020                471          CMP.B   #SPACE,D0       Test for delimiter
00001384  6720                     472          BEQ.S   PARAM4          The permitted delimiter is a
00001386  B03C 000D                473          CMP.B   #CR,D0          space or a carriage return
0000138A  671A                     474          BEQ.S   PARAM4          Exit on either space or C/R
0000138C  E981                     475          ASL.L   #4,D1           Shift accumulated result 4 bits left
0000138E  0400 0030                476          SUB.B   #$30,D0         Convert new character to hex
00001392  6B1E                     477          BMI.S   PARAM5          If less than $30 then not-hex
00001394  B03C 0009                478          CMP.B   #$09,D0         If less than 10
00001398  6F08                     479          BLE.S   PARAM3          then continue
0000139A  5F00                     480          SUB.B   #$07,D0            Else assume $A - $F
0000139C  B03C 000F                481          CMP.B   #$0F,D0         If more than $F
000013A0  6E10                     482          BGT.S   PARAM5          then exit to error on not-hex
000013A2  D200                     483  PARAM3  ADD.B   D0,D1           Add latest nybble to total in D1
000013A4  60D8                     484          BRA     PARAM1          Repeat until delimiter found
000013A6  2D48 0102                485  PARAM4  MOVE.L  A0,BUFFPT(A6)   Save pointer in memory
000013AA  2D41 0106                486          MOVE.L  D1,PARAMTR(A6)  Save parameter in memory
000013AE  2001                     487          MOVE.L  D1,D0           Put parameter in D0 for return
000013B0  6004                     488          BRA.S   PARAM6          Return without error
000013B2  8E3C 0002                489  PARAM5  OR.B    #2,D7          Set error flag before return
000013B6  221F                     490  PARAM6  MOVE.L  (A7)+,D1        Restore working register
000013B8  4E75                     491          RTS                     Return with error
000013BA                           492  *============================================================================
000013BA                           493  *
000013BA                           494  *   Output routines
000013BA                           495  *   OUT1X   = print one   hexadecimal character
000013BA                           496  *   OUT2X   = print two   hexadecimal characters
000013BA                           497  *   OUT4X   = print four  hexadecimal characters
000013BA                           498  *   OUT8X   = print eight hexadecimal characters
000013BA                           499  *   In each case, the data to be printed is in D0
000013BA                           500   
000013BA  3F00                     501  OUT1X   MOVE.W  D0,-(A7)        Save D0
000013BC  C03C 000F                502          AND.B   #$0F,D0         Mask off MS nybble
000013C0  0600 0030                503          ADD.B   #$30,D0         Convert to ASCII
000013C4  B03C 0039                504          CMP.B   #$39,D0         ASCII = HEX + $30
000013C8  6302                     505          BLS.S   OUT1X1          If ASCII <= $39 then print and exit
000013CA  5E00                     506          ADD.B   #$07,D0         Else ASCII := HEX + 7
000013CC  6100 0326                507  OUT1X1  BSR     PUTCHAR         Print the character
000013D0  301F                     508          MOVE.W  (A7)+,D0        Restore D0
000013D2  4E75                     509          RTS
000013D4                           510  *
000013D4  E818                     511  OUT2X   ROR.B   #4,D0           Get MS nybble in LS position
000013D6  61E2                     512          BSR     OUT1X           Print MS nybble
000013D8  E918                     513             ROL.B   #4,D0        Restore LS nybble
000013DA  60DE                     514          BRA     OUT1X           Print LS nybble and return
000013DC                           515  *
000013DC  E058                     516  OUT4X   ROR.W   #8,D0           Get MS byte in LS position
000013DE  61F4                     517          BSR     OUT2X           Print MS byte
000013E0  E158                     518          ROL.W   #8,D0           Restore LS byte
000013E2  60F0                     519          BRA     OUT2X           Print LS byte and return
000013E4                           520  *
000013E4  4840                     521  OUT8X   SWAP    D0              Get MS word in LS position
000013E6  61F4                     522          BSR     OUT4X           Print MS word
000013E8  4840                     523          SWAP    D0              Restore LS word
000013EA  60F0                     524          BRA     OUT4X           Print LS word and return
000013EC                           525   *=============================================================================
000013EC                           526  *   JUMP causes execution to begin at the address in the line buffer
000013EC                           527   
000013EC  6188                     528  JUMP    BSR     PARAM           Get address from buffer
000013EE  4A07                     529          TST.B   D7              Test for input error
000013F0  6608                     530          BNE.S   JUMP1           If error flag not zero then exit
000013F2  4A80                     531          TST.L   D0              Else test for missing address
000013F4  6704                     532          BEQ.S   JUMP1           field. If no address then exit
000013F6  2040                     533          MOVE.L  D0,A0           Put jump address in A0 and call the
000013F8  4ED0                     534          JMP     (A0)            subroutine. User to supply RTS!!
000013FA  49FA 0A69                535  JUMP1   LEA.L   ERMES1(PC),A4   Here for error - display error
000013FE  6000 FDA2                536          BRA     PSTRING         message and return
00001402                           537   *=============================================================================
00001402                           538  *   Display the contents of a memory location and modify it
00001402                           539   
00001402  6100 FF72                540  MEMORY  BSR     PARAM           Get start address from line buffer
00001406  4A07                     541          TST.B   D7              Test for input error
00001408  6634                     542          BNE.S   MEM3            If error then exit
0000140A  2640                     543          MOVE.L  D0,A3           A3 points to location to be opened
0000140C  6100 FD84                544  MEM1    BSR     NEWLINE
00001410  612E                     545          BSR.S   ADR_DAT         Print current address and contents
00001412  6140                     546          BSR.S   PSPACE          update pointer, A3, and O/P space
00001414  6100 0296                547          BSR     GETCHAR         Input char to decide next action
00001418  B03C 000D                548          CMP.B   #CR,D0          If carriage return then exit
0000141C  6720                     549          BEQ.S   MEM3            Exit
0000141E  B03C 002D                550          CMP.B   #'-',D0         If "-" then move back
00001422  6606                     551          BNE.S   MEM2            Else skip wind-back procedure
00001424  47EB FFFC                552          LEA.L   -4(A3),A3       Move pointer back 2+2
00001428  60E2                     553          BRA     MEM1            Repeat until carriage return
0000142A  B03C 0020                554  MEM2    CMP.B   #SPACE,D0       Test for space (= new entry)
0000142E  66DC                     555          BNE.S   MEM1            If not space then repeat
00001430  6100 FF38                556          BSR     WORD            Else get new word to store
00001434  4A07                     557          TST.B   D7              Test for input error
00001436  6606                     558          BNE.S   MEM3            If error then exit
00001438  3740 FFFE                559          MOVE.W  D0,-2(A3)       Store new word
0000143C  60CE                     560          BRA     MEM1            Repeat until carriage return
0000143E  4E75                     561  MEM3    RTS
00001440                           562   
00001440  2F00                     563  ADR_DAT MOVE.L  D0,-(A7)        Print the contents of A3 and the
00001442  200B                     564          MOVE.L  A3,D0           word pointed at by A3.
00001444  619E                     565          BSR     OUT8X           and print current address
00001446  610C                     566          BSR.S   PSPACE          Insert delimiter
00001448  3013                     567          MOVE.W  (A3),D0         Get data at this address in D0
0000144A  6190                     568          BSR     OUT4X           and print it
0000144C  47EB 0002                569          LEA.L   2(A3),A3        Point to next address to display
00001450  201F                     570          MOVE.L  (A7)+,D0        Restore D0
00001452  4E75                     571          RTS
00001454                           572   
00001454  1F00                     573  PSPACE  MOVE.B  D0,-(A7)        Print a single space
00001456  103C 0020                574          MOVE.B  #SPACE,D0
0000145A  6100 0298                575          BSR     PUTCHAR
0000145E  101F                     576          MOVE.B  (A7)+,D0
00001460  4E75                     577          RTS
00001462                           578   *=============================================================================
00001462                           579  *   LOAD        Loads data formatted in hexadecimal "S" format from Port 2
00001462                           580  *               NOTE - I/O is automatically redirected to the aux port for
00001462                           581  *               loader functions. S1 or S2 records accepted
00001462                           582  _LOAD
00001462  2F2E 0116                583  LOAD    MOVE.L  CN_OVEC(A6),-(A7)   Save current output device name
00001466  2F2E 0112                584          MOVE.L  CN_IVEC(A6),-(A7)   Save current input device name
0000146A  522E 010A                585          ADD.B   #1,ECHO(A6)             Turn off character echo
0000146E  6100 FD22                586          BSR     NEWLINE                 Send newline to host
00001472  6100 015A                587          BSR     DELAY                   Wait for host to "settle"
00001476  6100 0156                588          BSR     DELAY
0000147A  286E 0102                589          MOVE.L  BUFFPT(A6),A4           Any string in the line buffer is
0000147E  101C                     590  LOAD1   MOVE.B  (A4)+,D0                transmitted to the host computer
00001480  6100 0272                591          BSR     PUTCHAR                 before the loading begins
00001484  B03C 000D                592          CMP.B   #CR,D0                  Read from the buffer until EOL
00001488  66F4                     593          BNE     LOAD1
0000148A  6100 FD06                594          BSR     NEWLINE                 Send newline before loading
0000148E  6100 021C                595  LOAD2   BSR     GETCHAR                 Records from the host must begin
00001492  B03C 0053                596          CMP.B   #'S',D0                 with S1/S2 (data) or S9/S8 (term)
00001496  66F6                     597          BNE.S   LOAD2                   Repeat GETCHAR until char = "S"
00001498  6100 0212                598          BSR     GETCHAR                 Get character after "S"
0000149C  B03C 0039                599          CMP.B   #'9',D0                 Test for the two terminators S9/S8
000014A0  6706                     600          BEQ.S   LOAD3                   If S9 record then exit else test
000014A2  B03C 0038                601          CMP.B   #'8',D0                 for S8 terminator. Fall through to
000014A6  662A                     602          BNE.S   LOAD6                   exit on S8 else continue search
000014A8  =000014A8                603  LOAD3   EQU     *                       Exit point from LOAD
000014A8  2D5F 0112                604          MOVE.L  (A7)+,CN_IVEC(A6)   Clean up by restoring input device
000014AC  2D5F 0116                605          MOVE.L  (A7)+,CN_OVEC(A6)   and output device name
000014B0  422E 010A                606          CLR.B   ECHO(A6)                Restore input character echo
000014B4  0807 0000                607          BTST    #0,D7                   Test for input errors
000014B8  6708                     608          BEQ.S   LOAD4                   If no I/P error then look at checksum
000014BA  49FA 09A9                609          LEA.L   ERMES1(PC),A4           Else point to error message
000014BE  6100 FCE2                610          BSR     PSTRING                 Print it
000014C2  0807 0003                611  LOAD4   BTST    #3,D7                   Test for checksum error
000014C6  6708                     612          BEQ.S   LOAD5                   If clear then exit
000014C8  49FA 09CB                613          LEA.L   ERMES3(PC),A4           Else point to error message
000014CC  6100 FCD4                614          BSR     PSTRING                 Print it and return
000014D0  4E75                     615  LOAD5   RTS
000014D2                           616   
000014D2  B03C 0031                617  LOAD6   CMP.B   #'1',D0                 Test for S1 record
000014D6  671E                     618          BEQ.S   LOAD6A                  If S1 record then read it
000014D8  B03C 0032                619          CMP.B   #'2',D0                 Else test for S2 record
000014DC  66B0                     620          BNE.S   LOAD2                   Repeat until valid header found
000014DE  4203                     621          CLR.B   D3                      Read the S2 byte count and address,
000014E0  613C                     622          BSR.S   LOAD8                   clear the checksum
000014E2  5900                     623          SUB.B   #4,D0                   Calculate size of data field
000014E4  1400                     624          MOVE.B  D0,D2                   D2 contains data bytes to read
000014E6  4280                     625          CLR.L   D0                      Clear address accumulator
000014E8  6134                     626          BSR.S   LOAD8                   Read most sig byte of address
000014EA  E180                     627          ASL.L   #8,D0                   Move it one byte left
000014EC  6130                     628          BSR.S   LOAD8                   Read the middle byte of address
000014EE  E180                     629          ASL.L   #8,D0                   Move it one byte left
000014F0  612C                     630          BSR.S   LOAD8                   Read least sig byte of address
000014F2  2440                     631          MOVE.L  D0,A2                   A2 points to destination of record
000014F4  6012                     632          BRA.S   LOAD7                   Skip past S1 header loader
000014F6  4203                     633  LOAD6A  CLR.B   D3                      S1 record found - clear checksum
000014F8  6124                     634          BSR.S   LOAD8                   Get byte and update checksum
000014FA  5700                     635          SUB.B   #3,D0                   Subtract 3 from record length
000014FC  1400                     636          MOVE.B  D0,D2                 Save byte count in D2
000014FE  4280                     637          CLR.L   D0                      Clear address accumulator
00001500  611C                     638          BSR.S   LOAD8                   Get MS byte of load address
00001502  E180                     639          ASL.L   #8,D0                   Move it to MS position
00001504  6118                     640          BSR.S   LOAD8                   Get LS byte in D2
00001506  2440                     641          MOVE.L  D0,A2                   A2 points to destination of data
00001508  6114                     642  LOAD7   BSR.S   LOAD8                   Get byte of data for loading
0000150A  14C0                     643          MOVE.B  D0,(A2)+                Store it
0000150C  5302                     644          SUB.B   #1,D2                   Decrement byte counter
0000150E  66F8                     645          BNE     LOAD7                   Repeat until count = 0
00001510  610C                     646          BSR.S   LOAD8                   Read checksum
00001512  5203                     647          ADD.B   #1,D3                   Add 1 to total checksum
00001514  6700 FF78                648          BEQ     LOAD2                   If zero then start next record
00001518  8E3C 0008                649          OR.B    #%00001000,D7           Else set checksum error bit,
0000151C  608A                     650          BRA     LOAD3                   restore I/O devices and return
0000151E                           651  *
0000151E  6100 FE3A                652  LOAD8   BSR     BYTE                    Get a byte
00001522  D600                     653          ADD.B   D0,D3                   Update checksum
00001524  4E75                     654          RTS                             and return
00001526                           655   *=============================================================================
00001526                           656  *   DUMP        Transmit S1 formatted records to host computer
00001526                           657  *               A3 = Starting address of data block
00001526                           658  *               A2 = End address of data block
00001526                           659  *               D1 = Checksum, D2 = current record length
00001526                           660   
00001526  6100 0096                661  DUMP    BSR     RANGE                   Get start and end address
0000152A  4A07                     662          TST.B   D7                      Test for input error
0000152C  6708                     663          BEQ.S   DUMP1                   If no error then continue
0000152E  49FA 0935                664          LEA.L   ERMES1(PC),A4           Else point to error message,
00001532  6000 FC6E                665          BRA     PSTRING                 print it and return
00001536  B08B                     666  DUMP1   CMP.L   A3,D0                   Compare start and end addresses
00001538  6A08                     667          BPL.S   DUMP2                   If positive then start < end
0000153A  49FA 09A9                668          LEA.L   ERMES7(PC),A4           Else print error message
0000153E  6000 FC62                669          BRA     PSTRING                 and return
00001542  2F2E 0116                670  DUMP2   MOVE.L  CN_OVEC(A6),-(A7)   Save name of current output device
00001546  2D7C 00001D60 0116       671          MOVE.L  #DCB2,CN_OVEC(A6)   Set up Port as output device
0000154E  6100 FC42                672          BSR     NEWLINE                 Send newline to host and wait
00001552  617A                     673          BSR.S   DELAY
00001554  286E 0102                674          MOVE.L  BUFFPT(A6),A4           Before dumping, send any string
00001558  101C                     675  DUMP3   MOVE.B  (A4)+,D0                in the input buffer to the host
0000155A  6100 0198                676          BSR     PUTCHAR                 Repeat
0000155E  B03C 000D                677          CMP.B   #CR,D0                  Transmit char from buffer to host
00001562  66F4                     678          BNE     DUMP3                   Until char = C/R
00001564  6100 FC2C                679          BSR     NEWLINE
00001568  6164                     680          BSR.S   DELAY                   Allow time for host to settle
0000156A  528A                     681          ADDQ.L  #1,A2                   A2 contains length of record + 1
0000156C  240A                     682  DUMP4   MOVE.L  A2,D2            D2 points to end address
0000156E  948B                     683          SUB.L   A3,D2                   D2 contains bytes left to print
00001570  B4BC 00000011            684          CMP.L   #17,D2                  If this is not a full record of 16
00001576  6502                     685          BCS.S   DUMP5                   then load D2 with record size
00001578  7410                     686          MOVEQ   #16,D2                  Else preset byte count to 16
0000157A  49FA 0801                687  DUMP5   LEA.L   HEADER(PC),A4           Point to record header
0000157E  6100 FC22                688          BSR     PSTRING                 Print header
00001582  4201                     689          CLR.B   D1                      Clear checksum
00001584  1002                     690          MOVE.B  D2,D0                   Move record length to output register
00001586  5600                     691          ADD.B   #3,D0                   Length includes address + count
00001588  612E                     692          BSR.S   DUMP7                   Print number of bytes in record
0000158A  200B                     693          MOVE.L  A3,D0                   Get start address to be printed
0000158C  E158                     694          ROL.W   #8,D0            Get MS byte in LS position
0000158E  6128                     695          BSR.S   DUMP7                   Print MS byte of address
00001590  E058                     696          ROR.W   #8,D0                   Restore LS byte
00001592  6124                     697          BSR.S   DUMP7                   Print LS byte of address
00001594  101B                     698  DUMP6   MOVE.B  (A3)+,D0                Get data byte to be printed
00001596  6120                     699          BSR.S   DUMP7                   Print it
00001598  5302                     700          SUB.B   #1,D2                   Decrement byte count
0000159A  66F8                     701          BNE     DUMP6                   Repeat until all this record printed
0000159C  4601                     702          NOT.B   D1                      Complement checksum
0000159E  1001                     703          MOVE.B  D1,D0                   Move to output register
000015A0  6116                     704          BSR.S   DUMP7                   Print checksum
000015A2  6100 FBEE                705          BSR     NEWLINE
000015A6  B7CA                     706          CMP.L   A2,A3                   Have all records been printed?
000015A8  66C2                     707          BNE     DUMP4                   Repeat until all done
000015AA  49FA 07D7                708          LEA.L   TAIL(PC),A4             Point to message tail (S9 record)
000015AE  6100 FBF2                709          BSR     PSTRING                 Print it
000015B2  2D5F 0116                710          MOVE.L  (A7)+,CN_OVEC(A6)   Restore name of output device
000015B6  4E75                     711          RTS                             and return
000015B8                           712   
000015B8  D200                     713  DUMP7   ADD.B   D0,D1                 Update checksum, transmit byte
000015BA  6000 FE18                714          BRA     OUT2X                   to host and return
000015BE                           715   
000015BE  =000015BE                716  RANGE   EQU     *                       Get the range of addresses to be
000015BE  4207                     717          CLR.B   D7                      transmitted from the buffer
000015C0  6100 FDB4                718          BSR     PARAM                 Get starting address
000015C4  2640                     719          MOVE.L  D0,A3                   Set up start address in A3
000015C6  6100 FDAE                720          BSR     PARAM                   Get end address
000015CA  2440                     721          MOVE.L  D0,A2                   Set up end address in A2
000015CC  4E75                     722          RTS
000015CE                           723   
000015CE  =000015CE                724  DELAY   EQU     *                       Provide a time delay for the host
000015CE  48E7 8008                725          MOVEM.L D0/A4,-(A7)             to settle. Save working registers
000015D2  203C 00004000            726          MOVE.L  #$4000,D0               Set up delay constant
000015D8  5380                     727  DELAY1  SUB.L   #1,D0                   Count down      (8 clk cycles)
000015DA  66FC                     728          BNE     DELAY1                  Repeat until zero  (10 clk cycles)
000015DC  4CDF 1001                729          MOVEM.L (A7)+,D0/A4             Restore working registers
000015E0                           730   *=============================================================================
000015E0                           731  *   This routine sets up the system DCBs in RAM using the information
000015E0                           732  *   stored in ROM at address DCB_LST. This is called at initialization.
000015E0                           733  *   CN_IVEC contains the name "DCB1" and IO_VEC the name "DCB2"
000015E0                           734   
000015E0  48E7 F0F0                735  SET_DCB MOVEM.L A0-A3/D0-D3,-(A7)   Save all working registers
000015E4  41EE 0194                736          LEA.L   FIRST(A6),A0            Pointer to first DCB destination in RAM
000015E8  43FA 0764                737          LEA.L   DCB_LST(PC),A1          A1 points to DCB info block in ROM
000015EC  303C 0001                738          MOVE.W  #1,D0                   2 DCBs to set up
000015F0  323C 000F                739  ST_DCB1 MOVE.W  #15,D1                  16 bytes to move per DCB header
000015F4  10D9                     740  ST_DCB2 MOVE.B  (A1)+,(A0)+             Move the 16 bytes of a DCB header
000015F6  51C9 FFFC                741          DBRA    D1,ST_DCB2              from ROM to RAM
000015FA  3619                     742          MOVE.W  (A1)+,D3                Get size of parameter block (bytes)
000015FC  3083                     743          MOVE.W  D3,(A0)                 Store size in DCB in RAM
000015FE  41F0 3002                744          LEA.L   2(A0,D3.W),A0           A0 points to tail of DCB in RAM
00001602  47E8 0004                745          LEA.L   4(A0),A3                A3 contains address of next DCB in RAM
00001606  208B                     746          MOVE.L  A3,(A0)                 Store pointer to next DCB in this DCB
00001608  41D3                     747          LEA.L   (A3),A0                 A0 now points at next DCB in RAM
0000160A  51C8 FFE4                748          DBRA    D0,ST_DCB1              Repeat until all DCBs set up
0000160E  47EB FFFC                749          LEA.L   -4(A3),A3               Adjust A3 to point to last DCB pointer
00001612  4293                     750          CLR.L   (A3)                    and force last pointer to zero
00001614  2D7C 00001D4E 0112       751          MOVE.L  #DCB1,CN_IVEC(A6)   Set up vector to console input DCB
0000161C  2D7C 00001D60 0116       752          MOVE.L  #DCB2,CN_OVEC(A6)   Set up vector to console output DCB
00001624  4CDF 0F0F                753          MOVEM.L (A7)+,A0-A3/D0-D3   Restore registers
00001628  4E75                     754          RTS
0000162A                           755   *=============================================================================
0000162A                           756  *   IO_REQ handles all input/output transactions. A0 points to DCB on
0000162A                           757  *   entry. IO_REQ calls the device driver whose address is in the DCB.
0000162A                           758   
0000162A  48E7 00C0                759  IO_REQ  MOVEM.L A0-A1,-(A7)     Save working registers
0000162E  43E8 0008                760          LEA.L   8(A0),A1        A1 points to device handler field in DCB
00001632  2251                     761          MOVE.L  (A1),A1         A1 contains device handler address
00001634  4E91                     762          JSR     (A1)            Call device handler
00001636  4CDF 0300                763          MOVEM.L (A7)+,A0-A1     Restore working registers
0000163A  4E75                     764          RTS
0000163C                           765   *=============================================================================
0000163C                           766  *   CON_IN handles input from the console device
0000163C                           767  *   This is the device driver used by DCB1. Exit with input in D0
0000163C                           768   
0000163C  48E7 4040                769  CON_IN  MOVEM.L D1/A1,-(A7)     Save working registers
00001640  43E8 000C                770          LEA.L   12(A0),A1       Get pointer to ACIA from DCB
00001644  2251                     771          MOVE.L  (A1),A1         Get address of ACIA in A1
00001646  4228 0013                772          CLR.B   19(A0)          Clear logical error in DCB
0000164A  1211                     773  CON_I1  MOVE.B  (A1),D1         Read ACIA status
0000164C  0801 0000                774          BTST    #0,D1           Test RDRF
00001650  67F8                     775          BEQ     CON_I1          Repeat until RDRF true
00001652  1141 0012                776          MOVE.B  D1,18(A0)       Store physical status in DCB
00001656  C23C 00F4                777          AND.B   #%011110100,D1  Mask to input error bits
0000165A  6706                     778          BEQ.S   CON_I2          If no error then skip update
0000165C  117C 0001 0013           779          MOVE.B  #1,19(A0)       Else update logical error
00001662  1029 0002                780  CON_I2  MOVE.B  2(A1),D0        Read input from ACIA
00001666  4CDF 0202                781          MOVEM.L (A7)+,A1/D1     Restore working registers
0000166A  4E75                     782          RTS
0000166C                           783   *=============================================================================
0000166C                           784  *   This is the device driver used by DCB2. Output in D0
0000166C                           785  *   The output can be halted or suspended
0000166C                           786   
0000166C  48E7 6040                787  CON_OUT MOVEM.L A1/D1-D2,-(A7)  Save working registers
00001670  43E8 000C                788          LEA.L   12(A0),A1       Get pointer to ACIA from DCB
00001674  2251                     789          MOVE.L  (A1),A1         Get address of ACIA in A1
00001676  4228 0013                790          CLR.B   19(A0)          Clear logical error in DCB
0000167A  1211                     791  CON_OT1 MOVE.B  (A1),D1         Read ACIA status
0000167C  0801 0000                792          BTST    #0,D1           Test RDRF bit (any input?)
00001680  6716                     793          BEQ.S   CON_OT3         If no input then test output status
00001682  1429 0002                794          MOVE.B  2(A1),D2        Else read the input
00001686  C43C 005F                795          AND.B   #%01011111,D2   Strip parity and bit 5
0000168A  B43C 0057                796          CMP.B   #WAIT,D2        and test for a wait condition
0000168E  6608                     797          BNE.S   CON_OT3         If not wait then ignore and test O/P
00001690  1411                     798  CON_OT2 MOVE.B  (A1),D2         Else read ACIA status register
00001692  0802 0000                799          BTST    #0,D2           and poll ACIA until next char received
00001696  67F8                     800          BEQ     CON_OT2
00001698  0801 0001                801  CON_OT3 BTST    #1,D1           Repeat
0000169C  67DC                     802          BEQ     CON_OT1         until ACIA Tx ready
0000169E  1141 0012                803          MOVE.B  D1,18(A0)       Store status in DCB physical error
000016A2  1340 0002                804          MOVE.B  D0,2(A1)        Transmit output
000016A6  4CDF 0206                805          MOVEM.L (A7)+,A1/D1-D2  Restore working registers
000016AA  4E75                     806          RTS
000016AC                           807   
000016AC                           808   *============================================================================
000016AC                           809  *   GETCHAR gets a character from the console device
000016AC                           810  *   This is the main input routine and uses the device whose name
000016AC                           811  *   is stored in CN_IVEC. Changing this name redirects input.
000016AC                           812   
000016AC  2F08                     813  GETCHAR MOVE.L  A0,-(A7)        Save working register
000016AE  206E 0112                814          MOVE.L  CN_IVEC(A6),A0  A0 points to name of console DCB
000016B2  6150                     815          BSR.S   IO_OPEN         Open console (get DCB address in A0)
000016B4  0807 0003                816          BTST    #3,D7           D7(3) set if open error
000016B8  6636                     817          BNE.S   GETCH3          If error then exit now
000016BA  6100 FF6E                818          BSR     IO_REQ          Else execute I/O transaction
000016BE  C03C 007F                819          AND.B   #$7F,D0         Strip msb of input
000016C2  4A2E 010C                820          TST.B   U_CASE(A6)      Test for upper -> lower case conversion
000016C6  660A                     821          BNE.S   GETCH2          If flag not zero do not convert case
000016C8  0800 0006                822          BTST    #6,D0           Test input for lower case
000016CC  6704                     823          BEQ.S   GETCH2          If upper case then skip conversion
000016CE  C03C 00DF                824          AND.B   #%11011111,D0   Else clear bit 5 for upper case conv
000016D2  4A2E 010A                825  GETCH2  TST.B   ECHO(A6)        Do we need to echo the input?
000016D6  6618                     826          BNE.S   GETCH3          If ECHO not zero then no echo
000016D8  4A2E 010B                827          TST.B   STAR(A6)        Test if echoing an * for a password
000016DC  6700 0010                828          BEQ     SKIP            Branch to standard echo if not a password
000016E0  3F00                     829          MOVE    D0,-(A7)        Save input char to stack
000016E2  103C 002A                830          MOVE.B  #42,D0          load an * char
000016E6  610C                     831          BSR.S   PUTCHAR         Echo the *
000016E8  301F                     832          MOVE    (A7)+,D0        Retrieve the input char from stack
000016EA  6000 0004                833          BRA     GETCH3          Goto exit
000016EE  6104                     834  SKIP    BSR.S   PUTCHAR         Else echo the input
000016F0  205F                     835  GETCH3  MOVE.L  (A7)+,A0        Restore working register
000016F2  4E75                     836          RTS                     and return
000016F4                           837   *=============================================================================
000016F4                           838  *   PUTCHAR sends a character to the console device
000016F4                           839  *   The name of the output device is in CN_OVEC.
000016F4                           840   
000016F4  2F08                     841  PUTCHAR MOVE.L  A0,-(A7)        Save working register
000016F6  206E 0116                842          MOVE.L  CN_OVEC(A6),A0  A0 points to name of console output
000016FA  6108                     843          BSR.S   IO_OPEN         Open console (Get address of DCB)
000016FC  6100 FF2C                844          BSR     IO_REQ          Perform output with DCB pointed at by A0
00001700  205F                     845          MOVE.L  (A7)+,A0        Restore working register
00001702  4E75                     846          RTS
00001704                           847   *=============================================================================
00001704                           848  *   Open - opens a DCB for input or output. IO_OPEN converts the
00001704                           849  *   name pointed at by A0 into the address of the DCB pointed at
00001704                           850  *   by A0. Bit 3 of D7 is set to zero if DCB not found
00001704                           851   
00001704  48E7 F870                852  IO_OPEN MOVEM.L A1-A3/D0-D4,-(A7)   Save working registers
00001708  43EE 0194                853          LEA.L   FIRST(A6),A1            A1 points to first DCB in chain in RAM
0000170C  45D1                     854  OPEN1   LEA.L   (A1),A2                 A2 = temp copy of pointer to DCB
0000170E  47D0                     855          LEA.L   (A0),A3                 A3 = temp copy of pointer to DCB name
00001710  303C 0007                856          MOVE.W  #7,D0               Up to 8 chars of DCB name to match
00001714  181A                     857  OPEN2   MOVE.B  (A2)+,D4                Compare DCB name with string
00001716  B81B                     858          CMP.B   (A3)+,D4
00001718  6608                     859          BNE.S   OPEN3                   If no match try next DCB
0000171A  51C8 FFF8                860          DBRA    D0,OPEN2                Else repeat until all chars matched
0000171E  41D1                     861          LEA.L   (A1),A0                 Success - move this DCB address to A0
00001720  6016                     862          BRA.S   OPEN4                   and return
00001722  =00001722                863  OPEN3   EQU     *                       Fail - calculate address of next DCB
00001722  3229 0010                864          MOVE.W  16(A1),D1               Get parameter block size of DCB
00001726  43F1 1012                865          LEA.L   18(A1,D1.W),A1          A1 points to pointer to next DCB
0000172A  2251                     866          MOVE.L  (A1),A1                 A1 now points to next DCB
0000172C  B3FC 00000000            867          CMP.L   #0,A1                   Test for end of DCB chain
00001732  66D8                     868          BNE     OPEN1                   If not end of chain then try next DCB
00001734  8E3C 0008                869          OR.B    #8,D7                   Else set error flag and return
00001738  4CDF 0E1F                870  OPEN4   MOVEM.L (A7)+,A1-A3/D0-D4   Restore working registers
0000173C  4E75                     871          RTS
0000173E                           872   *=============================================================================
0000173E                           873  *   This subroutine clears the breakpoint table in ram
0000173E                           874   
0000173E  303C 0007                875  CLR_BPT MOVE.W  #7,D0           Clear the breakpoint table
00001742  41EE 0164                876          LEA.L   BP_TAB(A6),A0   Point to table
00001746  4298                     877  LBPT    CLR.L   (A0)+           Clear an address entry
00001748  4258                     878          CLR.W   (A0)+           Clear the corresponding data
0000174A  51C8 FFFA                879          DBRA    D0,LBPT         Repeat until all 8 cleared
0000174E  4E75                     880          RTS
00001750                           881   *=============================================================================
00001750  =00001750                882  TRAP_0  EQU     *               User links to  MODWARE via TRAP #0
00001750  B23C 0000                883          CMP.B   #0,D1           D1 = 0 = Get character
00001754  6606                     884          BNE.S   FUNC1
00001756  6100 FF54                885          BSR     GETCHAR
0000175A  4E73                     886          RTE
0000175C  B23C 0001                887  FUNC1   CMP.B   #1,D1           D1 = 1 = Print character
00001760  6604                     888          BNE.S   FUNC2
00001762  6190                     889          BSR     PUTCHAR
00001764  4E73                     890          RTE
00001766  B23C 0002                891  FUNC2   CMP.B   #2,D1           D1 = 2 = Newline
0000176A  6606                     892          BNE.S   FUNC3
0000176C  6100 FA24                893          BSR     NEWLINE
00001770  4E73                     894          RTE
00001772  B23C 0003                895  FUNC3   CMP.B   #3,D1           D1 = 3 = Get parameter from buffer
00001776  6606                     896          BNE.S   FUNC4
00001778  6100 FBFC                897          BSR     PARAM
0000177C  4E73                     898          RTE
0000177E  B23C 0004                899  FUNC4   CMP.B   #4,D1           D1 = 4 = Print string pointed at by A4
00001782  6606                     900          BNE.S   FUNC5
00001784  6100 FA1C                901          BSR     PSTRING
00001788  4E73                     902          RTE
0000178A  B23C 0005                903  FUNC5   CMP.B   #5,D1           D1 = 5 = Get a hex character
0000178E  6606                     904          BNE.S   FUNC6
00001790  6100 FBAA                905          BSR     HEX
00001794  4E73                     906          RTE
00001796  B23C 0006                907  FUNC6   CMP.B   #6,D1           D1 = 6 = Get a hex byte
0000179A  6606                     908          BNE.S   FUNC7
0000179C  6100 FBBC                909          BSR     BYTE
000017A0  4E73                     910          RTE
000017A2  B23C 0007                911  FUNC7   CMP.B   #7,D1           D1 = 7 = Get a word
000017A6  6606                     912          BNE.S   FUNC8
000017A8  6100 FBC0                913          BSR     WORD
000017AC  4E73                     914          RTE
000017AE  B23C 0008                915  FUNC8   CMP.B   #8,D1           D1 = 8 = Get a longword
000017B2  6606                     916          BNE.S   FUNC9
000017B4  6100 FBBA                917          BSR     LONGWD
000017B8  4E73                     918          RTE
000017BA  B23C 0009                919  FUNC9   CMP.B   #9,D1           D1 = 9 = Output hex byte
000017BE  6606                     920          BNE.S   FUNC10
000017C0  6100 FC12                921          BSR     OUT2X
000017C4  4E73                     922          RTE
000017C6  B23C 000A                923  FUNC10  CMP.B   #10,D1          D1 = 10 = Output hex word
000017CA  6606                     924          BNE.S   FUNC11
000017CC  6100 FC0E                925          BSR     OUT4X
000017D0  4E73                     926          RTE
000017D2  B23C 000B                927  FUNC11  CMP.B   #11,D1          D1 = 11 = Output hex longword
000017D6  6606                     928          BNE.S   FUNC12
000017D8  6100 FC0A                929          BSR     OUT8X
000017DC  4E73                     930          RTE
000017DE  B23C 000C                931  FUNC12  CMP.B   #12,D1          D1 = 12 = Print a space
000017E2  6606                     932          BNE.S   FUNC13
000017E4  6100 FC6E                933          BSR     PSPACE
000017E8  4E73                     934          RTE
000017EA  B23C 000D                935  FUNC13  CMP.B   #13,D1          D1 = 13 = Get a line of text into
000017EE  6606                     936          BNE.S   FUNC14          the line buffer
000017F0  6100 F9C6                937          BSR     GETLINE
000017F4  4E73                     938          RTE
000017F6  B23C 000E                939  FUNC14  CMP.B   #14,D1          D1 = 14 = Tidy up the line in the
000017FA  6606                     940          BNE.S   FUNC15          line buffer by removing leading
000017FC  6100 FA90                941          BSR     TIDY            leading and multiple embedded spaces
00001800  4E73                     942          RTE
00001802  B23C 000F                943  FUNC15  CMP.B   #15,D1          D1 = 15 = Execute the command in
00001806  6606                     944          BNE.S   FUNC16          the line buffer
00001808  6100 FAC6                945          BSR     EXECUTE
0000180C  4E73                     946          RTE
0000180E  B23C 0010                947  FUNC16  CMP.B   #16,D1          D1 = 16 = Call RESTORE to transfer
00001812  6606                     948          BNE.S   FUNC17          the registers in TSK_T to the 68000
00001814  6100 017E                949          BSR     RESTORE         and therefore execute a program
00001818  4E73                     950          RTE
0000181A  4E73                     951  FUNC17  RTE
0000181C                           952   *=============================================================================
0000181C                           953  *   Display exception frame (D0 - D7, A0 - A6, USP, SSP, SR, PC)
0000181C                           954  *   EX_DIS prints registers saved after a breakpoint or exception
0000181C                           955  *   The registers are saved in TSK_T
0000181C                           956   
0000181C  4BEE 011A                957  EX_DIS  LEA.L   TSK_T(A6),A5    A5 points to display frame
00001820  49FA 0582                958          LEA.L   MES3(PC),A4     Point to heading
00001824  6100 F98C                959          BSR     HEADING         and print it
00001828  3C3C 0007                960          MOVE.W  #7,D6           8 pairs of registers to display
0000182C  4205                     961          CLR.B   D5              D5 is the line counter
0000182E  1005                     962  EX_D1   MOVE.B  D5,D0           Put current register number in D0
00001830  6100 FB88                963          BSR     OUT1X           and print it
00001834  6100 FC1E                964          BSR     PSPACE          and a space
00001838  5205                     965          ADD.B   #1,D5           Update counter for next pair
0000183A  2015                     966          MOVE.L  (A5),D0         Get data register to be displayed
0000183C  6100 FBA6                967          BSR     OUT8X           from the frame and print it
00001840  49FA 0580                968          LEA.L   MES4(PC),A4     Print string of spaces
00001844  6100 F95C                969          BSR.L   PSTRING         between data and address registers
00001848  202D 0020                970          MOVE.L  32(A5),D0       Get address register to be displayed
0000184C  6100 FB96                971          BSR     OUT8X           which is 32 bytes on from data reg
00001850  6100 F940                972          BSR     NEWLINE
00001854  4BED 0004                973          LEA.L   4(A5),A5        Point to next pair (ie Di, Ai)
00001858  51CE FFD4                974          DBRA    D6,EX_D1        Repeat until all displayed
0000185C  4BED 0020                975          LEA.L   32(A5),A5       Adjust pointer by 8 longwords
00001860  6100 F930                976          BSR     NEWLINE         to point to SSP
00001864  49FA 0535                977          LEA.L   MES2A(PC),A4    Point to "SS ="
00001868  6100 F938                978          BSR     PSTRING         Print it
0000186C  201D                     979          MOVE.L  (A5)+,D0        Get SSP from frame
0000186E  6100 FB74                980          BSR     OUT8X           and display it
00001872  6100 F91E                981          BSR     NEWLINE
00001876  49FA 0511                982          LEA.L   MES1(PC),A4     Point to 'SR ='
0000187A  6100 F926                983          BSR     PSTRING         Print it
0000187E  301D                     984          MOVE.W  (A5)+,D0        Get status register
00001880  6100 FB5A                985          BSR     OUT4X           Display status
00001884  6100 F90C                986          BSR     NEWLINE
00001888  49FA 0508                987          LEA.L   MES2(PC),A4     Point to 'PC ='
0000188C  6100 F914                988          BSR     PSTRING         Print it
00001890  201D                     989          MOVE.L  (A5)+,D0        Get PC
00001892  6100 FB50                990          BSR     OUT8X           Display PC
00001896  6000 F8FA                991          BRA     NEWLINE         Newline and return
0000189A                           992   *=============================================================================
0000189A                           993  *   Exception handling routines
0000189A                           994   
0000189A  =0000189A                995  IL_ER   EQU     *               Illegal instruction exception
0000189A  2F0C                     996          MOVE.L  A4,-(A7)        Save A4
0000189C  49FA 054B                997          LEA.L   MES10(PC),A4    Point to heading
000018A0  6100 F910                998          BSR     HEADING         Print it
000018A4  285F                     999          MOVE.L  (A7)+,A4        Restore A4
000018A6  4EB9 00001942           1000          JSR     GROUP2          Save registers in display frame
000018AC  6100 FF6E               1001          BSR     EX_DIS          Display registers saved in frame
000018B0  6000 0398               1002          BRA     _main           Return to monitor
000018B4                          1003  *
000018B4  =000018B4               1004  BUS_ER  EQU     *               Bus error (group 1) exception
000018B4  2F0C                    1005          MOVE.L  A4,-(A7)        Save A4
000018B6  49FA 0511               1006          LEA.L   MES8(PC),A4     Point to heading
000018BA  6100 F8F6               1007          BSR     HEADING         Print it
000018BE  285F                    1008          MOVE.L  (A7)+,A4        Restore A4
000018C0  6100 FF5A               1009          BSR     EX_DIS          Display registers saved in frame
000018C4  6000 0384               1010          BRA     _main           Return to monitor
000018C8                          1011  *
000018C8  =000018C8               1012  ADD_ER  EQU     *               Address error (group 1) exception
000018C8  2F0C                    1013          MOVE.L  A4,-(A7)        Save A4
000018CA  49FA 050B               1014          LEA.L   MES9(PC),A4     Point to heading
000018CE  6100 F8E2               1015          BSR     HEADING         Print it
000018D2  285F                    1016          MOVE.L  (A7)+,A4        Restore A4
000018D4  6100 FF46               1017          BSR     EX_DIS        Display registers saved in frame
000018D8  6000 0370               1018          BRA     _main           Return to monitor
000018DC                          1019  *
000018DC  =000018DC               1020  PRI_ER  EQU     *               Privilege violation error
000018DC  2F0C                    1021          MOVE.L  A4,-(A7)        Save A4
000018DE  49FA 0612               1022          LEA.L   ERMES8(PC),A4   Point to heading
000018E2  6100 F8CE               1023          BSR     HEADING         Print it
000018E6  285F                    1024          MOVE.L  (A7)+,A4        Restore A4
000018E8  6100 FF32               1025          BSR     EX_DIS          Display registers saved in frame
000018EC  6000 035C               1026          BRA     _main           Return to monitor
000018F0                          1027  *
000018F0  =000018F0               1028  BRKPT   EQU     *                       Deal with breakpoint
000018F0  48E7 FFFE               1029          MOVEM.L D0-D7/A0-A6,-(A7)   Save all registers
000018F4  6100 0180               1030          BSR     BR_CLR                  Clear breakpoints in code
000018F8  4CDF 7FFF               1031          MOVEM.L (A7)+,D0-D7/A0-A6   Restore registers
000018FC  6144                    1032          BSR.S   GROUP2                  Treat as group 2 exception
000018FE  49FA 04FF               1033          LEA.L   MES11(PC),A4            Point to heading
00001902  6100 F8AE               1034          BSR     HEADING                 Print it
00001906  6100 FF14               1035          BSR     EX_DIS                  Display saved registers
0000190A  6000 033E               1036          BRA     _main                   Return to monitor
0000190E                          1037   *=============================================================================
0000190E                          1038  *   GROUP1 is called by address and bus error exceptions
0000190E                          1039  *   These are "turned into group 2" exceptions (eg TRAP)
0000190E                          1040  *   by modifying the stack frame saved by a group 1 exception
0000190E                          1041   
0000190E  48E7 8080               1042  GROUP1  MOVEM.L D0/A0,-(A7)             Save working registers
00001912  206F 0012               1043          MOVE.L  18(A7),A0           Get PC from group 1 stack frame
00001916  302F 000E               1044          MOVE.W  14(A7),D0               Get instruction from stack frame
0000191A  B060                    1045          CMP.W   -(A0),D0                Now backtrack to find the "correct PC"
0000191C  670E                    1046          BEQ.S   GROUP1A                 by matching the op-code on the stack
0000191E  B060                    1047          CMP.W   -(A0),D0                with the code in the region of the
00001920  670A                    1048          BEQ.S   GROUP1A                 PC on the stack
00001922  B060                    1049          CMP.W   -(A0),D0
00001924  6706                    1050          BEQ.S   GROUP1A
00001926  B060                    1051          CMP.W   -(A0),D0
00001928  6702                    1052          BEQ.S   GROUP1A
0000192A  5588                    1053          SUBQ.L  #2,A0
0000192C  2F48 0012               1054  GROUP1A MOVE.L  A0,18(A7)               Restore modified PC to stack frame
00001930  4CDF 0101               1055          MOVEM.L (A7)+,D0/A0         Restore working registers
00001934  4FEF 0008               1056          LEA.L   8(A7),A7                Adjust stack pointer to group 1 type
00001938  6108                    1057          BSR.S   GROUP2                  Now treat as group 1 exception
0000193A  6100 FEE0               1058          BSR     EX_DIS                  Display contents of exception frame
0000193E  6000 030A               1059          BRA     _main                   Exit to monitor - no RTE from group 2
00001942                          1060  *
00001942  =00001942               1061  GROUP2  EQU     *                       Deal with group 2 exceptions
00001942  48E7 FFFF               1062          MOVEM.L A0-A7/D0-D7,-(A7)   Save all registers on the stack
00001946  303C 000E               1063          MOVE.W  #14,D0                  Transfer D0 - D7, A0 - A6 from
0000194A  41EE 011A               1064          LEA.L   TSK_T(A6),A0            the stack to the display frame
0000194E  20DF                    1065  GROUP2A MOVE.L  (A7)+,(A0)+             Move a register from stack to frame
00001950  51C8 FFFC               1066          DBRA    D0,GROUP2A              and repeat until D0-D7/A0-A6 moved
00001954  4E6A                    1067          MOVE.L  USP,A2                  Get the user stack pointer and put it
00001956  20CA                    1068          MOVE.L  A2,(A0)+                in the A7 position in the frame
00001958  201F                    1069          MOVE.L  (A7)+,D0                Now transfer the SSP to the frame,
0000195A  0480 0000000A           1070          SUB.L   #10,D0                  remembering to account for the
00001960  20C0                    1071          MOVE.L  D0,(A0)+                data pushed on the stack to this point
00001962  225F                    1072          MOVE.L  (A7)+,A1                Copy TOS (return address) to A1
00001964  30DF                    1073          MOVE.W  (A7)+,(A0)+             Move SR to display frame
00001966  201F                    1074          MOVE.L  (A7)+,D0                Get PC in D0
00001968  5580                    1075          SUBQ.L  #2,D0                   Move back to current instruction
0000196A  20C0                    1076          MOVE.L  D0,(A0)+                Put adjusted PC in display frame
0000196C  4ED1                    1077          JMP     (A1)                    Return from subroutine
0000196E                          1078   *=============================================================================
0000196E                          1079  *   GO executes a program either from a supplied address or
0000196E                          1080  *   by using the data in the display frame
0000196E                          1081  _GO
0000196E  6100 FA06               1082  GO      BSR     PARAM                   Get entry address (if any)
00001972  4A07                    1083          TST.B   D7                      Test for error in input
00001974  6708                    1084          BEQ.S   GO1                     If D7 zero then OK
00001976  49FA 04ED               1085          LEA.L   ERMES1(PC),A4           Else point to error message,
0000197A  6000 F826               1086          BRA     PSTRING                 print it and return
0000197E  4A80                    1087  GO1     TST.L   D0                      If no address entered then get
00001980  670A                    1088          BEQ.S   GO2                     address from display frame
00001982  2D40 0160               1089          MOVE.L  D0,TSK_T+70(A6)         Else save address in display frame
00001986  3D7C 0700 015E          1090          MOVE.W  #$0700,TSK_T+68(A6) Store dummy status in frame
0000198C  6006                    1091  GO2     BRA.S   RESTORE                 Restore volatile environment and go
0000198E                          1092  *
0000198E  6100 007A               1093  GB      BSR     BR_SET                  Same as go but presets breakpoints
00001992  60DA                    1094          BRA.S   GO                      Execute program
00001994                          1095   *=============================================================================
00001994                          1096  *   RESTORE moves the volatile environment from the display
00001994                          1097  *   frame and transfers it to the 68000's registers. This
00001994                          1098  *   re-runs a program suspended after an exception
00001994                          1099   
00001994  47EE 011A               1100  RESTORE LEA.L   TSK_T(A6),A3    A3 points to display frame
00001998  47EB 004A               1101          LEA.L   74(A3),A3       A3 now points to end of frame + 4
0000199C  4FEF 0004               1102          LEA.L   4(A7),A7        Remove return address from stack
000019A0  303C 0024               1103          MOVE.W  #36,D0          Counter for 37 words to be moved
000019A4  3F23                    1104  REST1   MOVE.W  -(A3),-(A7)     Move word from display frame to stack
000019A6  51C8 FFFC               1105          DBRA    D0,REST1        Repeat until entire frame moved
000019AA  4CDF 00FF               1106          MOVEM.L (A7)+,D0-D7     Restore old data registers from stack
000019AE  4CDF 7F00               1107          MOVEM.L (A7)+,A0-A6     Restore old address registers
000019B2  4FEF 0008               1108          LEA.L   8(A7),A7        Except SSP/USP - so adjust stack
000019B6  4E73                    1109          RTE                     Return from exception to run program
000019B8                          1110  *
000019B8  =000019B8               1111  TRACE   EQU     *               TRACE exception (rudimentary version)
000019B8  287A 0453               1112          MOVE.L  MES12(PC),A4    Point to heading
000019BC  6100 F7F4               1113          BSR     HEADING         Print it
000019C0  6100 FF4C               1114          BSR     GROUP1          Save volatile environment
000019C4  6100 FE56               1115          BSR     EX_DIS          Display it
000019C8  6000 0280               1116          BRA     _main           Return to monitor
000019CC                          1117   *=============================================================================
000019CC                          1118  *   Breakpoint routines: BR_GET gets the address of a breakpoint and
000019CC                          1119  *   puts it in the breakpoint table. It does not plant it in the code.
000019CC                          1120  *   BR_SET plants all breakpoints in the code. NOBR removes one or all
000019CC                          1121  *   breakpoints from the table. KILL removes breakpoints from the code.
000019CC                          1122   
000019CC  6100 F9A8               1123  BR_GET  BSR     PARAM           Get breakpoint address in table
000019D0  4A07                    1124          TST.B   D7              Test for input error
000019D2  6708                    1125          BEQ.S   BR_GET1         If no error then continue
000019D4  49FA 048F               1126          LEA.L   ERMES1(PC),A4   Else display error
000019D8  6000 F7C8               1127          BRA     PSTRING         and return
000019DC  47EE 0164               1128  BR_GET1 LEA.L   BP_TAB(A6),A3   A6 points to breakpoint table
000019E0  2A40                    1129          MOVE.L  D0,A5           Save new BP address in A5
000019E2  2C00                    1130          MOVE.L  D0,D6           and in D6 because D0 gets corrupted
000019E4  3A3C 0007               1131          MOVE.W  #7,D5           Eight entries to test
000019E8  201B                    1132  BR_GET2 MOVE.L  (A3)+,D0        Read entry from breakpoint table
000019EA  660C                    1133          BNE.S   BR_GET3         If not zero display existing BP
000019EC  4A86                    1134          TST.L   D6              Only store a non-zero breakpoint
000019EE  6710                    1135          BEQ.S   BR_GET4
000019F0  274D FFFC               1136          MOVE.L  A5,-4(A3)       Store new breakpoint in table
000019F4  3695                    1137          MOVE.W  (A5),(A3)       Save code at BP address in table
000019F6  4286                    1138          CLR.L   D6              Clear D6 to avoid repetition
000019F8  6100 F9EA               1139  BR_GET3 BSR     OUT8X           Display this breakpoint
000019FC  6100 F794               1140          BSR     NEWLINE
00001A00  47EB 0002               1141  BR_GET4 LEA.L   2(A3),A3        Step past stored op-code
00001A04  51CD FFE2               1142          DBRA    D5,BR_GET2      Repeat until all entries tested
00001A08  4E75                    1143          RTS                     Return
00001A0A                          1144  *
00001A0A  =00001A0A               1145  BR_SET  EQU     *               Plant any breakpoints in user code
00001A0A  41EE 0164               1146          LEA.L   BP_TAB(A6),A0   A0 points to BP table
00001A0E  45EE 0160               1147          LEA.L   TSK_T+70(A6),A2 A2 points to PC in display frame
00001A12  2452                    1148          MOVE.L  (A2),A2         Now A2 contains value of PC
00001A14  303C 0007               1149          MOVE.W  #7,D0           Up to eight entries to plant
00001A18  2218                    1150  BR_SET1 MOVE.L  (A0)+,D1        Read breakpoint address from table
00001A1A  670A                    1151          BEQ.S   BR_SET2         If zero then skip planting
00001A1C  B28A                    1152          CMP.L   A2,D1           Don't want to plant BP at current PC
00001A1E  6706                    1153          BEQ.S   BR_SET2         location, so skip planting if same
00001A20  2241                    1154          MOVE.L  D1,A1           Transfer BP address to address reg
00001A22  32BC 4E4E               1155          MOVE.W  #TRAP_14,(A1)   Plant op-code for TRAP #14 in code
00001A26  41E8 0002               1156  BR_SET2 LEA.L   2(A0),A0        Skip past op-code field in table
00001A2A  51C8 FFEC               1157          DBRA    D0,BR_SET1      Repeat until all entries tested
00001A2E  4E75                    1158          RTS
00001A30                          1159  *
00001A30  =00001A30               1160  NOBR    EQU     *               Clear one or all breakpoints
00001A30  6100 F944               1161          BSR     PARAM           Get BP address (if any)
00001A34  4A07                    1162          TST.B   D7              Test for input error
00001A36  6708                    1163          BEQ.S   NOBR1           If no error then skip abort
00001A38  49FA 042B               1164          LEA.L   ERMES1(PC),A4   Point to error message
00001A3C  6000 F764               1165          BRA     PSTRING         Display it and return
00001A40  4A80                    1166  NOBR1   TST.L   D0              Test for null address (clear all)
00001A42  6720                    1167          BEQ.S   NOBR4           If no address then clear all entries
00001A44  2240                    1168          MOVE.L  D0,A1           Else just clear breakpoint in A1
00001A46  41EE 0164               1169          LEA.L   BP_TAB(A6),A0   A0 points to BP table
00001A4A  303C 0007               1170          MOVE.W  #7,D0           Up to eight entries to test
00001A4E  2218                    1171  NOBR2   MOVE.L  (A0)+,D1        Get entry and
00001A50  41E8 0002               1172          LEA.L   2(A0),A0        skip past op-code field
00001A54  B289                    1173          CMP.L   A1,D1           Is this the one?
00001A56  6706                    1174          BEQ.S   NOBR3          If so go and clear entry
00001A58  51C8 FFF4               1175          DBRA    D0,NOBR2        Repeat until all tested
00001A5C  4E75                    1176          RTS
00001A5E  42A8 FFFA               1177  NOBR3   CLR.L   -6(A0)          Clear address in BP table
00001A62  4E75                    1178          RTS
00001A64  41EE 0164               1179  NOBR4   LEA.L   BP_TAB(A6),A0   Clear all 8 entries in BP table
00001A68  303C 0007               1180          MOVE.W  #7,D0           Eight entries to clear
00001A6C  4298                    1181  NOBR5   CLR.L   (A0)+           Clear breakpoint address
00001A6E  4258                    1182          CLR.W   (A0)+           Clear op-code field
00001A70  51C8 FFFA               1183          DBRA    D0,NOBR5        Repeat until all done
00001A74  4E75                    1184          RTS
00001A76                          1185  *
00001A76  =00001A76               1186  BR_CLR  EQU     *               Remove breakpoints from code
00001A76  41EE 0164               1187          LEA.L   BP_TAB(A6),A0   A0 points to breakpoint table
00001A7A  303C 0007               1188          MOVE.W  #7,D0           Up to eight entries to clear
00001A7E  2218                    1189  BR_CLR1 MOVE.L  (A0)+,D1        Get address of BP in D1
00001A80  2241                    1190          MOVE.L  D1,A1           and put copy in A1
00001A82  4A81                    1191          TST.L   D1              Test this breakpoint
00001A84  6702                    1192          BEQ.S   BR_CLR2         If zero then skip BP clearing
00001A86  3290                    1193          MOVE.W  (A0),(A1)       Else restore op-code
00001A88  41E8 0002               1194  BR_CLR2 LEA.L   2(A0),A0        Skip past op-code field
00001A8C  51C8 FFF0               1195          DBRA    D0,BR_CLR1      Repeat until all tested
00001A90  4E75                    1196          RTS
00001A92                          1197   *=============================================================================
00001A92                          1198  *   REG_MOD modifies a register in the display frame. The command
00001A92                          1199  *   format is REG <reg> <value>. E.g. REG D3 1200
00001A92                          1200   
00001A92  4281                    1201  REG_MOD CLR.L   D1              D1 to hold name of register
00001A94  41EE 0102               1202          LEA.L   BUFFPT(A6),A0   A0 contains address of buffer pointer
00001A98  2050                    1203          MOVE.L  (A0),A0         A0 now points to next char in buffer
00001A9A  1218                    1204          MOVE.B  (A0)+,D1        Put first char of name in D1
00001A9C  E159                    1205          ROL.W   #8,D1            Move char one place left
00001A9E  1218                    1206          MOVE.B  (A0)+,D1        Get second char in D1
00001AA0  41E8 0001               1207          LEA.L   1(A0),A0        Move pointer past space in buffer
00001AA4  2D48 0102               1208          MOVE.L  A0,BUFFPT(A6)   Update buffer pointer
00001AA8  4282                    1209          CLR.L   D2              D2 is the character pair counter
00001AAA  41FA 0390               1210          LEA.L   REGNAME(PC),A0  A0 points to string of character pairs
00001AAE  43D0                    1211          LEA.L   (A0),A1         A1 also points to string
00001AB0  B258                    1212  REG_MD1 CMP.W   (A0)+,D1        Compare a char pair with input
00001AB2  6712                    1213          BEQ.S   REG_MD2         If match then exit loop
00001AB4  5282                    1214          ADD.L   #1,D2           Else increment match counter
00001AB6  B4BC 00000013           1215          CMP.L   #19,D2          Test for end of loop
00001ABC  66F2                    1216          BNE     REG_MD1         Continue until all pairs matched
00001ABE  49FA 03A5               1217          LEA.L   ERMES1(PC),A4   If here then error
00001AC2  6000 F6DE               1218          BRA     PSTRING         Display error and return
00001AC6  43EE 011A               1219  REG_MD2 LEA.L   TSK_T(A6),A1    A1 points to display frame
00001ACA  E582                    1220          ASL.L   #2,D2           Multiply offset by 4 (4 bytes/entry)
00001ACC  B4BC 00000048           1221          CMP.L   #72,D2          Test for address of PC
00001AD2  6602                    1222          BNE.S   REG_MD3         If not PC then all is OK
00001AD4  5582                    1223          SUB.L   #2,D2           else dec PC pointer as Sr is a word
00001AD6  45F1 2000               1224  REG_MD3 LEA.L   (A1,D2),A2      Calculate address of entry in disptable
00001ADA  2012                    1225          MOVE.L  (A2),D0         Get old contents
00001ADC  6100 F906               1226          BSR     OUT8X           Display them
00001AE0  6100 F6B0               1227           BSR     NEWLINE
00001AE4  6100 F890               1228          BSR     PARAM           Get new data
00001AE8  4A07                    1229          TST.B   D7              Test for input error
00001AEA  6708                    1230          BEQ.S   REG_MD4         If no error then go and store data
00001AEC  49FA 0377               1231          LEA.L   ERMES1(PC),A4   Else point to error message
00001AF0  6000 F6B0               1232          BRA     PSTRING         print it and return
00001AF4  B4BC 00000044           1233  REG_MD4 CMP.L   #68,D2          If this address is the SR then
00001AFA  6704                    1234          BEQ.S   REG_MD5         we have only a word to store
00001AFC  2480                    1235          MOVE.L  D0,(A2)         Else store new data in display frame
00001AFE  4E75                    1236          RTS
00001B00  3480                    1237  REG_MD5 MOVE.W  D0,(A2)         Store SR (one word)
00001B02  4E75                    1238          RTS
00001B04                          1239   *=============================================================================
00001B04  =00001B04               1240  X_UN    EQU     *               Uninitialized exception vector routine
00001B04  49FA 03C5               1241          LEA.L   ERMES6(PC),A4   Point to error message
00001B08  6100 F698               1242          BSR     PSTRING         Display it
00001B0C  6100 FD0E               1243          BSR     EX_DIS          Display registers
00001B10  6000 0138               1244           BRA     _main          Abort
00001B14                          1245   *=============================================================================
00001B14                          1246  *   LOGON subroutine is called upon RESET
00001B14                          1247  *   If successful, returns with no effect
00001B14                          1248  *   Upon failure, RESETs
00001B14                          1249  _LOGON
00001B14  =00001B14               1250  LOGON   EQU     *
00001B14  48E7 E018               1251          MOVEM.L D0-D2/A3-A4,-(A7)   Save registers to stack
00001B18  4280                    1252          CLR.L   D0              Clear attempt count
00001B1A                          1253  *       CLR.L   STAR(A6)        Clear STAR ECHO
00001B1A  7000                    1254          MOVE.L  #0, D0
00001B1C  4282                    1255  LOG1    CLR.L   D2              Clear user match
00001B1E  4287                    1256          CLR.L   D7              Clear error flag
00001B20  B0BC 00000003           1257          CMP.L   #3,D0           if too many attempts
00001B26  6700 004A               1258          BEQ     LOGF                    goto failure
00001B2A  6100 F666               1259          BSR     NEWLINE
00001B2E  49FA 06A2               1260          LEA.L   LOGM(PC),A4
00001B32  6100 F66E               1261          BSR     PSTRING
00001B36  6100 F680               1262          BSR     GETLINE
00001B3A  6100 F752               1263          BSR     TIDY
00001B3E  47FA 069F               1264          LEA.L   USERNA(PC),A3   Load username into A3
00001B42  6100 003E               1265          BSR     LSCH            Sets D1 if we have match
00001B46  2401                    1266          MOVE.L  D1,D2           Save user match in D2
00001B48  4287                    1267          CLR.L   D7              Clear error flag
00001B4A  6100 F646               1268          BSR     NEWLINE
00001B4E                          1269  *       MOVE.L  #1,STAR(A6)     Set STAR ECHO
00001B4E  49FA 0698               1270          LEA.L   PASSM(PC),A4
00001B52  6100 F64E               1271          BSR     PSTRING
00001B56  6100 F696               1272          BSR     GETPASS
00001B5A                          1273  *       CLR.L   STAR(A6)        Clear STAR ECHO
00001B5A  47FA 0697               1274          LEA.L   PASS(PC),A3     Load password into A3
00001B5E  6100 0022               1275          BSR     LSCH            Sets D1 if we have a match
00001B62  D282                    1276          ADD.L   D2,D1           Add two match flags together
00001B64  B2BC 00000002           1277          CMP.L   #2,D1           If both are set
00001B6A  6700 0010               1278          BEQ     LOGS            Success
00001B6E  5280                    1279          ADD.L   #1,D0           Else increment attempt count
00001B70  60AA                    1280          BRA     LOG1            And loop
00001B72  49FA 0686               1281  LOGF    LEA.L   LOGINERROR(PC),A4
00001B76  6100 F62A               1282          BSR     PSTRING
00001B7A  4E70                    1283          RESET                   Reset on login failure
00001B7C  4CDF 1807               1284  LOGS    MOVEM.L (A7)+,D0-D2/A3-A4   Restore registers from stack
00001B80  4E75                    1285          RTS                     Return on success
00001B82                          1286   
00001B82                          1287   *============================================================================
00001B82                          1288  *   LOGON helper subroutine
00001B82                          1289  *   INPUT:  A3 = start address of string to compare against
00001B82                          1290  *   OUTPUT: D1 = 1 if strings match, 0 otherwise
00001B82                          1291  _LSCH
00001B82  48E7 8008               1292  LSCH    MOVEM.L D0/A4,-(A7)     Save registers to stack
00001B86  49EE 00C1               1293          LEA.L   LNBUFF(A6),A4   Load line buffer into A4
00001B8A  4281                    1294          CLR.L   D1              Preemptively clear user match
00001B8C  101B                    1295  LSCH0   MOVE.B  (A3)+,D0        Get character of username
00001B8E  4A40                    1296          TST     D0              Test for null
00001B90  6700 000A               1297          BEQ     LSCHS           Success on NULL
00001B94  B01C                    1298          CMP.B   (A4)+,D0        Compare with input char
00001B96  6600 0006               1299          BNE     LSCHF           Fail on mismatch
00001B9A  60F0                    1300          BRA     LSCH0           Loop
00001B9C  7201                    1301  LSCHS   MOVE.L  #1,D1           Set user match
00001B9E  4CDF 1001               1302  LSCHF   MOVEM.L (A7)+,D0/A4     Restore registers from stack
00001BA2  4E75                    1303          RTS
00001BA4                          1304   *=============================================================================
00001BA4                          1305  *   HELP prints a description of each command in COMTAB
00001BA4                          1306  _HELP
00001BA4  =00001BA4               1307  HELP    EQU     *
00001BA4  6100 F5EC               1308          BSR     NEWLINE
00001BA8  49FA 035E               1309          LEA.L   HEJU(PC),A4
00001BAC  6100 F5F4               1310          BSR     PSTRING
00001BB0  6100 F5E0               1311          BSR     NEWLINE
00001BB4  49FA 038B               1312          LEA.L   HEME(PC),A4
00001BB8  6100 F5E8               1313          BSR     PSTRING
00001BBC  6100 F5D4               1314          BSR     NEWLINE
00001BC0  49FA 03B2               1315          LEA.L   HELO(PC),A4
00001BC4  6100 F5DC               1316          BSR     PSTRING
00001BC8  6100 F5C8               1317          BSR     NEWLINE
00001BCC  49FA 03D9               1318          LEA.L   HEDU(PC),A4
00001BD0  6100 F5D0               1319          BSR     PSTRING
00001BD4  6100 F5BC               1320          BSR     NEWLINE
00001BD8  49FA 040E               1321          LEA.L   HENO(PC),A4
00001BDC  6100 F5C4               1322          BSR     PSTRING
00001BE0  6100 F5B0               1323          BSR     NEWLINE
00001BE4  49FA 0444               1324          LEA.L   HEDI(PC),A4
00001BE8  6100 F5B8               1325          BSR     PSTRING
00001BEC  6100 F5A4               1326          BSR     NEWLINE
00001BF0  49FA 0477               1327          LEA.L   HEGO(PC),A4
00001BF4  6100 F5AC               1328          BSR     PSTRING
00001BF8  6100 F598               1329          BSR     NEWLINE
00001BFC  49FA 04A1               1330          LEA.L   HEBR(PC),A4
00001C00  6100 F5A0               1331          BSR     PSTRING
00001C04  6100 F58C               1332          BSR     NEWLINE
00001C08  49FA 04D5               1333          LEA.L   HEPL(PC),A4
00001C0C  6100 F594               1334          BSR     PSTRING
00001C10  6100 F580               1335          BSR     NEWLINE
00001C14  49FA 04F2               1336          LEA.L   HEKI(PC),A4
00001C18  6100 F588               1337          BSR     PSTRING
00001C1C  6100 F574               1338          BSR     NEWLINE
00001C20  49FA 0510               1339          LEA.L   HEGB(PC),A4
00001C24  6100 F57C               1340          BSR     PSTRING
00001C28  6100 F568               1341          BSR     NEWLINE
00001C2C  49FA 0537               1342          LEA.L   HERE(PC),A4
00001C30  6100 F570               1343          BSR     PSTRING
00001C34  6000 0014               1344          BRA     _main
00001C38                          1345         
00001C38                          1346  *===========================================================================
00001C38                          1347  *       MAIN FUNCTION
00001C38                          1348   
00001C38                          1349  _mainstart:
00001C38                          1350  ; //test();
00001C38                          1351  ; LOGON();
00001C38  4EB8 1B14               1352         jsr      _LOGON
00001C3C                          1353  ; //logon();
00001C3C                          1354  ; banner();
00001C3C  4EB9 00001C5C           1355         jsr      _banner
00001C42                          1356  ; command();
00001C42  4EB9 00001C4A           1357         jsr      _command
00001C48  4E75                    1358         rts
00001C4A                          1359  ; }
00001C4A                          1360  ; void command(){
00001C4A                          1361  _main
00001C4A                          1362  _command:
00001C4A                          1363  ; while(1){
00001C4A                          1364  command_1:
00001C4A                          1365  ; GETLINE();
00001C4A  4EB8 1192               1366         jsr      _NEWLINE
00001C4E  4EB8 11B8               1367         jsr      _GETLINE
00001C52                          1368  ; TIDY();
00001C52  4EB8 128E               1369         jsr      _TIDY
00001C56                          1370  ; EXECUTE();
00001C56  4EB8 12D0               1371         jsr      _EXECUTE
00001C5A                          1372             ;jsr          _NEWLINE
00001C5A  60EE                    1373         bra      command_1
00001C5C                          1374  ; }
00001C5C                          1375  ; }
00001C5C                          1376  ; /*void logon(){
00001C5C                          1377  ; /*char* userName = "STUDENT";
00001C5C                          1378  ; char* pass = "CECS525";
00001C5C                          1379  ; sendmsg(&USERMSG);            //get user name
00001C5C                          1380  ; while(buffer != 13){
00001C5C                          1381  ; *buffer = getchar();
00001C5C                          1382  ; sendchar(*buffer);
00001C5C                          1383  ; buffer = buffer + 1;
00001C5C                          1384  ; }
00001C5C                          1385  ; //check user name
00001C5C                          1386  ; while(*buffer != 0){
00001C5C                          1387  ; if(*buffer != *userName){
00001C5C                          1388  ; break;
00001C5C                          1389  ; }
00001C5C                          1390  ; else{
00001C5C                          1391  ; buffer = buffer + 1;
00001C5C                          1392  ; userName = userName + 1;
00001C5C                          1393  ; }
00001C5C                          1394  ; }
00001C5C                          1395  ; }
00001C5C                          1396  ; void debug(){
00001C5C                          1397  ; _A4 = DEBUG;
00001C5C                          1398  ; PSTRING();
00001C5C                          1399  ; NEWLINE();
00001C5C                          1400  ; sendchar('*');
00001C5C                          1401  ; GETLINE();
00001C5C                          1402  ; _A4 = _A0;
00001C5C                          1403  ; PSTRING();
00001C5C                          1404  ; NEWLINE();
00001C5C                          1405  ; _A4 = _A1;
00001C5C                          1406  ; PSTRING();
00001C5C                          1407  ; NEWLINE();
00001C5C                          1408  ; _A4 = DEBUGEND;
00001C5C                          1409  ; PSTRING();
00001C5C                          1410  ; NEWLINE();
00001C5C                          1411  ; }*/
00001C5C                          1412  ; void banner(){
00001C5C                          1413  _banner:
00001C5C  48E7 0030               1414         movem.l   A2/A3,-(A7)
00001C60  45F9 00001192           1415         lea      _NEWLINE.L,A2
00001C66  47F9 000011A2           1416         lea      _PSTRING.L,A3
00001C6C                          1417  ; _A4 = BANNER;
00001C6C  41F9 00002222           1418         lea      tinywa1_1.L,A0
00001C72  2848                    1419         move.l   A0,A4
00001C74                          1420  ; PSTRING();
00001C74  4E93                    1421         jsr      (A3)
00001C76                          1422  ; NEWLINE();
00001C76  4E92                    1423         jsr      (A2)
00001C78                          1424  ; _A4 = MODIFY;
00001C78  41F9 0000223B           1425         lea      tinywa1_2.L,A0
00001C7E  2848                    1426         move.l   A0,A4
00001C80                          1427  ; PSTRING();
00001C80  4E93                    1428         jsr      (A3)
00001C82                          1429  ; NEWLINE();
00001C82  4E92                    1430         jsr      (A2)
00001C84                          1431  ; _A4 = MODIFY2;
00001C84  41F9 00002268           1432         lea      tinywa1_3.L,A0
00001C8A  2848                    1433         move.l   A0,A4
00001C8C                          1434  ; PSTRING();
00001C8C  4E93                    1435         jsr      (A3)
00001C8E                          1436  ; NEWLINE();
00001C8E  4E92                    1437         jsr      (A2)
00001C90                          1438  ; _A4 = WHY;
00001C90  41F9 00002280           1439         lea      tinywa1_4.L,A0
00001C96  2848                    1440         move.l   A0,A4
00001C98                          1441  ; PSTRING();
00001C98  4E93                    1442         jsr      (A3)
00001C9A                          1443  ; NEWLINE();
00001C9A  4E92                    1444         jsr      (A2)
00001C9C                          1445  ; _A4 = WHERE;
00001C9C  41F9 000022B7           1446         lea      tinywa1_5.L,A0
00001CA2  2848                    1447         move.l   A0,A4
00001CA4                          1448  ; PSTRING();
00001CA4  4E93                    1449         jsr      (A3)
00001CA6                          1450  ; NEWLINE();
00001CA6  4E92                    1451         jsr      (A2)
00001CA8                          1452  ; _A4 = ADDRE;
00001CA8  41F9 000022D0           1453         lea      tinywa1_6.L,A0
00001CAE  2848                    1454         move.l   A0,A4
00001CB0                          1455  ; PSTRING();
00001CB0  4E93                    1456         jsr      (A3)
00001CB2                          1457  ; NEWLINE();
00001CB2  4E92                    1458         jsr      (A2)
00001CB4  4CDF 0C00               1459         movem.l   (A7)+,A2/A3
00001CB8  4E75                    1460         rts
00001CBA                          1461  ; }
00001CBA                          1462   *=============================================================================
00001CBA                          1463  *   COMTAB  is the built-in command table. All entries are made up of
00001CBA                          1464  *               a string length + number of characters to match + the string
00001CBA                          1465  *           plus the address of the command relative to COMTAB
00001CBA                          1466   
00001CBA= 04 04                   1467  COMTAB  DC.B    4,4             HELP lists commands with discriptions
00001CBC= 48 45 4C 50             1468             DC.B    'HELP'
00001CC0= FFFFFEEA                1469          DC.L    HELP-COMTAB
00001CC4= 04 04                   1470          DC.B    4,4             JUMP <address> causes execution to
00001CC6= 4A 55 4D 50             1471          DC.B    'JUMP'          begin at <address>
00001CCA= FFFFF732                1472          DC.L    JUMP-COMTAB
00001CCE= 08 03                   1473          DC.B    8,3             MEMORY <address> examines contents of
00001CD0= 4D 45 4D 4F 52 59 ...   1474          DC.B    'MEMORY  '      <address> and allows them to be changed
00001CD8= FFFFF748                1475          DC.L    MEMORY-COMTAB
00001CDC= 04 02                   1476          DC.B    4,2             LOAD <string> loads S1/S2 records
00001CDE= 4C 4F 41 44             1477          DC.B    'LOAD'          from the host. <string> is sent to host
00001CE2= FFFFF7A8                1478          DC.L    LOAD-COMTAB
00001CE6= 04 02                   1479          DC.B    4,2             DUMP <string> sends S1 records to the
00001CE8= 44 55 4D 50             1480          DC.B    'DUMP'          host and is preceeded by <string>.
00001CEC= FFFFF86C                1481          DC.L    DUMP-COMTAB
00001CF0= 04 02                   1482          DC.B    4,2             NOBR <address> removes the breakpoint
00001CF2= 4E 4F 42 52             1483          DC.B    'NOBR'          at <address> from the BP table. If
00001CF6= FFFFFD76                1484          DC.L    NOBR-COMTAB     no address is given all BPs are removed.
00001CFA= 04 02                   1485          DC.B    4,2             DISP displays the contents of the
00001CFC= 44 49 53 50             1486          DC.B    'DISP'          pseudo registers in TSK_T.
00001D00= FFFFFB62                1487          DC.L    EX_DIS-COMTAB
00001D04= 04 02                   1488          DC.B    4,2             GO <address> starts program execution
00001D06= 47 4F 20 20             1489          DC.B    'GO  '          at <address> and loads regs from TSK_T
00001D0A= FFFFFCB4                1490          DC.L    GO-COMTAB
00001D0E= 04 02                   1491          DC.B    4,2             BRGT puts a breakpoint in the BP
00001D10= 42 52 47 54             1492          DC.B    'BRGT'          table - but not in the code
00001D14= FFFFFD12                1493          DC.L    BR_GET-COMTAB
00001D18= 04 02                   1494          DC.B    4,2             PLAN puts the breakpoints in the code
00001D1A= 50 4C 41 4E             1495          DC.B    'PLAN'
00001D1E= FFFFFD50                1496          DC.L    BR_SET-COMTAB
00001D22= 04 04                   1497          DC.B    4,4              KILL removes breakpoints from the code
00001D24= 4B 49 4C 4C             1498          DC.B    'KILL'
00001D28= FFFFFDBC                1499          DC.L    BR_CLR-COMTAB
00001D2C= 04 02                   1500          DC.B    4,2             GB <address> sets breakpoints and
00001D2E= 47 42 20 20             1501          DC.B    'GB  '          then calls GO.
00001D32= FFFFFCD4                1502          DC.L    GB-COMTAB
00001D36= 04 03                   1503          DC.B    4,3             REG <reg> <value> loads <value>
00001D38= 52 45 47 20             1504          DC.B    'REG '          into <reg> in TASK_T. Used to preset
00001D3C= FFFFFDD8                1505          DC.L    REG_MOD-COMTAB  registers before a GO or GB
00001D40= 05 05                   1506          DC.B    5,5             REG <reg> <value> loads <value>
00001D42= 52 45 53 45 54          1507          DC.B    'RESET'         into <reg> in TASK_T. Used to preset
00001D48= FFFFF346                1508          DC.L    RESET-COMTAB  registers before a GO or GB
00001D4C= 00 00                   1509          DC.B    0,0
00001D4E                          1510   *=============================================================================
00001D4E                          1511  *   This is a list of the information needed to setup the DCBs
00001D4E                          1512   
00001D4E  =00001D4E               1513  DCB_LST EQU     *
00001D4E= 43 4F 4E 5F 49 4E ...   1514  DCB1    DC.B    'CON_IN  '      Device name (8 bytes)
00001D56= 0000163C 00008001       1515          DC.L    CON_IN,ACIA     Address of driver routine, device
00001D5E= 0002                    1516          DC.W    2               Number of words in parameter field
00001D60= 43 4F 4E 5F 4F 55 ...   1517  DCB2    DC.B    'CON_OUT '
00001D68= 0000166C 00008001       1518          DC.L    CON_OUT,ACIA
00001D70= 0002                    1519          DC.W    2
00001D72                          1520   *=============================================================================
00001D72                          1521  *   DCB structure
00001D72                          1522  *
00001D72                          1523  *               -----------------------
00001D72                          1524  *       0 ->   | DCB  name           |
00001D72                          1525  *               |---------------------|
00001D72                          1526  *       8 ->   | Device driver          |
00001D72                          1527  *               |---------------------|
00001D72                          1528  *      12 ->   | Device address         |
00001D72                          1529  *               |---------------------|
00001D72                          1530  *      16 ->   |Size of param block  |
00001D72                          1531  *              |---------------------| ---
00001D72                          1532  *      18 ->   |        Status          |   |
00001D72                          1533  *               | logical  | physical |   | S
00001D72                          1534  *               |---------------------|   |
00001D72                          1535  *               .                       .   .
00001D72                          1536  *               |---------------------| ---
00001D72                          1537  *    18+S ->   | Pointer to next DCB |
00001D72                          1538  *
00001D72                          1539  *=============================================================================
00001D72                          1540  *   All strings and other fixed parameters here
00001D72                          1541   
00001D72= 0D 0A 54 53 32 4D ...   1542  CRLF    DC.B    CR,LF,'TS2MON >',0
00001D7D= 0D 0A 53 31 00 00       1543  HEADER  DC.B    CR,LF,'S','1',0,0
00001D83= 53 39 20 20 00 00       1544  TAIL    DC.B    'S9  ',0,0
00001D89= 20 53 52 20 20 3D ...   1545  MES1    DC.B    ' SR  =  ',0
00001D92= 20 50 43 20 20 3D ...   1546  MES2    DC.B    ' PC  =  ',0
00001D9B= 20 53 53 20 20 3D ...   1547  MES2A   DC.B    ' SS  =  ',0
00001DA4= 20 20 44 61 74 61 ...   1548  MES3    DC.B    '  Data reg       Address reg',0,0
00001DC2= 20 20 20 20 09 00 00    1549  MES4    DC.B    '       ',0,0
00001DC9= 42 75 73 20 65 72 ...   1550  MES8    DC.B    'Bus error   ',0,0
00001DD7= 41 64 64 72 65 73 ...   1551  MES9    DC.B    'Address error   ',0,0
00001DE9= 49 6C 6C 65 67 61 ...   1552  MES10   DC.B    'Illegal instruction ',0,0
00001DFF= 42 72 65 61 6B 70 ...   1553  MES11   DC.B    'Breakpoint  ',0,0
00001E0D= 54 72 61 63 65 20 ...   1554  MES12   DC.B    'Trace   ',0
00001E16= 44 69 76 69 73 69 ...   1555  MES13   DC.B    'Division by Zero',0
00001E27= 50 72 69 76 69 6C ...   1556  MES14   DC.B    'Priviledge Violation',0
00001E3C= 44 30 44 31 44 32 ...   1557  REGNAME DC.B    'D0D1D2D3D4D5D6D7'
00001E4C= 41 30 41 31 41 32 ...   1558          DC.B    'A0A1A2A3A4A5A6A7'
00001E5C= 53 53 53 52             1559          DC.B    'SSSR'
00001E60= 50 43 20 20 00          1560          DC.B    'PC  ',0
00001E65= 4E 6F 6E 2D 76 61 ...   1561  ERMES1  DC.B    'Non-valid hexadecimal input  ',0
00001E83= 49 6E 76 61 6C 69 ...   1562  ERMES2  DC.B    'Invalid command  ',0
00001E95= 4C 6F 61 64 69 6E ...   1563  ERMES3  DC.B    'Loading error',0
00001EA3= 54 61 62 6C 65 20 ...   1564  ERMES4  DC.B    'Table full  ',0,0
00001EB1= 42 72 65 61 6B 70 ...   1565  ERMES5  DC.B    'Breakpoint not active   ',0,0
00001ECB= 55 6E 69 6E 69 74 ...   1566  ERMES6  DC.B    'Uninitialized exception ',0,0
00001EE5= 20 52 61 6E 67 65 ...   1567  ERMES7  DC.B    ' Range error',0
00001EF2= 50 72 69 76 69 6C ...   1568  ERMES8  DC.B    'Privilege violation ',0,0
00001F08= 28 4A 55 4D 50 29 ...   1569  HEJU    DC.B    '(JUMP) <address> causes execution to begin at <address>',0,0
00001F41= 28 4D 45 4D 29 4F ...   1570  HEME    DC.B    '(MEM)ORY <address> examines contents of <address>',0,0
00001F74= 28 4C 4F 29 41 44 ...   1571  HELO    DC.B    '(LO)AD <string> loads S1/S2 records from the host',0,0
00001FA7= 28 44 55 29 4D 50 ...   1572  HEDU    DC.B    '(DU)MP <string> sends S1 records to host preceeded by <string>',0,0,0
00001FE8= 28 4E 4F 29 42 52 ...   1573  HENO    DC.B    '(NO)BR <address> removes the breakpoint at <address> from the BP',0,0
0000202A= 28 44 49 29 53 50 ...   1574  HEDI    DC.B    '(DI)SP displays the contents of the pseudo registers in TSK_T',0,0
00002069= 28 47 4F 29 20 3C ...   1575  HEGO    DC.B    '(GO) <address> starts program execution at <address>',0,0
0000209F= 28 42 52 29 47 54 ...   1576  HEBR    DC.B    '(BR)GT puts a breakpoint in the BP table - but not in the code',0,0
000020DF= 28 50 4C 29 41 4E ...   1577  HEPL    DC.B    '(PL)AN puts the breakpoints in the code',0,0
00002108= 28 4B 49 4C 4C 29 ...   1578  HEKI    DC.B    '(KILL) removes breakpoints from the code',0,0
00002132= 28 47 42 29 20 3C ...   1579  HEGB    DC.B    '(GB) <address> sets breakpoints and then calls GO',0,0
00002165= 28 52 45 47 29 20 ...   1580  HERE    DC.B    '(REG) <reg> <value> view or preloads <value> into <reg>',0,0
0000219E= 46 50 55 20 4D 61 ...   1581  NAN     DC.B    'FPU Math Error: Result is Not a Number or Infinity',0,0
000021D2= 55 53 45 52 20 4E ...   1582  LOGM    DC.B    'USER NAME: ',0,0
000021DF= 50 52 4F 4A 45 43 ...   1583  USERNA  DC.B    'PROJECT2',0
000021E8= 50 41 53 53 57 4F ...   1584  PASSM   DC.B    'PASSWORD: ',0
000021F3= 47 52 4F 55 50 34 00    1585  PASS    DC.B    'GROUP4',0
000021FA= 46 61 69 6C 65 64 ...   1586  LOGINERROR DC.B 'Failed to logon 3 times, going to reset',0
00002222                          1587   
00002222                          1588  tinywa1_1:
00002222= 54 53 42 55 47 20 ...   1589          DC.B    84,83,66,85,71,32,50,32,86,101,114,115,105,111
00002230= 6E 20 32 33 2E 30 ...   1590          DC.B    110,32,50,51,46,48,55,46,56,54,0
0000223B                          1591  tinywa1_2:
0000223B= 4D 6F 64 69 66 69 ...   1592         DC.B     77,111,100,105,102,105,101,100,32,98,121,32
00002247= 45 75 67 65 6E 65 ...   1593         DC.B     69,117,103,101,110,101,32,65,46,32,82,111,99
00002254= 6B 65 79 20 4A 72 ...   1594         DC.B     107,101,121,32,74,114,46,32,79,99,116,46,49
00002261= 38 2E 32 30 30 39 00    1595         DC.B     56,46,50,48,48,57,0
00002268                          1596  tinywa1_3:
00002268= 61 6E 64 20 47 72 ...   1597         DC.B     97,110,100,32,71,114,111,117,112,32,49,32,83
00002275= 65 70 2E 31 38 2E ...   1598         DC.B     101,112,46,49,56,46,50,48,49,55,0
00002280                          1599  tinywa1_4:
00002280= 66 6F 72 20 75 73 ...   1600         DC.B     102,111,114,32,117,115,101,32,119,105,116,104
0000228C= 20 74 68 65 20 4D ...   1601         DC.B     32,116,104,101,32,77,54,56,48,48,48,32,77,105
0000229A= 6E 69 6D 61 6C 20 ...   1602         DC.B     110,105,109,97,108,32,67,111,109,112,117,116
000022A6= 65 72 20 43 6F 6E ...   1603         DC.B     101,114,32,67,111,110,102,105,103,117,114,97
000022B2= 74 69 6F 6E 00          1604         DC.B     116,105,111,110,0
000022B7                          1605  tinywa1_5:
000022B7= 55 6E 69 76 65 72 ...   1606         DC.B     85,110,105,118,101,114,115,105,116,121,32,111
000022C3= 66 20 4C 6F 75 69 ...   1607         DC.B     102,32,76,111,117,105,115,118,105,108,108,101
000022CF= 00                      1608          DC.B    0
000022D0                          1609  tinywa1_6:
000022D0= 43 45 43 53 20 35 ...   1610         DC.B     67,69,67,83,32,53,50,53,44,32,119,119,119,46
000022DE= 63 73 2E 6C 6F 75 ...   1611         DC.B     99,115,46,108,111,117,105,115,118,105,108,108
000022EA= 65 2E 65 64 75 00       1612         DC.B     101,46,101,100,117,0
000022F0                          1613           
000022F0                          1614  addingErrorMessage      
000022F0= 0D 0A                   1615          DC.B     CR,LF
000022F2= 41 4C 55 20 54 65 ...   1616          DC.B     'ALU Test Error:',CR,LF
00002303= 41 64 64 69 6E 67 ...   1617          DC.B     'Adding error.',CR,LF,0
00002313                          1618                  
00002313                          1619  subtractingErrorMessage 
00002313= 0D 0A                   1620          DC.B     CR,LF
00002315= 41 4C 55 20 54 65 ...   1621          DC.B     'ALU Test Error:',CR,LF
00002326= 53 75 62 74 72 61 ...   1622          DC.B     'Subtracting error.',CR,LF,0
0000233B                          1623                  
0000233B                          1624  multiplyingErrorMessage 
0000233B= 0D 0A                   1625          DC.B      CR,LF
0000233D= 41 4C 55 20 54 65 ...   1626          DC.B      'ALU Test Error:',CR,LF
0000234E= 4D 75 6C 74 69 70 ...   1627          DC.B      'Multiplying error.',CR,LF,0
00002363                          1628                  
00002363                          1629  dividingErrorMessage    
00002363= 0D 0A                   1630          DC.B      CR,LF
00002365= 41 4C 55 20 54 65 ...   1631          DC.B      'ALU Test Error:',CR,LF
00002376= 44 69 76 69 64 69 ...   1632          DC.B      'Dividing error.',CR,LF,0
00002388                          1633                  
00002388                          1634  finishedALUTest
00002388= 0D 0A                   1635          DC.B      CR,LF
0000238A= 41 4C 55 20 54 45 ...   1636          DC.B      'ALU TEST COMPLETE',CR,LF,0
0000239E                          1637                  
0000239E                          1638  MemTestSuccess
0000239E= 0D 0A                   1639          DC.B      CR,LF
000023A0= 4D 45 4D 4F 52 59 ...   1640          DC.B      'MEMORY TEST COMPLETE',CR,LF,0
000023B7                          1641                  
000023B7                          1642  ramErrorMessage 
000023B7= 0D 0A                   1643          DC.B      CR,LF
000023B9= 54 68 65 72 65 20 ...   1644          DC.B      'There was an error reading/writing in Ram at address: ',CR,LF,0
000023F2                          1645          
000023F2                          1646   
000023F2                          1647  _chr:
000023F2= 01                      1648          DC.B    1
000023F3                          1649        
000023F3                          1650          END     RESET

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ACIA                8001
ADD                 10F0
ADDINGERROR         112C
ADDINGERRORMESSAGE  22F0
ADD_ER              18C8
ADR_DAT             1440
ALUTEST             10DA
BP_TAB              164
BRKPT               18F0
BR_CLR              1A76
BR_CLR1             1A7E
BR_CLR2             1A88
BR_GET              19CC
BR_GET1             19DC
BR_GET2             19E8
BR_GET3             19F8
BR_GET4             1A00
BR_SET              1A0A
BR_SET1             1A18
BR_SET2             1A26
BS                  8
BUFFEND             100
BUFFER              394
BUFFPT              102
BUS_ER              18B4
BYTE                135A
CLEARRAM            1042
CLR_BPT             173E
CN_IVEC             112
CN_OVEC             116
COMMAND             8000A
COMMAND_1           1C4A
COMTAB              1CBA
CON_I1              164A
CON_I2              1662
CON_IN              163C
CON_OT1             167A
CON_OT2             1690
CON_OT3             1698
CON_OUT             166C
CR                  D
CRLF                1D72
CTRL_A              1
DATA                4500
DCB1                1D4E
DCB2                1D60
DCB_LST             1D4E
DELAY               15CE
DELAY1              15D8
DIVIDE              111C
DIVIDINGERRORMESSAGE  2363
DIVISIONERROR       115C
DUMP                1526
DUMP1               1536
DUMP2               1542
DUMP3               1558
DUMP4               156C
DUMP5               157A
DUMP6               1594
DUMP7               15B8
ECHO                10A
ENDALUTEST          116C
ERMES1              1E65
ERMES2              1E83
ERMES3              1E95
ERMES4              1EA3
ERMES5              1EB1
ERMES6              1ECB
ERMES7              1EE5
ERMES8              1EF2
EXEC1               12E2
EXEC2               12F2
EXECUTE             12D0
EX_D1               182E
EX_DIS              181C
FINISHEDALUTEST     2388
FIRST               194
FUNC1               175C
FUNC10              17C6
FUNC11              17D2
FUNC12              17DE
FUNC13              17EA
FUNC14              17F6
FUNC15              1802
FUNC16              180E
FUNC17              181A
FUNC2               1766
FUNC3               1772
FUNC4               177E
FUNC5               178A
FUNC6               1796
FUNC7               17A2
FUNC8               17AE
FUNC9               17BA
GB                  198E
GETCH2              16D2
GETCH3              16F0
GETCHAR             16AC
GETLINE             11B8
GETLN2              11C2
GETLN3              11DC
GETLN4              11E6
GETLN5              11EA
GETPASS             11EE
GETPS2              11F8
GETPS3              1212
GETPS4              121E
GETPS5              1222
GETSTAR             1228
GO                  196E
GO1                 197E
GO2                 198C
GROUP1              190E
GROUP1A             192C
GROUP2              1942
GROUP2A             194E
HEADER              1D7D
HEADING             11B2
HEBR                209F
HEDI                202A
HEDU                1FA7
HEGB                2132
HEGO                2069
HEJU                1F08
HEKI                2108
HELO                1F74
HELP                1BA4
HEME                1F41
HENO                1FE8
HEPL                20DF
HERE                2165
HEX                 133C
HEX_OK              1358
IL_ER               189A
IO_OPEN             1704
IO_REQ              162A
JUMP                13EC
JUMP1               13FA
LBPT                1746
LF                  A
LNBUFF              C1
LOAD                1462
LOAD1               147E
LOAD2               148E
LOAD3               14A8
LOAD4               14C2
LOAD5               14D0
LOAD6               14D2
LOAD6A              14F6
LOAD7               1508
LOAD8               151E
LOG1                1B1C
LOGF                1B72
LOGINERROR          21FA
LOGM                21D2
LOGON               1B14
LOGS                1B7C
LONGWD              1370
LSCH                1B82
LSCH0               1B8C
LSCHF               1B9E
LSCHS               1B9C
MAXCHR              40
MEM1                140C
MEM2                142A
MEM3                143E
MEMORY              1402
MEMTESTEND          10CA
MEMTESTSUCCESS      239E
MES1                1D89
MES10               1DE9
MES11               1DFF
MES12               1E0D
MES13               1E16
MES14               1E27
MES2                1D92
MES2A               1D9B
MES3                1DA4
MES4                1DC2
MES8                1DC9
MES9                1DD7
MULTIPLICATIONERROR  114C
MULTIPLY            110C
MULTIPLYINGERRORMESSAGE  233B
NAN                 219E
NEWLINE             1192
NOBR                1A30
NOBR1               1A40
NOBR2               1A4E
NOBR3               1A5E
NOBR4               1A64
NOBR5               1A6C
NOT_HEX             1354
OPEN1               170C
OPEN2               1714
OPEN3               1722
OPEN4               1738
OPERAND             80010
OUT1X               13BA
OUT1X1              13CC
OUT2X               13D4
OUT4X               13DC
OUT8X               13E4
PARAM               1376
PARAM1              137E
PARAM3              13A2
PARAM4              13A6
PARAM5              13B2
PARAM6              13B6
PARAMTR             106
PASS                21F3
PASSCH2             1250
PASSCH3             126E
PASSM               21E8
PRI_ER              18DC
PS1                 11A4
PS2                 11AE
PSPACE              1454
PSTRING             11A2
PUTCHAR             16F4
PUTSTAR             1272
PUTSTARS            1280
RAMCLEARERROR       106E
RAMERRORMESSAGE     23B7
RAMTEST             1036
RAMWRITEERROR       109C
RANGE               15BE
REGNAME             1E3C
REG_MD1             1AB0
REG_MD2             1AC6
REG_MD3             1AD6
REG_MD4             1AF4
REG_MD5             1B00
REG_MOD             1A92
RESET               1000
RESPONSE            80000
REST1               19A4
RESTORE             1994
SEARCH              12FC
SETACIA             117C
SET_DCB             15E0
SIMMODE             C0
SKIP                16EE
SPACE               20
SRCH2               1316
SRCH3               131A
SRCH4               1322
SRCH6               132C
SRCH7               1336
STACK               4400
STAR                10B
ST_DCB1             15F0
ST_DCB2             15F4
SUBTRACT            10FE
SUBTRACTINGERROR    113C
SUBTRACTINGERRORMESSAGE  2313
TAIL                1D83
TIDY                128E
TIDY1               1294
TIDY2               12A0
TIDY3               12AA
TIDY4               12B4
TIDY5               12BE
TIDY6               12CA
TINYWA1_1           2222
TINYWA1_2           223B
TINYWA1_3           2268
TINYWA1_4           2280
TINYWA1_5           22B7
TINYWA1_6           22D0
TRACE               19B8
TRAP_0              1750
TRAP_14             4E4E
TSK_T               11A
USERNA              21DF
UTAB                10E
U_CASE              10C
WAIT                57
WORD                136A
WRITERAM            1058
X_UN                1B04
_00000000           126A
_00000001           126E
_BANNER             1C5C
_CHR                23F2
_COMMAND            1C4A
_EXECUTE            12D0
_GETLINE            11B8
_GETPASS            11EE
_GO                 196E
_HELP               1BA4
_LOAD               1462
_LOGON              1B14
_LSCH               1B82
_MAIN               1C4A
_MAINSTART          1C38
_NEWLINE            1192
_PSTRING            11A2
_RESET              1000
_TIDY               128E
