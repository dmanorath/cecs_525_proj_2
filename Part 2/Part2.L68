00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 2/19/2018 1:00:33 PM

00000000                             1  *=============================================================================
00000000                             2  *   Exception Vector Table in ROM
00000000                             3                  ORG     $0
00000000                             4                  * 00-03 SSP, Reset, bus error, address error
00000000= 00004400 00001000 ...      5                  DC.L    STACK,RESET,BUS_ER,ADD_ER
00000010                             6                  * 04-07 ILLEGAL, zero divide, CHK, TRAPV
00000010= 00001882 00001AEC ...      7                  DC.L    IL_ER,X_UN,X_UN,X_UN
00000020                             8                  * 08-0F Privilege, Trace, 1010, 1111, 3 Reserved, Uninitialized
00000020= 000018C4 00001AEC ...      9                  DC.L    PRI_ER,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000040                            10                  * 10-17 Uninitialized
00000040= 00001AEC 00001AEC ...     11                  DC.L    X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000060                            12                  * 18-1F Uninitialized
00000060= 00001AEC 00001AEC ...     13                  DC.L    X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
00000080                            14                  * 20-2F TRAP Vectors: 0, 14, 15 are initialized
00000080= 00001738 00001AEC ...     15                  DC.L    TRAP_0,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,X_UN
000000A0= 00001AEC 00001AEC ...     16                  DC.L    X_UN,X_UN,X_UN,X_UN,X_UN,X_UN,BRKPT,_main
000000C0                            17  * *=============================================================================
000000C0  =00000008                 18  BS              EQU     $08             Back_space
000000C0  =0000000D                 19  CR              EQU     $0D             Carriage_return
000000C0  =0000000A                 20  LF              EQU     $0A             Line_feed
000000C0  =00000020                 21  SPACE           EQU     $20             Space
000000C0  =00000057                 22  WAIT            EQU     'W'             Wait character (to suspend output)
000000C0  =00000001                 23  CTRL_A          EQU     $01             Control_A forces return to monitor
000000C0                            24  *                                       Device addresses
000000C0  =00004400                 25  STACK           EQU     $4400           Stack_pointer
000000C0  =00008001                 26  ACIA            EQU     $8001           Console ACIA control
000000C0  =00004E4E                 27  TRAP_14         EQU     $4E4E           Code for TRAP #14
000000C0  =00000040                 28  MAXCHR          EQU     64              Length of input line buffer
000000C0  =0008000A                 29  COMMAND         EQU     $8000A          Address of FPU command register
000000C0  =00080000                 30  RESPONSE    EQU  $80000         Address of FPU response register
000000C0  =00080010                 31  OPERAND         EQU     $80010          Address of FPU operand register
000000C0                            32  *
000000C0= 00                        33  SIMMODE     DC.B        0               1 for sim mode 0 for board
000000C1  =00004500                 34  DATA            EQU     $4500           Data origin
000000C1                            35  LNBUFF          DS.B    MAXCHR          Input line buffer
00000101  =00000100                 36  BUFFEND         EQU     LNBUFF+MAXCHR-1 End of line buffer
00000102                            37  BUFFPT          DS.L    1               Pointer to line buffer
00000106                            38  PARAMTR         DS.L    1               Last parameter from line buffer
0000010A                            39  ECHO            DS.B    1               When clear this enable input echo
0000010B                            40  STAR            DS.B    1
0000010C                            41  U_CASE          DS.B    1               Flag for upper case conversion
0000010E                            42  UTAB            DS.L    1               Pointer to user command table
00000112                            43  CN_IVEC         DS.L    1               Pointer to console input DCB
00000116                            44  CN_OVEC         DS.L    1               Pointer to console output DCB
0000011A                            45  TSK_T           DS.W    37              Frame for D0-D7, A0-A6, USP, SSP, SW, PC
00000164                            46  BP_TAB          DS.W    24              Breakpoint table
00000194                            47  FIRST           DS.B    512             DCB area
00000394                            48  BUFFER          DS.B    256             256 bytes for I/O buffer
00000494                            49   
00000494                            50  *   This is the main program which assembles a command in the line
00000494                            51  *   buffer, removes leading/embedded spaces and interprets it by matching
00000494                            52  *   it with a command in the user table or the built-in table COMTAB
00000494                            53  *   All variables are specified with respect to A6
00000494                            54   
00000494                            55   
00001000                            56                  ORG     $1000           Monitor Origin
00001000  =00001000                 57  RESET:          EQU     *
00001000  4DF8 4500                 58                  LEA.L   DATA,A6         A6 points to data area
00001004  2D4E 0152                 59                  MOVE.L  A6,TSK_T+56(A6) initialize A6 in the register Frame
00001008  4DF8 4500                 60                  LEA.L   DATA,A6         A6 points to data area
0000100C  42AE 010E                 61                  CLR.L   UTAB(A6)        Reset pointer to user extension table
00001010  422E 010A                 62                  CLR.B   ECHO(A6)        Set automatic character echo
00001014  422E 010B                 63                  CLR.B   STAR(A6)        Clear this flag for a standard echo
00001018  422E 010C                 64                  CLR.B   U_CASE(A6)      Clear case conversion flag (UC<-LC)
0000101C  6100 0146                 65                  BSR     SETACIA         Setup ACIAs
00001020  6100 0704                 66                  BSR     CLR_BPT         Clear break point table
00001024  6100 05A2                 67                  BSR     SET_DCB         Setup DCB table in RAM
00001028  6100 00AE                 68                  BSR     ALUTest
0000102C  6100 0008                 69                  BSR     RamTest
00001030  4287                      70                          CLR.L   D7
00001032  6100 0BE2                 71                  BSR     _mainstart
00001036                            72  *===========================================================================
00001036                            73  *   MEM TEST
00001036                            74   
00001036                            75   
00001036                            76  RamTest
00001036  1A3C 00FF                 77                  move.b #$FF, d5
0000103A  207C 00004000             78                  move.l #$4000, a0
00001040                            79                  ;bsr    ClearRam
00001040                            80                  ;bsr    WriteRam
00001040  6000 0086                 81                  bra     MemTestEnd
00001044                            82    
00001044                            83  ClearRam
00001044  4210                      84                  clr.b   (a0) 
00001046  0C18 0000                 85                  cmpi.b #0,(a0)+
0000104A  6600 0020                 86                  bne     RamClearError
0000104E  B1FC 00005001             87                  cmp.l   #$5001, a0
00001054  66EE                      88                  bne     ClearRam
00001056  4E75                      89                  rts
00001058                            90          
00001058                            91  WriteRam
00001058  1105                      92                  move.b d5, -(a0)
0000105A  0C10 00FF                 93                  cmpi.b  #$FF, (a0)
0000105E  6600 003A                 94                  bne     RamWriteError
00001062  B1FC 00004000             95                  cmp.l   #$4000, a0
00001068  66EE                      96                  bne     WriteRam
0000106A  4E75                      97                  rts
0000106C                            98     
0000106C                            99  RamClearError
0000106C                           100                  ; exception message
0000106C  5348                     101                  sub     #$01, a0
0000106E  49F9 00002361            102                  lea.l   ramErrorMessage,a4              
00001074  6100 0114                103                  bsr     PSTRING
00001078  6100 0100                104                  bsr     NEWLINE  
0000107C  103C 000F                105                  move.b  #15,d0
00001080  143C 0010                106                  move.b  #16,d2
00001084  3848                     107                  move    a0,a4
00001086  6100 0102                108                  bsr     PSTRING
0000108A  6100 00EE                109                  bsr     NEWLINE         
0000108E  5248                     110                  add     #$01,a0
00001090  B1FC 00005001            111                  cmp.l   #$5001, a0
00001096  66AC                     112                  bne     ClearRam
00001098  4E75                     113                  rts
0000109A                           114     
0000109A                           115  RamWriteError
0000109A                           116                  ; exception message 
0000109A  103C 000E                117                  move.b  #14,d0          
0000109E  49F9 00002361            118                  lea.l   ramErrorMessage,a4              
000010A4  6100 00E4                119                  bsr     PSTRING
000010A8  6100 00D0                120                  bsr     NEWLINE  
000010AC  103C 000F                121                  move.b  #15,d0
000010B0  143C 0010                122                  move.b  #16,d2
000010B4  3848                     123                  move    a0,a4
000010B6  6100 00D2                124                  bsr     PSTRING
000010BA  6100 00BE                125                  bsr     NEWLINE         
000010BE  B1FC 00004000            126                  cmp.l   #$4000, a0
000010C4  6692                     127                  bne     WriteRam
000010C6  4E75                     128                  rts
000010C8                           129          
000010C8                           130  MemTestEnd
000010C8  49F9 00002348            131                  lea     MemTestSuccess,a4
000010CE  6100 00BA                132                  bsr     _PSTRING
000010D2  6100 00A6                133                  bsr     _NEWLINE
000010D6  4E75                     134                  rts
000010D8                           135     
000010D8                           136          
000010D8                           137  *============================================================================
000010D8                           138  *   ALU Test
000010D8                           139   
000010D8                           140  ALUTest:
000010D8  123C 000E                141                  move.b #14, d1
000010DC                           142     
000010DC                           143                  ;bsr    Add
000010DC                           144                  ;bsr    Subtract
000010DC                           145                  ;bsr    Multiply
000010DC                           146                  ;bsr    Divide
000010DC  6000 0076                147                  bra      EndALUTest
000010E0                           148   
000010E0                           149  Add
000010E0  5E41                     150                  add.w  #7, d1
000010E2  0C41 0015                151                  cmpi.w #21, d1
000010E6  6600 002C                152                  bne     AddingError
000010EA  4E75                     153                  rts
000010EC                           154          
000010EC                           155  Subtract
000010EC  5F01                     156                  sub.b  #7, d1
000010EE  0C41 000E                157                  cmpi.w  #14, d1
000010F2  6600 0030                158                  bne     SubtractingError
000010F6  4E75                     159                  rts
000010F8                           160  Multiply
000010F8  C3FC 0002                161                  muls.w  #2, d1
000010FC  0C41 001C                162                  cmpi.w  #28, d1
00001100  6600 0032                163                  bne     MultiplicationError
00001104  4E75                     164                  rts
00001106                           165     
00001106                           166  Divide
00001106  83FC 0002                167                  divs.w  #2, d1
0000110A  0C41 000E                168                  cmpi.w  #14, d1
0000110E  6600 0034                169                  bne     DivisionError
00001112  4E75                     170                  rts
00001114                           171     
00001114                           172  AddingError     
00001114  49F9 0000229A            173                  lea     addingErrorMessage,a4   
0000111A  6100 006E                174                  bsr     _PSTRING
0000111E  6100 005A                175                  bsr     _NEWLINE
00001122  4E75                     176                  rts
00001124                           177     
00001124                           178  SubtractingError        
00001124  49F9 000022BD            179                  lea     subtractingErrorMessage,a4      
0000112A  6100 005E                180                  bsr     _PSTRING
0000112E  6100 004A                181                  bsr     _NEWLINE
00001132  4E75                     182                  rts
00001134                           183     
00001134                           184  MultiplicationError             
00001134  49F9 000022E5            185                  lea     multiplyingErrorMessage,a4      
0000113A  6100 004E                186                  bsr     _PSTRING
0000113E  6100 003A                187                  bsr     _NEWLINE
00001142  4E75                     188                  rts
00001144                           189     
00001144                           190  DivisionError           
00001144  49F9 0000230D            191                  lea     dividingErrorMessage,a4 
0000114A  6100 003E                192                  bsr     _PSTRING
0000114E  6100 002A                193                  bsr     _NEWLINE
00001152  4E75                     194                  rts
00001154                           195   
00001154                           196  EndALUTest
00001154  49F9 00002332            197                  lea     finishedALUTest,a4
0000115A  6100 002E                198                  bsr     _PSTRING
0000115E  6100 001A                199                  bsr     _NEWLINE
00001162  4E75                     200                  rts
00001164                           201   
00001164                           202  *=============================================================================
00001164                           203  *   Some initialization and basic routines
00001164                           204   
00001164  =00001164                205  SETACIA         EQU     *               Setup ACIA parameters
00001164  41F9 00008001            206                  LEA.L   ACIA,A0         A0 points to console ACIA
0000116A  10BC 0003                207                  MOVE.B  #$03,(A0)       Reset ACIA
0000116E  10BC 0019                208                  MOVE.B  #$19,(A0)       Set up ACIA constants (no IRQ,
00001172  117C 0019 0001           209                  MOVE.B  #$19,1(A0)      8 bit, even parity, 1 stop, no flowctrl
00001178  4E75                     210                  RTS                      Return
0000117A                           211  *=============================================================================
0000117A                           212  *   Prints a newline carriage return
0000117A                           213   
0000117A                           214  _NEWLINE
0000117A  =0000117A                215  NEWLINE         EQU     *               Move cursor to start of newline
0000117A  48E7 0008                216                  MOVEM.L A4,-(A7)        Save A4
0000117E  49FA 0BC4                217                  LEA.L   CRLF(PC),A4     Point to CR/LF string
00001182  6106                     218                  BSR.S   PSTRING         Print it
00001184  4CDF 1000                219                  MOVEM.L (A7)+,A4        Restore A4
00001188  4E75                     220                  RTS                     Return
0000118A                           221  _PSTRING
0000118A  =0000118A                222  PSTRING         EQU     *               Display the string pointed at by A4
0000118A  2F00                     223                  MOVE.L  D0,-(A7)        Save D0
0000118C  101C                     224  PS1             MOVE.B  (A4)+,D0        Get character to be printed
0000118E  6706                     225                  BEQ.S   PS2             
00001190  6100 054A                226                  BSR     PUTCHAR         Else print it
00001194  60F6                     227                  BRA     PS1             Continue
00001196  201F                     228  PS2             MOVE.L  (A7)+,D0        Restore D0 and exit
00001198  4E75                     229                  RTS
0000119A                           230   
0000119A  61DE                     231  HEADING         BSR     NEWLINE         Same as PSTRING but with newline
0000119C  61EC                     232                  BSR     PSTRING
0000119E  60DA                     233                  BRA     NEWLINE
000011A0                           234   
000011A0                           235  *=============================================================================
000011A0                           236  *   GETLINE inputs a string of characters into a line buffer
000011A0                           237  *               A3 points to next free entry in line buffer
000011A0                           238  *               A2 points to end of buffer
000011A0                           239  *               A1 points to start of buffer
000011A0                           240  *               D0 holds character to be stored
000011A0                           241  _GETLINE
000011A0  43EE 00C1                242  GETLINE         LEA.L   LNBUFF(A6),A1   A1 points to start of line buffer
000011A4  47D1                     243                  LEA.L   (A1),A3         A3 points to start (initially)
000011A6  45E9 0040                244                  LEA.L   MAXCHR(A1),A2   A2 points to end of buffer
000011AA  6100 04E8                245  GETLN2          BSR     GETCHAR         Get a character
000011AE  B03C 0001                246                  CMP.B   #CTRL_A,D0      If control_A then reject this line
000011B2  671E                     247                  BEQ.S   GETLN5          and get another line
000011B4  B03C 0008                248                  CMP.B   #BS,D0          If back_space then move back pointer
000011B8  660A                     249                  BNE.S   GETLN3          Else skip past wind-back routine
000011BA  B7C9                     250                  CMP.L   A1,A3           First check for empty buffer
000011BC  67EC                     251                  BEQ     GETLN2          If buffer empty then continue
000011BE  47EB FFFF                252                  LEA     -1(A3),A3       Else decrement buffer pointer
000011C2  60E6                     253                  BRA     GETLN2          and continue with next character
000011C4  16C0                     254  GETLN3          MOVE.B  D0,(A3)+        Store character and update pointer
000011C6  B03C 000D                255                  CMP.B   #CR,D0          Test for command terminator
000011CA  6602                     256                  BNE.S   GETLN4          If not CR then skip past exit
000011CC  60AC                     257                  BRA     NEWLINE         Else new line before next operation
000011CE  B7CA                     258  GETLN4          CMP.L   A2,A3           Test for buffer overflow
000011D0  66D8                     259                  BNE     GETLN2          If buffer not full then continue
000011D2  61A6                     260  GETLN5          BSR     NEWLINE         Else move to next line and
000011D4  60CA                     261                  BRA     GETLINE         repeat this routine
000011D6                           262  *=============================================================================
000011D6                           263  *  GETPASS  inputs a string of characters into a line buffer
000011D6                           264  *               A3 points to next free entry in line buffer
000011D6                           265  *               A2 points to end of buffer
000011D6                           266  *               A1 points to start of buffer
000011D6                           267  *               D0 holds character to be stored
000011D6                           268  *
000011D6                           269  _GETPASS
000011D6  43EE 00C1                270  GETPASS     LEA.L       LNBUFF(A6),A1  A1 points to start of password buffer
000011DA  47D1                     271              LEA.L       (A1),A3         A3 points to start (initially)
000011DC  45E9 0040                272              LEA.L       MAXCHR(A1),A2  A2 points to end of buffer
000011E0  6100 002E                273  GETPS2      BSR         GETSTAR         Get a character
000011E4  B03C 0001                274              CMP.B       #CTRL_A,D0      If control_A then reject this line
000011E8  6720                     275              BEQ.S       GETPS5          and get another line
000011EA  B03C 0008                276              CMP.B       #BS,D0          If back_space then move back pointer
000011EE  660A                     277              BNE.S       GETPS3          Else skip past wind-back routine
000011F0  B7C9                     278              CMP.L       A1,A3           First check for empty buffer
000011F2  67EC                     279              BEQ         GETPS2          If buffer empty then continue
000011F4  47EB FFFF                280              LEA         -1(A3),A3       Else decrement buffer pointer
000011F8  60E6                     281              BRA         GETPS2          and continue with next character
000011FA  16C0                     282  GETPS3      MOVE.B   D0,(A3)+           Store character and update pointer
000011FC  B03C 000D                283              CMP.B       #CR,D0          Test for command terminator
00001200  6604                     284              BNE.S       GETPS4          If not CR then skip past exit
00001202  6000 FF76                285              BRA         NEWLINE         Else new line before next operation
00001206  B7CA                     286  GETPS4      CMP.L       A2,A3           Test for buffer overflow
00001208  66D6                     287              BNE         GETPS2          If buffer not full then continue
0000120A  6100 FF6E                288  GETPS5      BSR         NEWLINE         Else move to next line and
0000120E  60C6                     289              BRA         GETPASS         repeat this routine
00001210                           290           
00001210                           291  *************************************************************************
00001210                           292  *
00001210                           293  *  GETSTAR gets a character from the console device
00001210                           294  *  This is the main input routine and uses the device whose name 
00001210                           295  *  is stored in CN_IVEC. Changing this name redirects input.
00001210                           296   
00001210  2F08                     297  GETSTAR     MOVE.L  A0,-(A7)            Save working register
00001212  206E 0112                298              MOVE.L  CN_IVEC(A6),A0  A0 points to name of console DCB
00001216  6100 04D4                299              BSR.L   IO_OPEN             Open console (get DCB address in A0)
0000121A  0807 0003                300              BTST    #3,D7               D7(3) set if open error
0000121E  6636                     301              BNE.S   PASSCH3             If error then exit now
00001220  6100 03F0                302              BSR         IO_REQ          Else execute I/O transaction
00001224  C03C 007F                303              AND.B   #$7F,D0             Strip msb of input
00001228  4A2E 010C                304              TST.B   U_CASE(A6)          Test for upper -> lower case conversion
0000122C  660A                     305              BNE.S   PASSCH2             If flag not zero do not convert case
0000122E  0800 0006                306              BTST        #6,D0           Test input for lower case
00001232  6704                     307              BEQ.S   PASSCH2             If upper case then skip conversion
00001234  C03C 00DF                308              AND.B   #%11011111,D0   Else clear bit 5 for upper case conv
00001238                           309   
00001238  43F8 00C0                310  PASSCH2     LEA.L       SIMMODE,A1
0000123C  1E11                     311              MOVE.B   (A1),D7
0000123E                           312   
0000123E                           313           if.l d7 <eq> #1 then.s
00001246  6100 0012                314                  BSR.L   PUTSTAR         Echo the input
0000124A  6100 001C                315                  BSR.L   PUTSTARS
0000124E                           316           else
00001252  6100 0014                317                  BSR.L   PUTSTARS
00001256                           318           endi
00001256                           319          
00001256  205F                     320  PASSCH3     MOVE.L  (A7)+,A0            Restore working register
00001258  4E75                     321              RTS                         and return
0000125A                           322   
0000125A                           323  *************************************************************************
0000125A                           324  *
0000125A                           325  *  PUTSTAR removes a character to the console device so password is not shown
0000125A                           326  *  The name of the output device is in CN_OVEC.
0000125A                           327  *
0000125A  3F00                     328  PUTSTAR     MOVE.W   D0,-(A7)           Save D0
0000125C                           329                  ;MOVE.B   #$2A,D0       Load * into D0
0000125C  103C 0008                330                  move.B  #$8,D0
00001260  6100 047A                331                  BSR   PUTCHAR           Print the character
00001264  301F                     332                  MOVE.W   (A7)+,D0       Restore D0
00001266  4E75                     333                  RTS
00001268                           334  *************************************************************************
00001268                           335  *
00001268                           336  *  PUTSTARS adds a * to the console device for each character of password
00001268                           337  *  The name of the output device is in CN_OVEC.
00001268                           338  *        
00001268  3F00                     339  PUTSTARS    MOVE.W   D0,-(A7)           Save D0
0000126A  103C 002A                340                  MOVE.B   #$2A,D0        Load * into D0
0000126E                           341                  ;move.B  #$8,D0
0000126E  6100 046C                342                  BSR     PUTCHAR         Print the character
00001272  301F                     343                  MOVE.W  (A7)+,D0        Restore D0
00001274  4E75                     344                  RTS
00001276                           345          
00001276                           346  * *==============================================================================
00001276                           347  *
00001276                           348  *   TIDY        cleans up the line buffer by removing leading spaces and multiple
00001276                           349  *               spaces between parameters. At the end of TIDY, BUFFPT points to
00001276                           350  *               the first parameter following the command.
00001276                           351  *               A0 = pointer to line buffer. A1 = pointer to cleaned up buffer
00001276                           352  _TIDY
00001276  41EE 00C1                353  TIDY            LEA.L   LNBUFF(A6),A0   A0 points to line buffer
0000127A  43D0                     354                  LEA.L   (A0),A1         A1 points to start of line buffer
0000127C  1018                     355  TIDY1           MOVE.B  (A0)+,D0        Read character from line buffer
0000127E  B03C 0020                356                  CMP.B   #SPACE,D0       Repeat until the first non-space
00001282  67F8                     357                  BEQ     TIDY1           character is found
00001284  41E8 FFFF                358                  LEA.L   -1(A0),A0       Move pointer back to first char
00001288  1018                     359  TIDY2           MOVE.B  (A0)+,D0        Move the string left to remove
0000128A  12C0                     360                  MOVE.B  D0,(A1)+        any leading spaces
0000128C  B03C 0020                361                  CMP.B   #SPACE,D0       Test for embedded space
00001290  660A                     362                  BNE.S   TIDY4           If not space then test for EOL
00001292  0C18 0020                363  TIDY3           CMP.B   #SPACE,(A0)+    If space skip multiple embedded
00001296  67FA                     364                  BEQ     TIDY3           spaces
00001298  41E8 FFFF                365                  LEA.L   -1(A0),A0       Move back pointer
0000129C  B03C 000D                366  TIDY4           CMP.B   #CR,D0          Test for end_of_line (EOL)
000012A0  66E6                     367                  BNE     TIDY2           If not EOL then read next char
000012A2  41EE 00C1                368                  LEA.L   LNBUFF(A6),A0   Restore buffer pointer
000012A6  0C10 000D                369  TIDY5           CMP.B   #CR,(A0)        Test for EOL
000012AA  6706                     370                  BEQ.S   TIDY6           If EOL then exit
000012AC  0C18 0020                371                  CMP.B   #SPACE,(A0)+    Test for delimiter
000012B0  66F4                     372                  BNE     TIDY5           Repeat until delimiter or EOL
000012B2  2D48 0102                373  TIDY6           MOVE.L  A0,BUFFPT(A6)   Update buffer pointer
000012B6  4E75                     374                  RTS
000012B8                           375   
000012B8                           376  * *==============================================================================
000012B8                           377  *
000012B8                           378  *   EXECUTE matches the first command in the line buffer with the
000012B8                           379  *               commands in a command table. An external table pointed at by
000012B8                           380  *               UTAB is searched first and then the in-built table, COMTAB.
000012B8                           381  _EXECUTE
000012B8  4AAE 010E                382  EXECUTE         TST.L   UTAB(A6)        Test pointer to user table
000012BC  670C                     383                  BEQ.S   EXEC1           If clear then try built-in table
000012BE  266E 010E                384                  MOVE.L  UTAB(A6),A3     Else pick up pointer to user table
000012C2  6120                     385                  BSR.S   SEARCH          Look for command in user table
000012C4  6404                     386                  BCC.S   EXEC1           If not found then try internal table
000012C6  2653                     387                  MOVE.L  (A3),A3         Else get absolute address of command
000012C8  4ED3                     388                  JMP     (A3)            from user table and execute it
000012CA                           389  *
000012CA  47FA 09CC                390  EXEC1           LEA.L   COMTAB(PC),A3   Try built-in command table
000012CE  6114                     391                  BSR.S   SEARCH          Look for command in built-in table
000012D0  6508                     392                  BCS.S   EXEC2           If found then execute command
000012D2  49FA 0B81                393                  LEA.L   ERMES2(PC),A4   Else print "invalid command"
000012D6  6000 FEB2                394                  BRA.L   PSTRING         and return
000012DA  2653                     395  EXEC2           MOVE.L  (A3),A3         Get the relative command address
000012DC  49FA 09BA                396                  LEA.L   COMTAB(PC),A4   pointed at by A3 and add it to
000012E0  D7CC                     397                  ADD.L   A4,A3           the PC to generate the actual
000012E2  4ED3                     398                  JMP     (A3)            command address. Then execute it.
000012E4                           399  *
000012E4  =000012E4                400  SEARCH          EQU     *               Match the command in the line buffer
000012E4  4280                     401                  CLR.L   D0              with command table pointed at by A3
000012E6  1013                     402                  MOVE.B  (A3),D0         Get the first character in the
000012E8  6734                     403                  BEQ.S   SRCH7           current entry. If zero then exit
000012EA  49F3 0006                404                  LEA.L   6(A3,D0.W),A4   Else calculate address of next entry
000012EE  122B 0001                405                  MOVE.B  1(A3),D1        Get number of characters to match
000012F2  4BEE 00C1                406                  LEA.L   LNBUFF(A6),A5   A5 points to command in line buffer
000012F6  142B 0002                407                  MOVE.B  2(A3),D2        Get first character in this entry
000012FA  B41D                     408                  CMP.B   (A5)+,D2        from the table and match with buffer
000012FC  6704                     409                  BEQ.S   SRCH3           If match then try rest of string
000012FE  264C                     410  SRCH2           MOVE.L  A4,A3           Else get address of next entry
00001300  60E2                     411                  BRA      SEARCH          and try the next entry in the table
00001302  5301                     412  SRCH3           SUB.B   #1,D1           One less character to match
00001304  670E                     413                  BEQ.S   SRCH6           If match counter zero then all done
00001306  47EB 0003                414                  LEA.L   3(A3),A3        Else point to next character in table
0000130A  141B                     415  SRCH4           MOVE.B  (A3)+,D2        Now match a pair of characters
0000130C  B41D                     416                  CMP.B   (A5)+,D2
0000130E  66EE                     417                  BNE     SRCH2           If no match then try next entry
00001310  5301                     418                  SUB.B   #1,D1           Else decrement match counter and
00001312  66F6                     419                  BNE     SRCH4           repeat until no chars left to match
00001314  47EC FFFC                420  SRCH6           LEA.L   -4(A4),A3       Calculate address of command entry
00001318  003C 0001                421                  OR.B    #1,CCR          point. Mark carry flag as success
0000131C  4E75                     422                  RTS                     and return
0000131E  023C 00FE                423  SRCH7           AND.B   #$FE,CCR        Fail - clear carry to indicate
00001322  4E75                     424                  RTS                     command not found and return
00001324                           425   *=============================================================================
00001324                           426  *   Basic input routines
00001324                           427  *   HEX =  Get one   hexadecimal character  into D0
00001324                           428  *   BYTE   =  Get two   hexadecimal characters into D0
00001324                           429  *   WORD   =  Get four  hexadecimal characters into D0
00001324                           430  *   LONGWD =  Get eight hexadecimal characters into D0
00001324                           431  *   PARAM  =  Get a longword from the line buffer into D0
00001324                           432  *   Bit 0 of D7 is set to indicate a hexadecimal input error
00001324                           433   
00001324  6100 036E                434  HEX             BSR     GETCHAR         Get a character from input device
00001328  0400 0030                435                  SUB.B   #$30,D0         Convert to binary
0000132C  6B0E                     436                  BMI.S   NOT_HEX         If less than $30 then exit with error
0000132E  B03C 0009                437                  CMP.B   #$09,D0         Else test for number (0 to 9)
00001332  6F0C                     438                  BLE.S   HEX_OK          If number then exit - success
00001334  5F00                     439                  SUB.B   #$07,D0         Else convert letter to hex
00001336  B03C 000F                440                  CMP.B   #$0F,D0         If character in range "A" to "F"
0000133A  6F04                     441                  BLE.S   HEX_OK          then exit successfully
0000133C  8E3C 0001                442  NOT_HEX         OR.B    #1,D7           Else set error flag
00001340  4E75                     443  HEX_OK          RTS                     and return
00001342                           444   
00001342  2F01                     445  BYTE            MOVE.L  D1,-(A7)        Save D1
00001344  61DE                     446                  BSR     HEX             Get first hex character
00001346  E900                     447                  ASL.B   #4,D0           Move it to MS nybble position
00001348  1200                     448                  MOVE.B  D0,D1           Save MS nybble in D1
0000134A  61D8                     449                  BSR     HEX             Get second hex character
0000134C  D001                     450                  ADD.B   D1,D0           Merge MS and LS nybbles
0000134E  221F                     451          MOVE.L  (A7)+,D1        Restore D1
00001350  4E75                     452          RTS
00001352                           453   
00001352  61EE                     454  WORD    BSR     BYTE              Get upper order byte
00001354  E140                     455          ASL.W   #8,D0           Move it to MS position
00001356  60EA                     456          BRA     BYTE            Get LS byte and return
00001358                           457  *
00001358  61F8                     458  LONGWD  BSR     WORD            Get upper order word
0000135A  4840                     459          SWAP    D0              Move it to MS position
0000135C  60F4                     460          BRA     WORD            Get lower order word and return
0000135E                           461   
0000135E                           462  *=============================================================================
0000135E                           463  *   PARAM reads a parameter from the line buffer and puts it in both
0000135E                           464  *   PARAMTR(A6) and D0. Bit 1 of D7 is set on error.
0000135E                           465   
0000135E  2F01                     466  PARAM   MOVE.L  D1,-(A7)        Save D1
00001360  4281                     467          CLR.L   D1              Clear input accumulator
00001362  206E 0102                468          MOVE.L  BUFFPT(A6),A0   A0 points to parameter in buffer
00001366  1018                     469  PARAM1  MOVE.B  (A0)+,D0        Read character from line buffer
00001368  B03C 0020                470          CMP.B   #SPACE,D0       Test for delimiter
0000136C  6720                     471          BEQ.S   PARAM4          The permitted delimiter is a
0000136E  B03C 000D                472          CMP.B   #CR,D0          space or a carriage return
00001372  671A                     473          BEQ.S   PARAM4          Exit on either space or C/R
00001374  E981                     474          ASL.L   #4,D1           Shift accumulated result 4 bits left
00001376  0400 0030                475          SUB.B   #$30,D0         Convert new character to hex
0000137A  6B1E                     476          BMI.S   PARAM5          If less than $30 then not-hex
0000137C  B03C 0009                477          CMP.B   #$09,D0         If less than 10
00001380  6F08                     478          BLE.S   PARAM3          then continue
00001382  5F00                     479          SUB.B   #$07,D0            Else assume $A - $F
00001384  B03C 000F                480          CMP.B   #$0F,D0         If more than $F
00001388  6E10                     481          BGT.S   PARAM5          then exit to error on not-hex
0000138A  D200                     482  PARAM3  ADD.B   D0,D1           Add latest nybble to total in D1
0000138C  60D8                     483          BRA     PARAM1          Repeat until delimiter found
0000138E  2D48 0102                484  PARAM4  MOVE.L  A0,BUFFPT(A6)   Save pointer in memory
00001392  2D41 0106                485          MOVE.L  D1,PARAMTR(A6)  Save parameter in memory
00001396  2001                     486          MOVE.L  D1,D0           Put parameter in D0 for return
00001398  6004                     487          BRA.S   PARAM6          Return without error
0000139A  8E3C 0002                488  PARAM5  OR.B    #2,D7          Set error flag before return
0000139E  221F                     489  PARAM6  MOVE.L  (A7)+,D1        Restore working register
000013A0  4E75                     490          RTS                     Return with error
000013A2                           491  *============================================================================
000013A2                           492  *
000013A2                           493  *   Output routines
000013A2                           494  *   OUT1X   = print one   hexadecimal character
000013A2                           495  *   OUT2X   = print two   hexadecimal characters
000013A2                           496  *   OUT4X   = print four  hexadecimal characters
000013A2                           497  *   OUT8X   = print eight hexadecimal characters
000013A2                           498  *   In each case, the data to be printed is in D0
000013A2                           499   
000013A2  3F00                     500  OUT1X   MOVE.W  D0,-(A7)        Save D0
000013A4  C03C 000F                501          AND.B   #$0F,D0         Mask off MS nybble
000013A8  0600 0030                502          ADD.B   #$30,D0         Convert to ASCII
000013AC  B03C 0039                503          CMP.B   #$39,D0         ASCII = HEX + $30
000013B0  6302                     504          BLS.S   OUT1X1          If ASCII <= $39 then print and exit
000013B2  5E00                     505          ADD.B   #$07,D0         Else ASCII := HEX + 7
000013B4  6100 0326                506  OUT1X1  BSR     PUTCHAR         Print the character
000013B8  301F                     507          MOVE.W  (A7)+,D0        Restore D0
000013BA  4E75                     508          RTS
000013BC                           509  *
000013BC  E818                     510  OUT2X   ROR.B   #4,D0           Get MS nybble in LS position
000013BE  61E2                     511          BSR     OUT1X           Print MS nybble
000013C0  E918                     512             ROL.B   #4,D0        Restore LS nybble
000013C2  60DE                     513          BRA     OUT1X           Print LS nybble and return
000013C4                           514  *
000013C4  E058                     515  OUT4X   ROR.W   #8,D0           Get MS byte in LS position
000013C6  61F4                     516          BSR     OUT2X           Print MS byte
000013C8  E158                     517          ROL.W   #8,D0           Restore LS byte
000013CA  60F0                     518          BRA     OUT2X           Print LS byte and return
000013CC                           519  *
000013CC  4840                     520  OUT8X   SWAP    D0              Get MS word in LS position
000013CE  61F4                     521          BSR     OUT4X           Print MS word
000013D0  4840                     522          SWAP    D0              Restore LS word
000013D2  60F0                     523          BRA     OUT4X           Print LS word and return
000013D4                           524   *=============================================================================
000013D4                           525  *   JUMP causes execution to begin at the address in the line buffer
000013D4                           526   
000013D4  6188                     527  JUMP    BSR     PARAM           Get address from buffer
000013D6  4A07                     528          TST.B   D7              Test for input error
000013D8  6608                     529          BNE.S   JUMP1           If error flag not zero then exit
000013DA  4A80                     530          TST.L   D0              Else test for missing address
000013DC  6704                     531          BEQ.S   JUMP1           field. If no address then exit
000013DE  2040                     532          MOVE.L  D0,A0           Put jump address in A0 and call the
000013E0  4ED0                     533          JMP     (A0)            subroutine. User to supply RTS!!
000013E2  49FA 0A53                534  JUMP1   LEA.L   ERMES1(PC),A4   Here for error - display error
000013E6  6000 FDA2                535          BRA     PSTRING         message and return
000013EA                           536   *=============================================================================
000013EA                           537  *   Display the contents of a memory location and modify it
000013EA                           538   
000013EA  6100 FF72                539  MEMORY  BSR     PARAM           Get start address from line buffer
000013EE  4A07                     540          TST.B   D7              Test for input error
000013F0  6634                     541          BNE.S   MEM3            If error then exit
000013F2  2640                     542          MOVE.L  D0,A3           A3 points to location to be opened
000013F4  6100 FD84                543  MEM1    BSR     NEWLINE
000013F8  612E                     544          BSR.S   ADR_DAT         Print current address and contents
000013FA  6140                     545          BSR.S   PSPACE          update pointer, A3, and O/P space
000013FC  6100 0296                546          BSR     GETCHAR         Input char to decide next action
00001400  B03C 000D                547          CMP.B   #CR,D0          If carriage return then exit
00001404  6720                     548          BEQ.S   MEM3            Exit
00001406  B03C 002D                549          CMP.B   #'-',D0         If "-" then move back
0000140A  6606                     550          BNE.S   MEM2            Else skip wind-back procedure
0000140C  47EB FFFC                551          LEA.L   -4(A3),A3       Move pointer back 2+2
00001410  60E2                     552          BRA     MEM1            Repeat until carriage return
00001412  B03C 0020                553  MEM2    CMP.B   #SPACE,D0       Test for space (= new entry)
00001416  66DC                     554          BNE.S   MEM1            If not space then repeat
00001418  6100 FF38                555          BSR     WORD            Else get new word to store
0000141C  4A07                     556          TST.B   D7              Test for input error
0000141E  6606                     557          BNE.S   MEM3            If error then exit
00001420  3740 FFFE                558          MOVE.W  D0,-2(A3)       Store new word
00001424  60CE                     559          BRA     MEM1            Repeat until carriage return
00001426  4E75                     560  MEM3    RTS
00001428                           561   
00001428  2F00                     562  ADR_DAT MOVE.L  D0,-(A7)        Print the contents of A3 and the
0000142A  200B                     563          MOVE.L  A3,D0           word pointed at by A3.
0000142C  619E                     564          BSR     OUT8X           and print current address
0000142E  610C                     565          BSR.S   PSPACE          Insert delimiter
00001430  3013                     566          MOVE.W  (A3),D0         Get data at this address in D0
00001432  6190                     567          BSR     OUT4X           and print it
00001434  47EB 0002                568          LEA.L   2(A3),A3        Point to next address to display
00001438  201F                     569          MOVE.L  (A7)+,D0        Restore D0
0000143A  4E75                     570          RTS
0000143C                           571   
0000143C  1F00                     572  PSPACE  MOVE.B  D0,-(A7)        Print a single space
0000143E  103C 0020                573          MOVE.B  #SPACE,D0
00001442  6100 0298                574          BSR     PUTCHAR
00001446  101F                     575          MOVE.B  (A7)+,D0
00001448  4E75                     576          RTS
0000144A                           577   *=============================================================================
0000144A                           578  *   LOAD        Loads data formatted in hexadecimal "S" format from Port 2
0000144A                           579  *               NOTE - I/O is automatically redirected to the aux port for
0000144A                           580  *               loader functions. S1 or S2 records accepted
0000144A                           581  _LOAD
0000144A  2F2E 0116                582  LOAD    MOVE.L  CN_OVEC(A6),-(A7)   Save current output device name
0000144E  2F2E 0112                583          MOVE.L  CN_IVEC(A6),-(A7)   Save current input device name
00001452  522E 010A                584          ADD.B   #1,ECHO(A6)             Turn off character echo
00001456  6100 FD22                585          BSR     NEWLINE                 Send newline to host
0000145A  6100 015A                586          BSR     DELAY                   Wait for host to "settle"
0000145E  6100 0156                587          BSR     DELAY
00001462  286E 0102                588          MOVE.L  BUFFPT(A6),A4           Any string in the line buffer is
00001466  101C                     589  LOAD1   MOVE.B  (A4)+,D0                transmitted to the host computer
00001468  6100 0272                590          BSR     PUTCHAR                 before the loading begins
0000146C  B03C 000D                591          CMP.B   #CR,D0                  Read from the buffer until EOL
00001470  66F4                     592          BNE     LOAD1
00001472  6100 FD06                593          BSR     NEWLINE                 Send newline before loading
00001476  6100 021C                594  LOAD2   BSR     GETCHAR                 Records from the host must begin
0000147A  B03C 0053                595          CMP.B   #'S',D0                 with S1/S2 (data) or S9/S8 (term)
0000147E  66F6                     596          BNE.S   LOAD2                   Repeat GETCHAR until char = "S"
00001480  6100 0212                597          BSR     GETCHAR                 Get character after "S"
00001484  B03C 0039                598          CMP.B   #'9',D0                 Test for the two terminators S9/S8
00001488  6706                     599          BEQ.S   LOAD3                   If S9 record then exit else test
0000148A  B03C 0038                600          CMP.B   #'8',D0                 for S8 terminator. Fall through to
0000148E  662A                     601          BNE.S   LOAD6                   exit on S8 else continue search
00001490  =00001490                602  LOAD3   EQU     *                       Exit point from LOAD
00001490  2D5F 0112                603          MOVE.L  (A7)+,CN_IVEC(A6)   Clean up by restoring input device
00001494  2D5F 0116                604          MOVE.L  (A7)+,CN_OVEC(A6)   and output device name
00001498  422E 010A                605          CLR.B   ECHO(A6)                Restore input character echo
0000149C  0807 0000                606          BTST    #0,D7                   Test for input errors
000014A0  6708                     607          BEQ.S   LOAD4                   If no I/P error then look at checksum
000014A2  49FA 0993                608          LEA.L   ERMES1(PC),A4           Else point to error message
000014A6  6100 FCE2                609          BSR     PSTRING                 Print it
000014AA  0807 0003                610  LOAD4   BTST    #3,D7                   Test for checksum error
000014AE  6708                     611          BEQ.S   LOAD5                   If clear then exit
000014B0  49FA 09B5                612          LEA.L   ERMES3(PC),A4           Else point to error message
000014B4  6100 FCD4                613          BSR     PSTRING                 Print it and return
000014B8  4E75                     614  LOAD5   RTS
000014BA                           615   
000014BA  B03C 0031                616  LOAD6   CMP.B   #'1',D0                 Test for S1 record
000014BE  671E                     617          BEQ.S   LOAD6A                  If S1 record then read it
000014C0  B03C 0032                618          CMP.B   #'2',D0                 Else test for S2 record
000014C4  66B0                     619          BNE.S   LOAD2                   Repeat until valid header found
000014C6  4203                     620          CLR.B   D3                      Read the S2 byte count and address,
000014C8  613C                     621          BSR.S   LOAD8                   clear the checksum
000014CA  5900                     622          SUB.B   #4,D0                   Calculate size of data field
000014CC  1400                     623          MOVE.B  D0,D2                   D2 contains data bytes to read
000014CE  4280                     624          CLR.L   D0                      Clear address accumulator
000014D0  6134                     625          BSR.S   LOAD8                   Read most sig byte of address
000014D2  E180                     626          ASL.L   #8,D0                   Move it one byte left
000014D4  6130                     627          BSR.S   LOAD8                   Read the middle byte of address
000014D6  E180                     628          ASL.L   #8,D0                   Move it one byte left
000014D8  612C                     629          BSR.S   LOAD8                   Read least sig byte of address
000014DA  2440                     630          MOVE.L  D0,A2                   A2 points to destination of record
000014DC  6012                     631          BRA.S   LOAD7                   Skip past S1 header loader
000014DE  4203                     632  LOAD6A  CLR.B   D3                      S1 record found - clear checksum
000014E0  6124                     633          BSR.S   LOAD8                   Get byte and update checksum
000014E2  5700                     634          SUB.B   #3,D0                   Subtract 3 from record length
000014E4  1400                     635          MOVE.B  D0,D2                 Save byte count in D2
000014E6  4280                     636          CLR.L   D0                      Clear address accumulator
000014E8  611C                     637          BSR.S   LOAD8                   Get MS byte of load address
000014EA  E180                     638          ASL.L   #8,D0                   Move it to MS position
000014EC  6118                     639          BSR.S   LOAD8                   Get LS byte in D2
000014EE  2440                     640          MOVE.L  D0,A2                   A2 points to destination of data
000014F0  6114                     641  LOAD7   BSR.S   LOAD8                   Get byte of data for loading
000014F2  14C0                     642          MOVE.B  D0,(A2)+                Store it
000014F4  5302                     643          SUB.B   #1,D2                   Decrement byte counter
000014F6  66F8                     644          BNE     LOAD7                   Repeat until count = 0
000014F8  610C                     645          BSR.S   LOAD8                   Read checksum
000014FA  5203                     646          ADD.B   #1,D3                   Add 1 to total checksum
000014FC  6700 FF78                647          BEQ     LOAD2                   If zero then start next record
00001500  8E3C 0008                648          OR.B    #%00001000,D7           Else set checksum error bit,
00001504  608A                     649          BRA     LOAD3                   restore I/O devices and return
00001506                           650  *
00001506  6100 FE3A                651  LOAD8   BSR     BYTE                    Get a byte
0000150A  D600                     652          ADD.B   D0,D3                   Update checksum
0000150C  4E75                     653          RTS                             and return
0000150E                           654   *=============================================================================
0000150E                           655  *   DUMP        Transmit S1 formatted records to host computer
0000150E                           656  *               A3 = Starting address of data block
0000150E                           657  *               A2 = End address of data block
0000150E                           658  *               D1 = Checksum, D2 = current record length
0000150E                           659   
0000150E  6100 0096                660  DUMP    BSR     RANGE                   Get start and end address
00001512  4A07                     661          TST.B   D7                      Test for input error
00001514  6708                     662          BEQ.S   DUMP1                   If no error then continue
00001516  49FA 091F                663          LEA.L   ERMES1(PC),A4           Else point to error message,
0000151A  6000 FC6E                664          BRA     PSTRING                 print it and return
0000151E  B08B                     665  DUMP1   CMP.L   A3,D0                   Compare start and end addresses
00001520  6A08                     666          BPL.S   DUMP2                   If positive then start < end
00001522  49FA 0993                667          LEA.L   ERMES7(PC),A4           Else print error message
00001526  6000 FC62                668          BRA     PSTRING                 and return
0000152A  2F2E 0116                669  DUMP2   MOVE.L  CN_OVEC(A6),-(A7)   Save name of current output device
0000152E  2D7C 00001D32 0116       670          MOVE.L  #DCB2,CN_OVEC(A6)   Set up Port as output device
00001536  6100 FC42                671          BSR     NEWLINE                 Send newline to host and wait
0000153A  617A                     672          BSR.S   DELAY
0000153C  286E 0102                673          MOVE.L  BUFFPT(A6),A4           Before dumping, send any string
00001540  101C                     674  DUMP3   MOVE.B  (A4)+,D0                in the input buffer to the host
00001542  6100 0198                675          BSR     PUTCHAR                 Repeat
00001546  B03C 000D                676          CMP.B   #CR,D0                  Transmit char from buffer to host
0000154A  66F4                     677          BNE     DUMP3                   Until char = C/R
0000154C  6100 FC2C                678          BSR     NEWLINE
00001550  6164                     679          BSR.S   DELAY                   Allow time for host to settle
00001552  528A                     680          ADDQ.L  #1,A2                   A2 contains length of record + 1
00001554  240A                     681  DUMP4   MOVE.L  A2,D2            D2 points to end address
00001556  948B                     682          SUB.L   A3,D2                   D2 contains bytes left to print
00001558  B4BC 00000011            683          CMP.L   #17,D2                  If this is not a full record of 16
0000155E  6502                     684          BCS.S   DUMP5                   then load D2 with record size
00001560  7410                     685          MOVEQ   #16,D2                  Else preset byte count to 16
00001562  49FA 07EB                686  DUMP5   LEA.L   HEADER(PC),A4           Point to record header
00001566  6100 FC22                687          BSR     PSTRING                 Print header
0000156A  4201                     688          CLR.B   D1                      Clear checksum
0000156C  1002                     689          MOVE.B  D2,D0                   Move record length to output register
0000156E  5600                     690          ADD.B   #3,D0                   Length includes address + count
00001570  612E                     691          BSR.S   DUMP7                   Print number of bytes in record
00001572  200B                     692          MOVE.L  A3,D0                   Get start address to be printed
00001574  E158                     693          ROL.W   #8,D0            Get MS byte in LS position
00001576  6128                     694          BSR.S   DUMP7                   Print MS byte of address
00001578  E058                     695          ROR.W   #8,D0                   Restore LS byte
0000157A  6124                     696          BSR.S   DUMP7                   Print LS byte of address
0000157C  101B                     697  DUMP6   MOVE.B  (A3)+,D0                Get data byte to be printed
0000157E  6120                     698          BSR.S   DUMP7                   Print it
00001580  5302                     699          SUB.B   #1,D2                   Decrement byte count
00001582  66F8                     700          BNE     DUMP6                   Repeat until all this record printed
00001584  4601                     701          NOT.B   D1                      Complement checksum
00001586  1001                     702          MOVE.B  D1,D0                   Move to output register
00001588  6116                     703          BSR.S   DUMP7                   Print checksum
0000158A  6100 FBEE                704          BSR     NEWLINE
0000158E  B7CA                     705          CMP.L   A2,A3                   Have all records been printed?
00001590  66C2                     706          BNE     DUMP4                   Repeat until all done
00001592  49FA 07C1                707          LEA.L   TAIL(PC),A4             Point to message tail (S9 record)
00001596  6100 FBF2                708          BSR     PSTRING                 Print it
0000159A  2D5F 0116                709          MOVE.L  (A7)+,CN_OVEC(A6)   Restore name of output device
0000159E  4E75                     710          RTS                             and return
000015A0                           711   
000015A0  D200                     712  DUMP7   ADD.B   D0,D1                 Update checksum, transmit byte
000015A2  6000 FE18                713          BRA     OUT2X                   to host and return
000015A6                           714   
000015A6  =000015A6                715  RANGE   EQU     *                       Get the range of addresses to be
000015A6  4207                     716          CLR.B   D7                      transmitted from the buffer
000015A8  6100 FDB4                717          BSR     PARAM                 Get starting address
000015AC  2640                     718          MOVE.L  D0,A3                   Set up start address in A3
000015AE  6100 FDAE                719          BSR     PARAM                   Get end address
000015B2  2440                     720          MOVE.L  D0,A2                   Set up end address in A2
000015B4  4E75                     721          RTS
000015B6                           722   
000015B6  =000015B6                723  DELAY   EQU     *                       Provide a time delay for the host
000015B6  48E7 8008                724          MOVEM.L D0/A4,-(A7)             to settle. Save working registers
000015BA  203C 00004000            725          MOVE.L  #$4000,D0               Set up delay constant
000015C0  5380                     726  DELAY1  SUB.L   #1,D0                   Count down      (8 clk cycles)
000015C2  66FC                     727          BNE     DELAY1                  Repeat until zero  (10 clk cycles)
000015C4  4CDF 1001                728          MOVEM.L (A7)+,D0/A4             Restore working registers
000015C8                           729   *=============================================================================
000015C8                           730  *   This routine sets up the system DCBs in RAM using the information
000015C8                           731  *   stored in ROM at address DCB_LST. This is called at initialization.
000015C8                           732  *   CN_IVEC contains the name "DCB1" and IO_VEC the name "DCB2"
000015C8                           733   
000015C8  48E7 F0F0                734  SET_DCB MOVEM.L A0-A3/D0-D3,-(A7)   Save all working registers
000015CC  41EE 0194                735          LEA.L   FIRST(A6),A0            Pointer to first DCB destination in RAM
000015D0  43FA 074E                736          LEA.L   DCB_LST(PC),A1          A1 points to DCB info block in ROM
000015D4  303C 0001                737          MOVE.W  #1,D0                   2 DCBs to set up
000015D8  323C 000F                738  ST_DCB1 MOVE.W  #15,D1                  16 bytes to move per DCB header
000015DC  10D9                     739  ST_DCB2 MOVE.B  (A1)+,(A0)+             Move the 16 bytes of a DCB header
000015DE  51C9 FFFC                740          DBRA    D1,ST_DCB2              from ROM to RAM
000015E2  3619                     741          MOVE.W  (A1)+,D3                Get size of parameter block (bytes)
000015E4  3083                     742          MOVE.W  D3,(A0)                 Store size in DCB in RAM
000015E6  41F0 3002                743          LEA.L   2(A0,D3.W),A0           A0 points to tail of DCB in RAM
000015EA  47E8 0004                744          LEA.L   4(A0),A3                A3 contains address of next DCB in RAM
000015EE  208B                     745          MOVE.L  A3,(A0)                 Store pointer to next DCB in this DCB
000015F0  41D3                     746          LEA.L   (A3),A0                 A0 now points at next DCB in RAM
000015F2  51C8 FFE4                747          DBRA    D0,ST_DCB1              Repeat until all DCBs set up
000015F6  47EB FFFC                748          LEA.L   -4(A3),A3               Adjust A3 to point to last DCB pointer
000015FA  4293                     749          CLR.L   (A3)                    and force last pointer to zero
000015FC  2D7C 00001D20 0112       750          MOVE.L  #DCB1,CN_IVEC(A6)   Set up vector to console input DCB
00001604  2D7C 00001D32 0116       751          MOVE.L  #DCB2,CN_OVEC(A6)   Set up vector to console output DCB
0000160C  4CDF 0F0F                752          MOVEM.L (A7)+,A0-A3/D0-D3   Restore registers
00001610  4E75                     753          RTS
00001612                           754   *=============================================================================
00001612                           755  *   IO_REQ handles all input/output transactions. A0 points to DCB on
00001612                           756  *   entry. IO_REQ calls the device driver whose address is in the DCB.
00001612                           757   
00001612  48E7 00C0                758  IO_REQ  MOVEM.L A0-A1,-(A7)     Save working registers
00001616  43E8 0008                759          LEA.L   8(A0),A1        A1 points to device handler field in DCB
0000161A  2251                     760          MOVE.L  (A1),A1         A1 contains device handler address
0000161C  4E91                     761          JSR     (A1)            Call device handler
0000161E  4CDF 0300                762          MOVEM.L (A7)+,A0-A1     Restore working registers
00001622  4E75                     763          RTS
00001624                           764   *=============================================================================
00001624                           765  *   CON_IN handles input from the console device
00001624                           766  *   This is the device driver used by DCB1. Exit with input in D0
00001624                           767   
00001624  48E7 4040                768  CON_IN  MOVEM.L D1/A1,-(A7)     Save working registers
00001628  43E8 000C                769          LEA.L   12(A0),A1       Get pointer to ACIA from DCB
0000162C  2251                     770          MOVE.L  (A1),A1         Get address of ACIA in A1
0000162E  4228 0013                771          CLR.B   19(A0)          Clear logical error in DCB
00001632  1211                     772  CON_I1  MOVE.B  (A1),D1         Read ACIA status
00001634  0801 0000                773          BTST    #0,D1           Test RDRF
00001638  67F8                     774          BEQ     CON_I1          Repeat until RDRF true
0000163A  1141 0012                775          MOVE.B  D1,18(A0)       Store physical status in DCB
0000163E  C23C 00F4                776          AND.B   #%011110100,D1  Mask to input error bits
00001642  6706                     777          BEQ.S   CON_I2          If no error then skip update
00001644  117C 0001 0013           778          MOVE.B  #1,19(A0)       Else update logical error
0000164A  1029 0002                779  CON_I2  MOVE.B  2(A1),D0        Read input from ACIA
0000164E  4CDF 0202                780          MOVEM.L (A7)+,A1/D1     Restore working registers
00001652  4E75                     781          RTS
00001654                           782   *=============================================================================
00001654                           783  *   This is the device driver used by DCB2. Output in D0
00001654                           784  *   The output can be halted or suspended
00001654                           785   
00001654  48E7 6040                786  CON_OUT MOVEM.L A1/D1-D2,-(A7)  Save working registers
00001658  43E8 000C                787          LEA.L   12(A0),A1       Get pointer to ACIA from DCB
0000165C  2251                     788          MOVE.L  (A1),A1         Get address of ACIA in A1
0000165E  4228 0013                789          CLR.B   19(A0)          Clear logical error in DCB
00001662  1211                     790  CON_OT1 MOVE.B  (A1),D1         Read ACIA status
00001664  0801 0000                791          BTST    #0,D1           Test RDRF bit (any input?)
00001668  6716                     792          BEQ.S   CON_OT3         If no input then test output status
0000166A  1429 0002                793          MOVE.B  2(A1),D2        Else read the input
0000166E  C43C 005F                794          AND.B   #%01011111,D2   Strip parity and bit 5
00001672  B43C 0057                795          CMP.B   #WAIT,D2        and test for a wait condition
00001676  6608                     796          BNE.S   CON_OT3         If not wait then ignore and test O/P
00001678  1411                     797  CON_OT2 MOVE.B  (A1),D2         Else read ACIA status register
0000167A  0802 0000                798          BTST    #0,D2           and poll ACIA until next char received
0000167E  67F8                     799          BEQ     CON_OT2
00001680  0801 0001                800  CON_OT3 BTST    #1,D1           Repeat
00001684  67DC                     801          BEQ     CON_OT1         until ACIA Tx ready
00001686  1141 0012                802          MOVE.B  D1,18(A0)       Store status in DCB physical error
0000168A  1340 0002                803          MOVE.B  D0,2(A1)        Transmit output
0000168E  4CDF 0206                804          MOVEM.L (A7)+,A1/D1-D2  Restore working registers
00001692  4E75                     805          RTS
00001694                           806   
00001694                           807   *============================================================================
00001694                           808  *   GETCHAR gets a character from the console device
00001694                           809  *   This is the main input routine and uses the device whose name
00001694                           810  *   is stored in CN_IVEC. Changing this name redirects input.
00001694                           811   
00001694  2F08                     812  GETCHAR MOVE.L  A0,-(A7)        Save working register
00001696  206E 0112                813          MOVE.L  CN_IVEC(A6),A0  A0 points to name of console DCB
0000169A  6150                     814          BSR.S   IO_OPEN         Open console (get DCB address in A0)
0000169C  0807 0003                815          BTST    #3,D7           D7(3) set if open error
000016A0  6636                     816          BNE.S   GETCH3          If error then exit now
000016A2  6100 FF6E                817          BSR     IO_REQ          Else execute I/O transaction
000016A6  C03C 007F                818          AND.B   #$7F,D0         Strip msb of input
000016AA  4A2E 010C                819          TST.B   U_CASE(A6)      Test for upper -> lower case conversion
000016AE  660A                     820          BNE.S   GETCH2          If flag not zero do not convert case
000016B0  0800 0006                821          BTST    #6,D0           Test input for lower case
000016B4  6704                     822          BEQ.S   GETCH2          If upper case then skip conversion
000016B6  C03C 00DF                823          AND.B   #%11011111,D0   Else clear bit 5 for upper case conv
000016BA  4A2E 010A                824  GETCH2  TST.B   ECHO(A6)        Do we need to echo the input?
000016BE  6618                     825          BNE.S   GETCH3          If ECHO not zero then no echo
000016C0  4A2E 010B                826          TST.B   STAR(A6)        Test if echoing an * for a password
000016C4  6700 0010                827          BEQ     SKIP            Branch to standard echo if not a password
000016C8  3F00                     828          MOVE    D0,-(A7)        Save input char to stack
000016CA  103C 002A                829          MOVE.B  #42,D0          load an * char
000016CE  610C                     830          BSR.S   PUTCHAR         Echo the *
000016D0  301F                     831          MOVE    (A7)+,D0        Retrieve the input char from stack
000016D2  6000 0004                832          BRA     GETCH3          Goto exit
000016D6  6104                     833  SKIP    BSR.S   PUTCHAR         Else echo the input
000016D8  205F                     834  GETCH3  MOVE.L  (A7)+,A0        Restore working register
000016DA  4E75                     835          RTS                     and return
000016DC                           836   *=============================================================================
000016DC                           837  *   PUTCHAR sends a character to the console device
000016DC                           838  *   The name of the output device is in CN_OVEC.
000016DC                           839   
000016DC  2F08                     840  PUTCHAR MOVE.L  A0,-(A7)        Save working register
000016DE  206E 0116                841          MOVE.L  CN_OVEC(A6),A0  A0 points to name of console output
000016E2  6108                     842          BSR.S   IO_OPEN         Open console (Get address of DCB)
000016E4  6100 FF2C                843          BSR     IO_REQ          Perform output with DCB pointed at by A0
000016E8  205F                     844          MOVE.L  (A7)+,A0        Restore working register
000016EA  4E75                     845          RTS
000016EC                           846   *=============================================================================
000016EC                           847  *   Open - opens a DCB for input or output. IO_OPEN converts the
000016EC                           848  *   name pointed at by A0 into the address of the DCB pointed at
000016EC                           849  *   by A0. Bit 3 of D7 is set to zero if DCB not found
000016EC                           850   
000016EC  48E7 F870                851  IO_OPEN MOVEM.L A1-A3/D0-D4,-(A7)   Save working registers
000016F0  43EE 0194                852          LEA.L   FIRST(A6),A1            A1 points to first DCB in chain in RAM
000016F4  45D1                     853  OPEN1   LEA.L   (A1),A2                 A2 = temp copy of pointer to DCB
000016F6  47D0                     854          LEA.L   (A0),A3                 A3 = temp copy of pointer to DCB name
000016F8  303C 0007                855          MOVE.W  #7,D0               Up to 8 chars of DCB name to match
000016FC  181A                     856  OPEN2   MOVE.B  (A2)+,D4                Compare DCB name with string
000016FE  B81B                     857          CMP.B   (A3)+,D4
00001700  6608                     858          BNE.S   OPEN3                   If no match try next DCB
00001702  51C8 FFF8                859          DBRA    D0,OPEN2                Else repeat until all chars matched
00001706  41D1                     860          LEA.L   (A1),A0                 Success - move this DCB address to A0
00001708  6016                     861          BRA.S   OPEN4                   and return
0000170A  =0000170A                862  OPEN3   EQU     *                       Fail - calculate address of next DCB
0000170A  3229 0010                863          MOVE.W  16(A1),D1               Get parameter block size of DCB
0000170E  43F1 1012                864          LEA.L   18(A1,D1.W),A1          A1 points to pointer to next DCB
00001712  2251                     865          MOVE.L  (A1),A1                 A1 now points to next DCB
00001714  B3FC 00000000            866          CMP.L   #0,A1                   Test for end of DCB chain
0000171A  66D8                     867          BNE     OPEN1                   If not end of chain then try next DCB
0000171C  8E3C 0008                868          OR.B    #8,D7                   Else set error flag and return
00001720  4CDF 0E1F                869  OPEN4   MOVEM.L (A7)+,A1-A3/D0-D4   Restore working registers
00001724  4E75                     870          RTS
00001726                           871   *=============================================================================
00001726                           872  *   This subroutine clears the breakpoint table in ram
00001726                           873   
00001726  303C 0007                874  CLR_BPT MOVE.W  #7,D0           Clear the breakpoint table
0000172A  41EE 0164                875          LEA.L   BP_TAB(A6),A0   Point to table
0000172E  4298                     876  LBPT    CLR.L   (A0)+           Clear an address entry
00001730  4258                     877          CLR.W   (A0)+           Clear the corresponding data
00001732  51C8 FFFA                878          DBRA    D0,LBPT         Repeat until all 8 cleared
00001736  4E75                     879          RTS
00001738                           880   *=============================================================================
00001738  =00001738                881  TRAP_0  EQU     *               User links to  MODWARE via TRAP #0
00001738  B23C 0000                882          CMP.B   #0,D1           D1 = 0 = Get character
0000173C  6606                     883          BNE.S   FUNC1
0000173E  6100 FF54                884          BSR     GETCHAR
00001742  4E73                     885          RTE
00001744  B23C 0001                886  FUNC1   CMP.B   #1,D1           D1 = 1 = Print character
00001748  6604                     887          BNE.S   FUNC2
0000174A  6190                     888          BSR     PUTCHAR
0000174C  4E73                     889          RTE
0000174E  B23C 0002                890  FUNC2   CMP.B   #2,D1           D1 = 2 = Newline
00001752  6606                     891          BNE.S   FUNC3
00001754  6100 FA24                892          BSR     NEWLINE
00001758  4E73                     893          RTE
0000175A  B23C 0003                894  FUNC3   CMP.B   #3,D1           D1 = 3 = Get parameter from buffer
0000175E  6606                     895          BNE.S   FUNC4
00001760  6100 FBFC                896          BSR     PARAM
00001764  4E73                     897          RTE
00001766  B23C 0004                898  FUNC4   CMP.B   #4,D1           D1 = 4 = Print string pointed at by A4
0000176A  6606                     899          BNE.S   FUNC5
0000176C  6100 FA1C                900          BSR     PSTRING
00001770  4E73                     901          RTE
00001772  B23C 0005                902  FUNC5   CMP.B   #5,D1           D1 = 5 = Get a hex character
00001776  6606                     903          BNE.S   FUNC6
00001778  6100 FBAA                904          BSR     HEX
0000177C  4E73                     905          RTE
0000177E  B23C 0006                906  FUNC6   CMP.B   #6,D1           D1 = 6 = Get a hex byte
00001782  6606                     907          BNE.S   FUNC7
00001784  6100 FBBC                908          BSR     BYTE
00001788  4E73                     909          RTE
0000178A  B23C 0007                910  FUNC7   CMP.B   #7,D1           D1 = 7 = Get a word
0000178E  6606                     911          BNE.S   FUNC8
00001790  6100 FBC0                912          BSR     WORD
00001794  4E73                     913          RTE
00001796  B23C 0008                914  FUNC8   CMP.B   #8,D1           D1 = 8 = Get a longword
0000179A  6606                     915          BNE.S   FUNC9
0000179C  6100 FBBA                916          BSR     LONGWD
000017A0  4E73                     917          RTE
000017A2  B23C 0009                918  FUNC9   CMP.B   #9,D1           D1 = 9 = Output hex byte
000017A6  6606                     919          BNE.S   FUNC10
000017A8  6100 FC12                920          BSR     OUT2X
000017AC  4E73                     921          RTE
000017AE  B23C 000A                922  FUNC10  CMP.B   #10,D1          D1 = 10 = Output hex word
000017B2  6606                     923          BNE.S   FUNC11
000017B4  6100 FC0E                924          BSR     OUT4X
000017B8  4E73                     925          RTE
000017BA  B23C 000B                926  FUNC11  CMP.B   #11,D1          D1 = 11 = Output hex longword
000017BE  6606                     927          BNE.S   FUNC12
000017C0  6100 FC0A                928          BSR     OUT8X
000017C4  4E73                     929          RTE
000017C6  B23C 000C                930  FUNC12  CMP.B   #12,D1          D1 = 12 = Print a space
000017CA  6606                     931          BNE.S   FUNC13
000017CC  6100 FC6E                932          BSR     PSPACE
000017D0  4E73                     933          RTE
000017D2  B23C 000D                934  FUNC13  CMP.B   #13,D1          D1 = 13 = Get a line of text into
000017D6  6606                     935          BNE.S   FUNC14          the line buffer
000017D8  6100 F9C6                936          BSR     GETLINE
000017DC  4E73                     937          RTE
000017DE  B23C 000E                938  FUNC14  CMP.B   #14,D1          D1 = 14 = Tidy up the line in the
000017E2  6606                     939          BNE.S   FUNC15          line buffer by removing leading
000017E4  6100 FA90                940          BSR     TIDY            leading and multiple embedded spaces
000017E8  4E73                     941          RTE
000017EA  B23C 000F                942  FUNC15  CMP.B   #15,D1          D1 = 15 = Execute the command in
000017EE  6606                     943          BNE.S   FUNC16          the line buffer
000017F0  6100 FAC6                944          BSR     EXECUTE
000017F4  4E73                     945          RTE
000017F6  B23C 0010                946  FUNC16  CMP.B   #16,D1          D1 = 16 = Call RESTORE to transfer
000017FA  6606                     947          BNE.S   FUNC17          the registers in TSK_T to the 68000
000017FC  6100 017E                948          BSR     RESTORE         and therefore execute a program
00001800  4E73                     949          RTE
00001802  4E73                     950  FUNC17  RTE
00001804                           951   *=============================================================================
00001804                           952  *   Display exception frame (D0 - D7, A0 - A6, USP, SSP, SR, PC)
00001804                           953  *   EX_DIS prints registers saved after a breakpoint or exception
00001804                           954  *   The registers are saved in TSK_T
00001804                           955   
00001804  4BEE 011A                956  EX_DIS  LEA.L   TSK_T(A6),A5    A5 points to display frame
00001808  49FA 056C                957          LEA.L   MES3(PC),A4     Point to heading
0000180C  6100 F98C                958          BSR     HEADING         and print it
00001810  3C3C 0007                959          MOVE.W  #7,D6           8 pairs of registers to display
00001814  4205                     960          CLR.B   D5              D5 is the line counter
00001816  1005                     961  EX_D1   MOVE.B  D5,D0           Put current register number in D0
00001818  6100 FB88                962          BSR     OUT1X           and print it
0000181C  6100 FC1E                963          BSR     PSPACE          and a space
00001820  5205                     964          ADD.B   #1,D5           Update counter for next pair
00001822  2015                     965          MOVE.L  (A5),D0         Get data register to be displayed
00001824  6100 FBA6                966          BSR     OUT8X           from the frame and print it
00001828  49FA 056A                967          LEA.L   MES4(PC),A4     Print string of spaces
0000182C  6100 F95C                968          BSR.L   PSTRING         between data and address registers
00001830  202D 0020                969          MOVE.L  32(A5),D0       Get address register to be displayed
00001834  6100 FB96                970          BSR     OUT8X           which is 32 bytes on from data reg
00001838  6100 F940                971          BSR     NEWLINE
0000183C  4BED 0004                972          LEA.L   4(A5),A5        Point to next pair (ie Di, Ai)
00001840  51CE FFD4                973          DBRA    D6,EX_D1        Repeat until all displayed
00001844  4BED 0020                974          LEA.L   32(A5),A5       Adjust pointer by 8 longwords
00001848  6100 F930                975          BSR     NEWLINE         to point to SSP
0000184C  49FA 051F                976          LEA.L   MES2A(PC),A4    Point to "SS ="
00001850  6100 F938                977          BSR     PSTRING         Print it
00001854  201D                     978          MOVE.L  (A5)+,D0        Get SSP from frame
00001856  6100 FB74                979          BSR     OUT8X           and display it
0000185A  6100 F91E                980          BSR     NEWLINE
0000185E  49FA 04FB                981          LEA.L   MES1(PC),A4     Point to 'SR ='
00001862  6100 F926                982          BSR     PSTRING         Print it
00001866  301D                     983          MOVE.W  (A5)+,D0        Get status register
00001868  6100 FB5A                984          BSR     OUT4X           Display status
0000186C  6100 F90C                985          BSR     NEWLINE
00001870  49FA 04F2                986          LEA.L   MES2(PC),A4     Point to 'PC ='
00001874  6100 F914                987          BSR     PSTRING         Print it
00001878  201D                     988          MOVE.L  (A5)+,D0        Get PC
0000187A  6100 FB50                989          BSR     OUT8X           Display PC
0000187E  6000 F8FA                990          BRA     NEWLINE         Newline and return
00001882                           991   *=============================================================================
00001882                           992  *   Exception handling routines
00001882                           993   
00001882  =00001882                994  IL_ER   EQU     *               Illegal instruction exception
00001882  2F0C                     995          MOVE.L  A4,-(A7)        Save A4
00001884  49FA 0535                996          LEA.L   MES10(PC),A4    Point to heading
00001888  6100 F910                997          BSR     HEADING         Print it
0000188C  285F                     998          MOVE.L  (A7)+,A4        Restore A4
0000188E  4EB9 0000192A            999          JSR     GROUP2          Save registers in display frame
00001894  6100 FF6E               1000          BSR     EX_DIS          Display registers saved in frame
00001898  6000 038E               1001          BRA     _main           Return to monitor
0000189C                          1002  *
0000189C  =0000189C               1003  BUS_ER  EQU     *               Bus error (group 1) exception
0000189C  2F0C                    1004          MOVE.L  A4,-(A7)        Save A4
0000189E  49FA 04FB               1005          LEA.L   MES8(PC),A4     Point to heading
000018A2  6100 F8F6               1006          BSR     HEADING         Print it
000018A6  285F                    1007          MOVE.L  (A7)+,A4        Restore A4
000018A8  6100 FF5A               1008          BSR     EX_DIS          Display registers saved in frame
000018AC  6000 037A               1009          BRA     _main           Return to monitor
000018B0                          1010  *
000018B0  =000018B0               1011  ADD_ER  EQU     *               Address error (group 1) exception
000018B0  2F0C                    1012          MOVE.L  A4,-(A7)        Save A4
000018B2  49FA 04F5               1013          LEA.L   MES9(PC),A4     Point to heading
000018B6  6100 F8E2               1014          BSR     HEADING         Print it
000018BA  285F                    1015          MOVE.L  (A7)+,A4        Restore A4
000018BC  6100 FF46               1016          BSR     EX_DIS        Display registers saved in frame
000018C0  6000 0366               1017          BRA     _main           Return to monitor
000018C4                          1018  *
000018C4  =000018C4               1019  PRI_ER  EQU     *               Privilege violation error
000018C4  2F0C                    1020          MOVE.L  A4,-(A7)        Save A4
000018C6  49FA 05FC               1021          LEA.L   ERMES8(PC),A4   Point to heading
000018CA  6100 F8CE               1022          BSR     HEADING         Print it
000018CE  285F                    1023          MOVE.L  (A7)+,A4        Restore A4
000018D0  6100 FF32               1024          BSR     EX_DIS          Display registers saved in frame
000018D4  6000 0352               1025          BRA     _main           Return to monitor
000018D8                          1026  *
000018D8  =000018D8               1027  BRKPT   EQU     *                       Deal with breakpoint
000018D8  48E7 FFFE               1028          MOVEM.L D0-D7/A0-A6,-(A7)   Save all registers
000018DC  6100 0180               1029          BSR     BR_CLR                  Clear breakpoints in code
000018E0  4CDF 7FFF               1030          MOVEM.L (A7)+,D0-D7/A0-A6   Restore registers
000018E4  6144                    1031          BSR.S   GROUP2                  Treat as group 2 exception
000018E6  49FA 04E9               1032          LEA.L   MES11(PC),A4            Point to heading
000018EA  6100 F8AE               1033          BSR     HEADING                 Print it
000018EE  6100 FF14               1034          BSR     EX_DIS                  Display saved registers
000018F2  6000 0334               1035          BRA     _main                   Return to monitor
000018F6                          1036   *=============================================================================
000018F6                          1037  *   GROUP1 is called by address and bus error exceptions
000018F6                          1038  *   These are "turned into group 2" exceptions (eg TRAP)
000018F6                          1039  *   by modifying the stack frame saved by a group 1 exception
000018F6                          1040   
000018F6  48E7 8080               1041  GROUP1  MOVEM.L D0/A0,-(A7)             Save working registers
000018FA  206F 0012               1042          MOVE.L  18(A7),A0           Get PC from group 1 stack frame
000018FE  302F 000E               1043          MOVE.W  14(A7),D0               Get instruction from stack frame
00001902  B060                    1044          CMP.W   -(A0),D0                Now backtrack to find the "correct PC"
00001904  670E                    1045          BEQ.S   GROUP1A                 by matching the op-code on the stack
00001906  B060                    1046          CMP.W   -(A0),D0                with the code in the region of the
00001908  670A                    1047          BEQ.S   GROUP1A                 PC on the stack
0000190A  B060                    1048          CMP.W   -(A0),D0
0000190C  6706                    1049          BEQ.S   GROUP1A
0000190E  B060                    1050          CMP.W   -(A0),D0
00001910  6702                    1051          BEQ.S   GROUP1A
00001912  5588                    1052          SUBQ.L  #2,A0
00001914  2F48 0012               1053  GROUP1A MOVE.L  A0,18(A7)               Restore modified PC to stack frame
00001918  4CDF 0101               1054          MOVEM.L (A7)+,D0/A0         Restore working registers
0000191C  4FEF 0008               1055          LEA.L   8(A7),A7                Adjust stack pointer to group 1 type
00001920  6108                    1056          BSR.S   GROUP2                  Now treat as group 1 exception
00001922  6100 FEE0               1057          BSR     EX_DIS                  Display contents of exception frame
00001926  6000 0300               1058          BRA     _main                   Exit to monitor - no RTE from group 2
0000192A                          1059  *
0000192A  =0000192A               1060  GROUP2  EQU     *                       Deal with group 2 exceptions
0000192A  48E7 FFFF               1061          MOVEM.L A0-A7/D0-D7,-(A7)   Save all registers on the stack
0000192E  303C 000E               1062          MOVE.W  #14,D0                  Transfer D0 - D7, A0 - A6 from
00001932  41EE 011A               1063          LEA.L   TSK_T(A6),A0            the stack to the display frame
00001936  20DF                    1064  GROUP2A MOVE.L  (A7)+,(A0)+             Move a register from stack to frame
00001938  51C8 FFFC               1065          DBRA    D0,GROUP2A              and repeat until D0-D7/A0-A6 moved
0000193C  4E6A                    1066          MOVE.L  USP,A2                  Get the user stack pointer and put it
0000193E  20CA                    1067          MOVE.L  A2,(A0)+                in the A7 position in the frame
00001940  201F                    1068          MOVE.L  (A7)+,D0                Now transfer the SSP to the frame,
00001942  0480 0000000A           1069          SUB.L   #10,D0                  remembering to account for the
00001948  20C0                    1070          MOVE.L  D0,(A0)+                data pushed on the stack to this point
0000194A  225F                    1071          MOVE.L  (A7)+,A1                Copy TOS (return address) to A1
0000194C  30DF                    1072          MOVE.W  (A7)+,(A0)+             Move SR to display frame
0000194E  201F                    1073          MOVE.L  (A7)+,D0                Get PC in D0
00001950  5580                    1074          SUBQ.L  #2,D0                   Move back to current instruction
00001952  20C0                    1075          MOVE.L  D0,(A0)+                Put adjusted PC in display frame
00001954  4ED1                    1076          JMP     (A1)                    Return from subroutine
00001956                          1077   *=============================================================================
00001956                          1078  *   GO executes a program either from a supplied address or
00001956                          1079  *   by using the data in the display frame
00001956                          1080  _GO
00001956  6100 FA06               1081  GO      BSR     PARAM                   Get entry address (if any)
0000195A  4A07                    1082          TST.B   D7                      Test for error in input
0000195C  6708                    1083          BEQ.S   GO1                     If D7 zero then OK
0000195E  49FA 04D7               1084          LEA.L   ERMES1(PC),A4           Else point to error message,
00001962  6000 F826               1085          BRA     PSTRING                 print it and return
00001966  4A80                    1086  GO1     TST.L   D0                      If no address entered then get
00001968  670A                    1087          BEQ.S   GO2                     address from display frame
0000196A  2D40 0160               1088          MOVE.L  D0,TSK_T+70(A6)         Else save address in display frame
0000196E  3D7C 0700 015E          1089          MOVE.W  #$0700,TSK_T+68(A6) Store dummy status in frame
00001974  6006                    1090  GO2     BRA.S   RESTORE                 Restore volatile environment and go
00001976                          1091  *
00001976  6100 007A               1092  GB      BSR     BR_SET                  Same as go but presets breakpoints
0000197A  60DA                    1093          BRA.S   GO                      Execute program
0000197C                          1094   *=============================================================================
0000197C                          1095  *   RESTORE moves the volatile environment from the display
0000197C                          1096  *   frame and transfers it to the 68000's registers. This
0000197C                          1097  *   re-runs a program suspended after an exception
0000197C                          1098   
0000197C  47EE 011A               1099  RESTORE LEA.L   TSK_T(A6),A3    A3 points to display frame
00001980  47EB 004A               1100          LEA.L   74(A3),A3       A3 now points to end of frame + 4
00001984  4FEF 0004               1101          LEA.L   4(A7),A7        Remove return address from stack
00001988  303C 0024               1102          MOVE.W  #36,D0          Counter for 37 words to be moved
0000198C  3F23                    1103  REST1   MOVE.W  -(A3),-(A7)     Move word from display frame to stack
0000198E  51C8 FFFC               1104          DBRA    D0,REST1        Repeat until entire frame moved
00001992  4CDF 00FF               1105          MOVEM.L (A7)+,D0-D7     Restore old data registers from stack
00001996  4CDF 7F00               1106          MOVEM.L (A7)+,A0-A6     Restore old address registers
0000199A  4FEF 0008               1107          LEA.L   8(A7),A7        Except SSP/USP - so adjust stack
0000199E  4E73                    1108          RTE                     Return from exception to run program
000019A0                          1109  *
000019A0  =000019A0               1110  TRACE   EQU     *               TRACE exception (rudimentary version)
000019A0  287A 043D               1111          MOVE.L  MES12(PC),A4    Point to heading
000019A4  6100 F7F4               1112          BSR     HEADING         Print it
000019A8  6100 FF4C               1113          BSR     GROUP1          Save volatile environment
000019AC  6100 FE56               1114          BSR     EX_DIS          Display it
000019B0  6000 0276               1115          BRA     _main           Return to monitor
000019B4                          1116   *=============================================================================
000019B4                          1117  *   Breakpoint routines: BR_GET gets the address of a breakpoint and
000019B4                          1118  *   puts it in the breakpoint table. It does not plant it in the code.
000019B4                          1119  *   BR_SET plants all breakpoints in the code. NOBR removes one or all
000019B4                          1120  *   breakpoints from the table. KILL removes breakpoints from the code.
000019B4                          1121   
000019B4  6100 F9A8               1122  BR_GET  BSR     PARAM           Get breakpoint address in table
000019B8  4A07                    1123          TST.B   D7              Test for input error
000019BA  6708                    1124          BEQ.S   BR_GET1         If no error then continue
000019BC  49FA 0479               1125          LEA.L   ERMES1(PC),A4   Else display error
000019C0  6000 F7C8               1126          BRA     PSTRING         and return
000019C4  47EE 0164               1127  BR_GET1 LEA.L   BP_TAB(A6),A3   A6 points to breakpoint table
000019C8  2A40                    1128          MOVE.L  D0,A5           Save new BP address in A5
000019CA  2C00                    1129          MOVE.L  D0,D6           and in D6 because D0 gets corrupted
000019CC  3A3C 0007               1130          MOVE.W  #7,D5           Eight entries to test
000019D0  201B                    1131  BR_GET2 MOVE.L  (A3)+,D0        Read entry from breakpoint table
000019D2  660C                    1132          BNE.S   BR_GET3         If not zero display existing BP
000019D4  4A86                    1133          TST.L   D6              Only store a non-zero breakpoint
000019D6  6710                    1134          BEQ.S   BR_GET4
000019D8  274D FFFC               1135          MOVE.L  A5,-4(A3)       Store new breakpoint in table
000019DC  3695                    1136          MOVE.W  (A5),(A3)       Save code at BP address in table
000019DE  4286                    1137          CLR.L   D6              Clear D6 to avoid repetition
000019E0  6100 F9EA               1138  BR_GET3 BSR     OUT8X           Display this breakpoint
000019E4  6100 F794               1139          BSR     NEWLINE
000019E8  47EB 0002               1140  BR_GET4 LEA.L   2(A3),A3        Step past stored op-code
000019EC  51CD FFE2               1141          DBRA    D5,BR_GET2      Repeat until all entries tested
000019F0  4E75                    1142          RTS                     Return
000019F2                          1143  *
000019F2  =000019F2               1144  BR_SET  EQU     *               Plant any breakpoints in user code
000019F2  41EE 0164               1145          LEA.L   BP_TAB(A6),A0   A0 points to BP table
000019F6  45EE 0160               1146          LEA.L   TSK_T+70(A6),A2 A2 points to PC in display frame
000019FA  2452                    1147          MOVE.L  (A2),A2         Now A2 contains value of PC
000019FC  303C 0007               1148          MOVE.W  #7,D0           Up to eight entries to plant
00001A00  2218                    1149  BR_SET1 MOVE.L  (A0)+,D1        Read breakpoint address from table
00001A02  670A                    1150          BEQ.S   BR_SET2         If zero then skip planting
00001A04  B28A                    1151          CMP.L   A2,D1           Don't want to plant BP at current PC
00001A06  6706                    1152          BEQ.S   BR_SET2         location, so skip planting if same
00001A08  2241                    1153          MOVE.L  D1,A1           Transfer BP address to address reg
00001A0A  32BC 4E4E               1154          MOVE.W  #TRAP_14,(A1)   Plant op-code for TRAP #14 in code
00001A0E  41E8 0002               1155  BR_SET2 LEA.L   2(A0),A0        Skip past op-code field in table
00001A12  51C8 FFEC               1156          DBRA    D0,BR_SET1      Repeat until all entries tested
00001A16  4E75                    1157          RTS
00001A18                          1158  *
00001A18  =00001A18               1159  NOBR    EQU     *               Clear one or all breakpoints
00001A18  6100 F944               1160          BSR     PARAM           Get BP address (if any)
00001A1C  4A07                    1161          TST.B   D7              Test for input error
00001A1E  6708                    1162          BEQ.S   NOBR1           If no error then skip abort
00001A20  49FA 0415               1163          LEA.L   ERMES1(PC),A4   Point to error message
00001A24  6000 F764               1164          BRA     PSTRING         Display it and return
00001A28  4A80                    1165  NOBR1   TST.L   D0              Test for null address (clear all)
00001A2A  6720                    1166          BEQ.S   NOBR4           If no address then clear all entries
00001A2C  2240                    1167          MOVE.L  D0,A1           Else just clear breakpoint in A1
00001A2E  41EE 0164               1168          LEA.L   BP_TAB(A6),A0   A0 points to BP table
00001A32  303C 0007               1169          MOVE.W  #7,D0           Up to eight entries to test
00001A36  2218                    1170  NOBR2   MOVE.L  (A0)+,D1        Get entry and
00001A38  41E8 0002               1171          LEA.L   2(A0),A0        skip past op-code field
00001A3C  B289                    1172          CMP.L   A1,D1           Is this the one?
00001A3E  6706                    1173          BEQ.S   NOBR3          If so go and clear entry
00001A40  51C8 FFF4               1174          DBRA    D0,NOBR2        Repeat until all tested
00001A44  4E75                    1175          RTS
00001A46  42A8 FFFA               1176  NOBR3   CLR.L   -6(A0)          Clear address in BP table
00001A4A  4E75                    1177          RTS
00001A4C  41EE 0164               1178  NOBR4   LEA.L   BP_TAB(A6),A0   Clear all 8 entries in BP table
00001A50  303C 0007               1179          MOVE.W  #7,D0           Eight entries to clear
00001A54  4298                    1180  NOBR5   CLR.L   (A0)+           Clear breakpoint address
00001A56  4258                    1181          CLR.W   (A0)+           Clear op-code field
00001A58  51C8 FFFA               1182          DBRA    D0,NOBR5        Repeat until all done
00001A5C  4E75                    1183          RTS
00001A5E                          1184  *
00001A5E  =00001A5E               1185  BR_CLR  EQU     *               Remove breakpoints from code
00001A5E  41EE 0164               1186          LEA.L   BP_TAB(A6),A0   A0 points to breakpoint table
00001A62  303C 0007               1187          MOVE.W  #7,D0           Up to eight entries to clear
00001A66  2218                    1188  BR_CLR1 MOVE.L  (A0)+,D1        Get address of BP in D1
00001A68  2241                    1189          MOVE.L  D1,A1           and put copy in A1
00001A6A  4A81                    1190          TST.L   D1              Test this breakpoint
00001A6C  6702                    1191          BEQ.S   BR_CLR2         If zero then skip BP clearing
00001A6E  3290                    1192          MOVE.W  (A0),(A1)       Else restore op-code
00001A70  41E8 0002               1193  BR_CLR2 LEA.L   2(A0),A0        Skip past op-code field
00001A74  51C8 FFF0               1194          DBRA    D0,BR_CLR1      Repeat until all tested
00001A78  4E75                    1195          RTS
00001A7A                          1196   *=============================================================================
00001A7A                          1197  *   REG_MOD modifies a register in the display frame. The command
00001A7A                          1198  *   format is REG <reg> <value>. E.g. REG D3 1200
00001A7A                          1199   
00001A7A  4281                    1200  REG_MOD CLR.L   D1              D1 to hold name of register
00001A7C  41EE 0102               1201          LEA.L   BUFFPT(A6),A0   A0 contains address of buffer pointer
00001A80  2050                    1202          MOVE.L  (A0),A0         A0 now points to next char in buffer
00001A82  1218                    1203          MOVE.B  (A0)+,D1        Put first char of name in D1
00001A84  E159                    1204          ROL.W   #8,D1            Move char one place left
00001A86  1218                    1205          MOVE.B  (A0)+,D1        Get second char in D1
00001A88  41E8 0001               1206          LEA.L   1(A0),A0        Move pointer past space in buffer
00001A8C  2D48 0102               1207          MOVE.L  A0,BUFFPT(A6)   Update buffer pointer
00001A90  4282                    1208          CLR.L   D2              D2 is the character pair counter
00001A92  41FA 037A               1209          LEA.L   REGNAME(PC),A0  A0 points to string of character pairs
00001A96  43D0                    1210          LEA.L   (A0),A1         A1 also points to string
00001A98  B258                    1211  REG_MD1 CMP.W   (A0)+,D1        Compare a char pair with input
00001A9A  6712                    1212          BEQ.S   REG_MD2         If match then exit loop
00001A9C  5282                    1213          ADD.L   #1,D2           Else increment match counter
00001A9E  B4BC 00000013           1214          CMP.L   #19,D2          Test for end of loop
00001AA4  66F2                    1215          BNE     REG_MD1         Continue until all pairs matched
00001AA6  49FA 038F               1216          LEA.L   ERMES1(PC),A4   If here then error
00001AAA  6000 F6DE               1217          BRA     PSTRING         Display error and return
00001AAE  43EE 011A               1218  REG_MD2 LEA.L   TSK_T(A6),A1    A1 points to display frame
00001AB2  E582                    1219          ASL.L   #2,D2           Multiply offset by 4 (4 bytes/entry)
00001AB4  B4BC 00000048           1220          CMP.L   #72,D2          Test for address of PC
00001ABA  6602                    1221          BNE.S   REG_MD3         If not PC then all is OK
00001ABC  5582                    1222          SUB.L   #2,D2           else dec PC pointer as Sr is a word
00001ABE  45F1 2000               1223  REG_MD3 LEA.L   (A1,D2),A2      Calculate address of entry in disptable
00001AC2  2012                    1224          MOVE.L  (A2),D0         Get old contents
00001AC4  6100 F906               1225          BSR     OUT8X           Display them
00001AC8  6100 F6B0               1226           BSR     NEWLINE
00001ACC  6100 F890               1227          BSR     PARAM           Get new data
00001AD0  4A07                    1228          TST.B   D7              Test for input error
00001AD2  6708                    1229          BEQ.S   REG_MD4         If no error then go and store data
00001AD4  49FA 0361               1230          LEA.L   ERMES1(PC),A4   Else point to error message
00001AD8  6000 F6B0               1231          BRA     PSTRING         print it and return
00001ADC  B4BC 00000044           1232  REG_MD4 CMP.L   #68,D2          If this address is the SR then
00001AE2  6704                    1233          BEQ.S   REG_MD5         we have only a word to store
00001AE4  2480                    1234          MOVE.L  D0,(A2)         Else store new data in display frame
00001AE6  4E75                    1235          RTS
00001AE8  3480                    1236  REG_MD5 MOVE.W  D0,(A2)         Store SR (one word)
00001AEA  4E75                    1237          RTS
00001AEC                          1238   *=============================================================================
00001AEC  =00001AEC               1239  X_UN    EQU     *               Uninitialized exception vector routine
00001AEC  49FA 03AF               1240          LEA.L   ERMES6(PC),A4   Point to error message
00001AF0  6100 F698               1241          BSR     PSTRING         Display it
00001AF4  6100 FD0E               1242          BSR     EX_DIS          Display registers
00001AF8  6000 012E               1243           BRA     _main          Abort
00001AFC                          1244   *=============================================================================
00001AFC                          1245  *   LOGON subroutine is called upon RESET
00001AFC                          1246  *   If successful, returns with no effect
00001AFC                          1247  *   Upon failure, RESETs
00001AFC                          1248  _LOGON
00001AFC  =00001AFC               1249  LOGON   EQU     *
00001AFC  48E7 E018               1250          MOVEM.L D0-D2/A3-A4,-(A7)   Save registers to stack
00001B00  4280                    1251          CLR.L   D0              Clear attempt count
00001B02                          1252  *       CLR.L   STAR(A6)        Clear STAR ECHO
00001B02  4282                    1253  LOG1    CLR.L   D2              Clear user match
00001B04  4287                    1254          CLR.L   D7              Clear error flag
00001B06  B0BC 00000003           1255          CMP.L   #3,D0           if too many attempts
00001B0C  6700 004A               1256          BEQ     LOGF                    goto failure
00001B10  6100 F668               1257          BSR     NEWLINE
00001B14  49FA 068E               1258          LEA.L   LOGM(PC),A4
00001B18  6100 F670               1259          BSR     PSTRING
00001B1C  6100 F682               1260          BSR     GETLINE
00001B20  6100 F754               1261          BSR     TIDY
00001B24  47FA 068B               1262          LEA.L   USERNA(PC),A3   Load username into A3
00001B28  6100 0036               1263          BSR     LSCH            Sets D1 if we have match
00001B2C  2401                    1264          MOVE.L  D1,D2           Save user match in D2
00001B2E  4287                    1265          CLR.L   D7              Clear error flag
00001B30  6100 F648               1266          BSR     NEWLINE
00001B34                          1267  *       MOVE.L  #1,STAR(A6)     Set STAR ECHO
00001B34  49FA 0684               1268          LEA.L   PASSM(PC),A4
00001B38  6100 F650               1269          BSR     PSTRING
00001B3C  6100 F698               1270          BSR     GETPASS
00001B40                          1271  *       CLR.L   STAR(A6)        Clear STAR ECHO
00001B40  47FA 0683               1272          LEA.L   PASS(PC),A3     Load password into A3
00001B44  6100 001A               1273          BSR     LSCH            Sets D1 if we have a match
00001B48  D282                    1274          ADD.L   D2,D1           Add two match flags together
00001B4A  B2BC 00000002           1275          CMP.L   #2,D1           If both are set
00001B50  6700 0008               1276          BEQ     LOGS            Success
00001B54  5280                    1277          ADD.L   #1,D0           Else increment attempt count
00001B56  60AA                    1278          BRA     LOG1            And loop
00001B58  4E70                    1279  LOGF    RESET                   Reset on login failure
00001B5A  4CDF 1807               1280  LOGS    MOVEM.L (A7)+,D0-D2/A3-A4   Restore registers from stack
00001B5E  4E75                    1281          RTS                     Return on success
00001B60                          1282   
00001B60                          1283   *============================================================================
00001B60                          1284  *   LOGON helper subroutine
00001B60                          1285  *   INPUT:  A3 = start address of string to compare against
00001B60                          1286  *   OUTPUT: D1 = 1 if strings match, 0 otherwise
00001B60                          1287  _LSCH
00001B60  48E7 8008               1288  LSCH    MOVEM.L D0/A4,-(A7)     Save registers to stack
00001B64  49EE 00C1               1289          LEA.L   LNBUFF(A6),A4   Load line buffer into A4
00001B68  4281                    1290          CLR.L   D1              Preemptively clear user match
00001B6A  101B                    1291  LSCH0   MOVE.B  (A3)+,D0        Get character of username
00001B6C  4A40                    1292          TST     D0              Test for null
00001B6E  6700 000A               1293          BEQ     LSCHS           Success on NULL
00001B72  B01C                    1294          CMP.B   (A4)+,D0        Compare with input char
00001B74  6600 0006               1295          BNE     LSCHF           Fail on mismatch
00001B78  60F0                    1296          BRA     LSCH0           Loop
00001B7A  7201                    1297  LSCHS   MOVE.L  #1,D1           Set user match
00001B7C  4CDF 1001               1298  LSCHF   MOVEM.L (A7)+,D0/A4     Restore registers from stack
00001B80  4E75                    1299          RTS
00001B82                          1300   *=============================================================================
00001B82                          1301  *   HELP prints a description of each command in COMTAB
00001B82                          1302  _HELP
00001B82  =00001B82               1303  HELP    EQU     *
00001B82  6100 F5F6               1304          BSR     NEWLINE
00001B86  49FA 0352               1305          LEA.L   HEJU(PC),A4
00001B8A  6100 F5FE               1306          BSR     PSTRING
00001B8E  6100 F5EA               1307          BSR     NEWLINE
00001B92  49FA 037F               1308          LEA.L   HEME(PC),A4
00001B96  6100 F5F2               1309          BSR     PSTRING
00001B9A  6100 F5DE               1310          BSR     NEWLINE
00001B9E  49FA 03A6               1311          LEA.L   HELO(PC),A4
00001BA2  6100 F5E6               1312          BSR     PSTRING
00001BA6  6100 F5D2               1313          BSR     NEWLINE
00001BAA  49FA 03CD               1314          LEA.L   HEDU(PC),A4
00001BAE  6100 F5DA               1315          BSR     PSTRING
00001BB2  6100 F5C6               1316          BSR     NEWLINE
00001BB6  49FA 0402               1317          LEA.L   HENO(PC),A4
00001BBA  6100 F5CE               1318          BSR     PSTRING
00001BBE  6100 F5BA               1319          BSR     NEWLINE
00001BC2  49FA 0438               1320          LEA.L   HEDI(PC),A4
00001BC6  6100 F5C2               1321          BSR     PSTRING
00001BCA  6100 F5AE               1322          BSR     NEWLINE
00001BCE  49FA 046B               1323          LEA.L   HEGO(PC),A4
00001BD2  6100 F5B6               1324          BSR     PSTRING
00001BD6  6100 F5A2               1325          BSR     NEWLINE
00001BDA  49FA 0495               1326          LEA.L   HEBR(PC),A4
00001BDE  6100 F5AA               1327          BSR     PSTRING
00001BE2  6100 F596               1328          BSR     NEWLINE
00001BE6  49FA 04C9               1329          LEA.L   HEPL(PC),A4
00001BEA  6100 F59E               1330          BSR     PSTRING
00001BEE  6100 F58A               1331          BSR     NEWLINE
00001BF2  49FA 04E6               1332          LEA.L   HEKI(PC),A4
00001BF6  6100 F592               1333          BSR     PSTRING
00001BFA  6100 F57E               1334          BSR     NEWLINE
00001BFE  49FA 0504               1335          LEA.L   HEGB(PC),A4
00001C02  6100 F586               1336          BSR     PSTRING
00001C06  6100 F572               1337          BSR     NEWLINE
00001C0A  49FA 052B               1338          LEA.L   HERE(PC),A4
00001C0E  6100 F57A               1339          BSR     PSTRING
00001C12  6000 0014               1340          BRA     _main
00001C16                          1341         
00001C16                          1342  *===========================================================================
00001C16                          1343  *       MAIN FUNCTION
00001C16                          1344   
00001C16                          1345  _mainstart:
00001C16                          1346  ; //test();
00001C16                          1347  ; LOGON();
00001C16  4EB8 1AFC               1348         jsr      _LOGON
00001C1A                          1349  ; //logon();
00001C1A                          1350  ; banner();
00001C1A  4EB9 00001C3A           1351         jsr      _banner
00001C20                          1352  ; command();
00001C20  4EB9 00001C28           1353         jsr      _command
00001C26  4E75                    1354         rts
00001C28                          1355  ; }
00001C28                          1356  ; void command(){
00001C28                          1357  _main
00001C28                          1358  _command:
00001C28                          1359  ; while(1){
00001C28                          1360  command_1:
00001C28                          1361  ; GETLINE();
00001C28  4EB8 117A               1362         jsr      _NEWLINE
00001C2C  4EB8 11A0               1363         jsr      _GETLINE
00001C30                          1364  ; TIDY();
00001C30  4EB8 1276               1365         jsr      _TIDY
00001C34                          1366  ; EXECUTE();
00001C34  4EB8 12B8               1367         jsr      _EXECUTE
00001C38                          1368             ;jsr          _NEWLINE
00001C38  60EE                    1369         bra      command_1
00001C3A                          1370  ; }
00001C3A                          1371  ; }
00001C3A                          1372  ; /*void logon(){
00001C3A                          1373  ; /*char* userName = "STUDENT";
00001C3A                          1374  ; char* pass = "CECS525";
00001C3A                          1375  ; sendmsg(&USERMSG);            //get user name
00001C3A                          1376  ; while(buffer != 13){
00001C3A                          1377  ; *buffer = getchar();
00001C3A                          1378  ; sendchar(*buffer);
00001C3A                          1379  ; buffer = buffer + 1;
00001C3A                          1380  ; }
00001C3A                          1381  ; //check user name
00001C3A                          1382  ; while(*buffer != 0){
00001C3A                          1383  ; if(*buffer != *userName){
00001C3A                          1384  ; break;
00001C3A                          1385  ; }
00001C3A                          1386  ; else{
00001C3A                          1387  ; buffer = buffer + 1;
00001C3A                          1388  ; userName = userName + 1;
00001C3A                          1389  ; }
00001C3A                          1390  ; }
00001C3A                          1391  ; }
00001C3A                          1392  ; void debug(){
00001C3A                          1393  ; _A4 = DEBUG;
00001C3A                          1394  ; PSTRING();
00001C3A                          1395  ; NEWLINE();
00001C3A                          1396  ; sendchar('*');
00001C3A                          1397  ; GETLINE();
00001C3A                          1398  ; _A4 = _A0;
00001C3A                          1399  ; PSTRING();
00001C3A                          1400  ; NEWLINE();
00001C3A                          1401  ; _A4 = _A1;
00001C3A                          1402  ; PSTRING();
00001C3A                          1403  ; NEWLINE();
00001C3A                          1404  ; _A4 = DEBUGEND;
00001C3A                          1405  ; PSTRING();
00001C3A                          1406  ; NEWLINE();
00001C3A                          1407  ; }*/
00001C3A                          1408  ; void banner(){
00001C3A                          1409  _banner:
00001C3A  48E7 0030               1410         movem.l   A2/A3,-(A7)
00001C3E  45F9 0000117A           1411         lea      _NEWLINE.L,A2
00001C44  47F9 0000118A           1412         lea      _PSTRING.L,A3
00001C4A                          1413  ; _A4 = BANNER;
00001C4A  41F9 000021CC           1414         lea      tinywa1_1.L,A0
00001C50  2848                    1415         move.l   A0,A4
00001C52                          1416  ; PSTRING();
00001C52  4E93                    1417         jsr      (A3)
00001C54                          1418  ; NEWLINE();
00001C54  4E92                    1419         jsr      (A2)
00001C56                          1420  ; _A4 = MODIFY;
00001C56  41F9 000021E5           1421         lea      tinywa1_2.L,A0
00001C5C  2848                    1422         move.l   A0,A4
00001C5E                          1423  ; PSTRING();
00001C5E  4E93                    1424         jsr      (A3)
00001C60                          1425  ; NEWLINE();
00001C60  4E92                    1426         jsr      (A2)
00001C62                          1427  ; _A4 = MODIFY2;
00001C62  41F9 00002212           1428         lea      tinywa1_3.L,A0
00001C68  2848                    1429         move.l   A0,A4
00001C6A                          1430  ; PSTRING();
00001C6A  4E93                    1431         jsr      (A3)
00001C6C                          1432  ; NEWLINE();
00001C6C  4E92                    1433         jsr      (A2)
00001C6E                          1434  ; _A4 = WHY;
00001C6E  41F9 0000222A           1435         lea      tinywa1_4.L,A0
00001C74  2848                    1436         move.l   A0,A4
00001C76                          1437  ; PSTRING();
00001C76  4E93                    1438         jsr      (A3)
00001C78                          1439  ; NEWLINE();
00001C78  4E92                    1440         jsr      (A2)
00001C7A                          1441  ; _A4 = WHERE;
00001C7A  41F9 00002261           1442         lea      tinywa1_5.L,A0
00001C80  2848                    1443         move.l   A0,A4
00001C82                          1444  ; PSTRING();
00001C82  4E93                    1445         jsr      (A3)
00001C84                          1446  ; NEWLINE();
00001C84  4E92                    1447         jsr      (A2)
00001C86                          1448  ; _A4 = ADDRE;
00001C86  41F9 0000227A           1449         lea      tinywa1_6.L,A0
00001C8C  2848                    1450         move.l   A0,A4
00001C8E                          1451  ; PSTRING();
00001C8E  4E93                    1452         jsr      (A3)
00001C90                          1453  ; NEWLINE();
00001C90  4E92                    1454         jsr      (A2)
00001C92  4CDF 0C00               1455         movem.l   (A7)+,A2/A3
00001C96  4E75                    1456         rts
00001C98                          1457  ; }
00001C98                          1458   *=============================================================================
00001C98                          1459  *   COMTAB  is the built-in command table. All entries are made up of
00001C98                          1460  *               a string length + number of characters to match + the string
00001C98                          1461  *           plus the address of the command relative to COMTAB
00001C98                          1462   
00001C98= 04 04                   1463  COMTAB  DC.B    4,4             HELP lists commands with discriptions
00001C9A= 48 45 4C 50             1464             DC.B    'HELP'
00001C9E= FFFFFEEA                1465          DC.L    HELP-COMTAB
00001CA2= 04 04                   1466          DC.B    4,4             JUMP <address> causes execution to
00001CA4= 4A 55 4D 50             1467          DC.B    'JUMP'          begin at <address>
00001CA8= FFFFF73C                1468          DC.L    JUMP-COMTAB
00001CAC= 08 03                   1469          DC.B    8,3             MEMORY <address> examines contents of
00001CAE= 4D 45 4D 4F 52 59 ...   1470          DC.B    'MEMORY  '      <address> and allows them to be changed
00001CB6= FFFFF752                1471          DC.L    MEMORY-COMTAB
00001CBA= 04 02                   1472          DC.B    4,2             LOAD <string> loads S1/S2 records
00001CBC= 4C 4F 41 44             1473          DC.B    'LOAD'          from the host. <string> is sent to host
00001CC0= FFFFF7B2                1474          DC.L    LOAD-COMTAB
00001CC4= 04 02                   1475          DC.B    4,2             DUMP <string> sends S1 records to the
00001CC6= 44 55 4D 50             1476          DC.B    'DUMP'          host and is preceeded by <string>.
00001CCA= FFFFF876                1477          DC.L    DUMP-COMTAB
00001CCE= 04 02                   1478          DC.B    4,2             NOBR <address> removes the breakpoint
00001CD0= 4E 4F 42 52             1479          DC.B    'NOBR'          at <address> from the BP table. If
00001CD4= FFFFFD80                1480          DC.L    NOBR-COMTAB     no address is given all BPs are removed.
00001CD8= 04 02                   1481          DC.B    4,2             DISP displays the contents of the
00001CDA= 44 49 53 50             1482          DC.B    'DISP'          pseudo registers in TSK_T.
00001CDE= FFFFFB6C                1483          DC.L    EX_DIS-COMTAB
00001CE2= 04 02                   1484          DC.B    4,2             GO <address> starts program execution
00001CE4= 47 4F 20 20             1485          DC.B    'GO  '          at <address> and loads regs from TSK_T
00001CE8= FFFFFCBE                1486          DC.L    GO-COMTAB
00001CEC= 04 02                   1487          DC.B    4,2             BRGT puts a breakpoint in the BP
00001CEE= 42 52 47 54             1488          DC.B    'BRGT'          table - but not in the code
00001CF2= FFFFFD1C                1489          DC.L    BR_GET-COMTAB
00001CF6= 04 02                   1490          DC.B    4,2             PLAN puts the breakpoints in the code
00001CF8= 50 4C 41 4E             1491          DC.B    'PLAN'
00001CFC= FFFFFD5A                1492          DC.L    BR_SET-COMTAB
00001D00= 04 04                   1493          DC.B    4,4              KILL removes breakpoints from the code
00001D02= 4B 49 4C 4C             1494          DC.B    'KILL'
00001D06= FFFFFDC6                1495          DC.L    BR_CLR-COMTAB
00001D0A= 04 02                   1496          DC.B    4,2             GB <address> sets breakpoints and
00001D0C= 47 42 20 20             1497          DC.B    'GB  '          then calls GO.
00001D10= FFFFFCDE                1498          DC.L    GB-COMTAB
00001D14= 04 03                   1499          DC.B    4,3             REG <reg> <value> loads <value>
00001D16= 52 45 47 20             1500          DC.B    'REG '          into <reg> in TASK_T. Used to preset
00001D1A= FFFFFDE2                1501          DC.L    REG_MOD-COMTAB  registers before a GO or GB
00001D1E= 00 00                   1502          DC.B    0,0
00001D20                          1503   *=============================================================================
00001D20                          1504  *   This is a list of the information needed to setup the DCBs
00001D20                          1505   
00001D20  =00001D20               1506  DCB_LST EQU     *
00001D20= 43 4F 4E 5F 49 4E ...   1507  DCB1    DC.B    'CON_IN  '      Device name (8 bytes)
00001D28= 00001624 00008001       1508          DC.L    CON_IN,ACIA     Address of driver routine, device
00001D30= 0002                    1509          DC.W    2               Number of words in parameter field
00001D32= 43 4F 4E 5F 4F 55 ...   1510  DCB2    DC.B    'CON_OUT '
00001D3A= 00001654 00008001       1511          DC.L    CON_OUT,ACIA
00001D42= 0002                    1512          DC.W    2
00001D44                          1513   *=============================================================================
00001D44                          1514  *   DCB structure
00001D44                          1515  *
00001D44                          1516  *               -----------------------
00001D44                          1517  *       0 ->   | DCB  name           |
00001D44                          1518  *               |---------------------|
00001D44                          1519  *       8 ->   | Device driver          |
00001D44                          1520  *               |---------------------|
00001D44                          1521  *      12 ->   | Device address         |
00001D44                          1522  *               |---------------------|
00001D44                          1523  *      16 ->   |Size of param block  |
00001D44                          1524  *              |---------------------| ---
00001D44                          1525  *      18 ->   |        Status          |   |
00001D44                          1526  *               | logical  | physical |   | S
00001D44                          1527  *               |---------------------|   |
00001D44                          1528  *               .                       .   .
00001D44                          1529  *               |---------------------| ---
00001D44                          1530  *    18+S ->   | Pointer to next DCB |
00001D44                          1531  *
00001D44                          1532  *=============================================================================
00001D44                          1533  *   All strings and other fixed parameters here
00001D44                          1534   
00001D44= 0D 0A 54 53 32 4D ...   1535  CRLF    DC.B    CR,LF,'TS2MON >',0
00001D4F= 0D 0A 53 31 00 00       1536  HEADER  DC.B    CR,LF,'S','1',0,0
00001D55= 53 39 20 20 00 00       1537  TAIL    DC.B    'S9  ',0,0
00001D5B= 20 53 52 20 20 3D ...   1538  MES1    DC.B    ' SR  =  ',0
00001D64= 20 50 43 20 20 3D ...   1539  MES2    DC.B    ' PC  =  ',0
00001D6D= 20 53 53 20 20 3D ...   1540  MES2A   DC.B    ' SS  =  ',0
00001D76= 20 20 44 61 74 61 ...   1541  MES3    DC.B    '  Data reg       Address reg',0,0
00001D94= 20 20 20 20 09 00 00    1542  MES4    DC.B    '       ',0,0
00001D9B= 42 75 73 20 65 72 ...   1543  MES8    DC.B    'Bus error   ',0,0
00001DA9= 41 64 64 72 65 73 ...   1544  MES9    DC.B    'Address error   ',0,0
00001DBB= 49 6C 6C 65 67 61 ...   1545  MES10   DC.B    'Illegal instruction ',0,0
00001DD1= 42 72 65 61 6B 70 ...   1546  MES11   DC.B    'Breakpoint  ',0,0
00001DDF= 54 72 61 63 65 20 ...   1547  MES12   DC.B    'Trace   ',0
00001DE8= 44 69 76 69 73 69 ...   1548  MES13   DC.B    'Division by Zero',0
00001DF9= 50 72 69 76 69 6C ...   1549  MES14   DC.B    'Priviledge Violation',0
00001E0E= 44 30 44 31 44 32 ...   1550  REGNAME DC.B    'D0D1D2D3D4D5D6D7'
00001E1E= 41 30 41 31 41 32 ...   1551          DC.B    'A0A1A2A3A4A5A6A7'
00001E2E= 53 53 53 52             1552          DC.B    'SSSR'
00001E32= 50 43 20 20 00          1553          DC.B    'PC  ',0
00001E37= 4E 6F 6E 2D 76 61 ...   1554  ERMES1  DC.B    'Non-valid hexadecimal input  ',0
00001E55= 49 6E 76 61 6C 69 ...   1555  ERMES2  DC.B    'Invalid command  ',0
00001E67= 4C 6F 61 64 69 6E ...   1556  ERMES3  DC.B    'Loading error',0
00001E75= 54 61 62 6C 65 20 ...   1557  ERMES4  DC.B    'Table full  ',0,0
00001E83= 42 72 65 61 6B 70 ...   1558  ERMES5  DC.B    'Breakpoint not active   ',0,0
00001E9D= 55 6E 69 6E 69 74 ...   1559  ERMES6  DC.B    'Uninitialized exception ',0,0
00001EB7= 20 52 61 6E 67 65 ...   1560  ERMES7  DC.B    ' Range error',0
00001EC4= 50 72 69 76 69 6C ...   1561  ERMES8  DC.B    'Privilege violation ',0,0
00001EDA= 28 4A 55 4D 50 29 ...   1562  HEJU    DC.B    '(JUMP) <address> causes execution to begin at <address>',0,0
00001F13= 28 4D 45 4D 29 4F ...   1563  HEME    DC.B    '(MEM)ORY <address> examines contents of <address>',0,0
00001F46= 28 4C 4F 29 41 44 ...   1564  HELO    DC.B    '(LO)AD <string> loads S1/S2 records from the host',0,0
00001F79= 28 44 55 29 4D 50 ...   1565  HEDU    DC.B    '(DU)MP <string> sends S1 records to host preceeded by <string>',0,0,0
00001FBA= 28 4E 4F 29 42 52 ...   1566  HENO    DC.B    '(NO)BR <address> removes the breakpoint at <address> from the BP',0,0
00001FFC= 28 44 49 29 53 50 ...   1567  HEDI    DC.B    '(DI)SP displays the contents of the pseudo registers in TSK_T',0,0
0000203B= 28 47 4F 29 20 3C ...   1568  HEGO    DC.B    '(GO) <address> starts program execution at <address>',0,0
00002071= 28 42 52 29 47 54 ...   1569  HEBR    DC.B    '(BR)GT puts a breakpoint in the BP table - but not in the code',0,0
000020B1= 28 50 4C 29 41 4E ...   1570  HEPL    DC.B    '(PL)AN puts the breakpoints in the code',0,0
000020DA= 28 4B 49 4C 4C 29 ...   1571  HEKI    DC.B    '(KILL) removes breakpoints from the code',0,0
00002104= 28 47 42 29 20 3C ...   1572  HEGB    DC.B    '(GB) <address> sets breakpoints and then calls GO',0,0
00002137= 28 52 45 47 29 20 ...   1573  HERE    DC.B    '(REG) <reg> <value> view or preloads <value> into <reg>',0,0
00002170= 46 50 55 20 4D 61 ...   1574  NAN     DC.B    'FPU Math Error: Result is Not a Number or Infinity',0,0
000021A4= 55 53 45 52 20 4E ...   1575  LOGM    DC.B    'USER NAME: ',0,0
000021B1= 50 52 4F 4A 45 43 ...   1576  USERNA  DC.B    'PROJECT2',0
000021BA= 50 41 53 53 57 4F ...   1577  PASSM   DC.B    'PASSWORD: ',0
000021C5= 47 52 4F 55 50 34 00    1578  PASS    DC.B    'GROUP4',0
000021CC                          1579   
000021CC                          1580  tinywa1_1:
000021CC= 54 53 42 55 47 20 ...   1581          DC.B    84,83,66,85,71,32,50,32,86,101,114,115,105,111
000021DA= 6E 20 32 33 2E 30 ...   1582          DC.B    110,32,50,51,46,48,55,46,56,54,0
000021E5                          1583  tinywa1_2:
000021E5= 4D 6F 64 69 66 69 ...   1584         DC.B     77,111,100,105,102,105,101,100,32,98,121,32
000021F1= 45 75 67 65 6E 65 ...   1585         DC.B     69,117,103,101,110,101,32,65,46,32,82,111,99
000021FE= 6B 65 79 20 4A 72 ...   1586         DC.B     107,101,121,32,74,114,46,32,79,99,116,46,49
0000220B= 38 2E 32 30 30 39 00    1587         DC.B     56,46,50,48,48,57,0
00002212                          1588  tinywa1_3:
00002212= 61 6E 64 20 47 72 ...   1589         DC.B     97,110,100,32,71,114,111,117,112,32,49,32,83
0000221F= 65 70 2E 31 38 2E ...   1590         DC.B     101,112,46,49,56,46,50,48,49,55,0
0000222A                          1591  tinywa1_4:
0000222A= 66 6F 72 20 75 73 ...   1592         DC.B     102,111,114,32,117,115,101,32,119,105,116,104
00002236= 20 74 68 65 20 4D ...   1593         DC.B     32,116,104,101,32,77,54,56,48,48,48,32,77,105
00002244= 6E 69 6D 61 6C 20 ...   1594         DC.B     110,105,109,97,108,32,67,111,109,112,117,116
00002250= 65 72 20 43 6F 6E ...   1595         DC.B     101,114,32,67,111,110,102,105,103,117,114,97
0000225C= 74 69 6F 6E 00          1596         DC.B     116,105,111,110,0
00002261                          1597  tinywa1_5:
00002261= 55 6E 69 76 65 72 ...   1598         DC.B     85,110,105,118,101,114,115,105,116,121,32,111
0000226D= 66 20 4C 6F 75 69 ...   1599         DC.B     102,32,76,111,117,105,115,118,105,108,108,101
00002279= 00                      1600          DC.B    0
0000227A                          1601  tinywa1_6:
0000227A= 43 45 43 53 20 35 ...   1602         DC.B     67,69,67,83,32,53,50,53,44,32,119,119,119,46
00002288= 63 73 2E 6C 6F 75 ...   1603         DC.B     99,115,46,108,111,117,105,115,118,105,108,108
00002294= 65 2E 65 64 75 00       1604         DC.B     101,46,101,100,117,0
0000229A                          1605           
0000229A                          1606  addingErrorMessage      
0000229A= 0D 0A                   1607          DC.B     CR,LF
0000229C= 41 4C 55 20 54 65 ...   1608          DC.B     'ALU Test Error:',CR,LF
000022AD= 41 64 64 69 6E 67 ...   1609          DC.B     'Adding error.',CR,LF,0
000022BD                          1610                  
000022BD                          1611  subtractingErrorMessage 
000022BD= 0D 0A                   1612          DC.B     CR,LF
000022BF= 41 4C 55 20 54 65 ...   1613          DC.B     'ALU Test Error:',CR,LF
000022D0= 53 75 62 74 72 61 ...   1614          DC.B     'Subtracting error.',CR,LF,0
000022E5                          1615                  
000022E5                          1616  multiplyingErrorMessage 
000022E5= 0D 0A                   1617          DC.B      CR,LF
000022E7= 41 4C 55 20 54 65 ...   1618          DC.B      'ALU Test Error:',CR,LF
000022F8= 4D 75 6C 74 69 70 ...   1619          DC.B      'Multiplying error.',CR,LF,0
0000230D                          1620                  
0000230D                          1621  dividingErrorMessage    
0000230D= 0D 0A                   1622          DC.B      CR,LF
0000230F= 41 4C 55 20 54 65 ...   1623          DC.B      'ALU Test Error:',CR,LF
00002320= 44 69 76 69 64 69 ...   1624          DC.B      'Dividing error.',CR,LF,0
00002332                          1625                  
00002332                          1626  finishedALUTest
00002332= 0D 0A                   1627          DC.B      CR,LF
00002334= 41 4C 55 20 54 45 ...   1628          DC.B      'ALU TEST COMPLETE',CR,LF,0
00002348                          1629                  
00002348                          1630  MemTestSuccess
00002348= 0D 0A                   1631          DC.B      CR,LF
0000234A= 4D 45 4D 4F 52 59 ...   1632          DC.B      'MEMORY TEST COMPLETE',CR,LF,0
00002361                          1633                  
00002361                          1634  ramErrorMessage 
00002361= 0D 0A                   1635          DC.B      CR,LF
00002363= 54 68 65 72 65 20 ...   1636          DC.B      'There was an error reading/writing in Ram at address: ',CR,LF,0
0000239C                          1637   
0000239C                          1638  _chr:
0000239C= 01                      1639          DC.B    1
0000239D                          1640        
0000239D                          1641          END     RESET

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ACIA                8001
ADD                 10E0
ADDINGERROR         1114
ADDINGERRORMESSAGE  229A
ADD_ER              18B0
ADR_DAT             1428
ALUTEST             10D8
BP_TAB              164
BRKPT               18D8
BR_CLR              1A5E
BR_CLR1             1A66
BR_CLR2             1A70
BR_GET              19B4
BR_GET1             19C4
BR_GET2             19D0
BR_GET3             19E0
BR_GET4             19E8
BR_SET              19F2
BR_SET1             1A00
BR_SET2             1A0E
BS                  8
BUFFEND             100
BUFFER              394
BUFFPT              102
BUS_ER              189C
BYTE                1342
CLEARRAM            1044
CLR_BPT             1726
CN_IVEC             112
CN_OVEC             116
COMMAND             8000A
COMMAND_1           1C28
COMTAB              1C98
CON_I1              1632
CON_I2              164A
CON_IN              1624
CON_OT1             1662
CON_OT2             1678
CON_OT3             1680
CON_OUT             1654
CR                  D
CRLF                1D44
CTRL_A              1
DATA                4500
DCB1                1D20
DCB2                1D32
DCB_LST             1D20
DELAY               15B6
DELAY1              15C0
DIVIDE              1106
DIVIDINGERRORMESSAGE  230D
DIVISIONERROR       1144
DUMP                150E
DUMP1               151E
DUMP2               152A
DUMP3               1540
DUMP4               1554
DUMP5               1562
DUMP6               157C
DUMP7               15A0
ECHO                10A
ENDALUTEST          1154
ERMES1              1E37
ERMES2              1E55
ERMES3              1E67
ERMES4              1E75
ERMES5              1E83
ERMES6              1E9D
ERMES7              1EB7
ERMES8              1EC4
EXEC1               12CA
EXEC2               12DA
EXECUTE             12B8
EX_D1               1816
EX_DIS              1804
FINISHEDALUTEST     2332
FIRST               194
FUNC1               1744
FUNC10              17AE
FUNC11              17BA
FUNC12              17C6
FUNC13              17D2
FUNC14              17DE
FUNC15              17EA
FUNC16              17F6
FUNC17              1802
FUNC2               174E
FUNC3               175A
FUNC4               1766
FUNC5               1772
FUNC6               177E
FUNC7               178A
FUNC8               1796
FUNC9               17A2
GB                  1976
GETCH2              16BA
GETCH3              16D8
GETCHAR             1694
GETLINE             11A0
GETLN2              11AA
GETLN3              11C4
GETLN4              11CE
GETLN5              11D2
GETPASS             11D6
GETPS2              11E0
GETPS3              11FA
GETPS4              1206
GETPS5              120A
GETSTAR             1210
GO                  1956
GO1                 1966
GO2                 1974
GROUP1              18F6
GROUP1A             1914
GROUP2              192A
GROUP2A             1936
HEADER              1D4F
HEADING             119A
HEBR                2071
HEDI                1FFC
HEDU                1F79
HEGB                2104
HEGO                203B
HEJU                1EDA
HEKI                20DA
HELO                1F46
HELP                1B82
HEME                1F13
HENO                1FBA
HEPL                20B1
HERE                2137
HEX                 1324
HEX_OK              1340
IL_ER               1882
IO_OPEN             16EC
IO_REQ              1612
JUMP                13D4
JUMP1               13E2
LBPT                172E
LF                  A
LNBUFF              C1
LOAD                144A
LOAD1               1466
LOAD2               1476
LOAD3               1490
LOAD4               14AA
LOAD5               14B8
LOAD6               14BA
LOAD6A              14DE
LOAD7               14F0
LOAD8               1506
LOG1                1B02
LOGF                1B58
LOGM                21A4
LOGON               1AFC
LOGS                1B5A
LONGWD              1358
LSCH                1B60
LSCH0               1B6A
LSCHF               1B7C
LSCHS               1B7A
MAXCHR              40
MEM1                13F4
MEM2                1412
MEM3                1426
MEMORY              13EA
MEMTESTEND          10C8
MEMTESTSUCCESS      2348
MES1                1D5B
MES10               1DBB
MES11               1DD1
MES12               1DDF
MES13               1DE8
MES14               1DF9
MES2                1D64
MES2A               1D6D
MES3                1D76
MES4                1D94
MES8                1D9B
MES9                1DA9
MULTIPLICATIONERROR  1134
MULTIPLY            10F8
MULTIPLYINGERRORMESSAGE  22E5
NAN                 2170
NEWLINE             117A
NOBR                1A18
NOBR1               1A28
NOBR2               1A36
NOBR3               1A46
NOBR4               1A4C
NOBR5               1A54
NOT_HEX             133C
OPEN1               16F4
OPEN2               16FC
OPEN3               170A
OPEN4               1720
OPERAND             80010
OUT1X               13A2
OUT1X1              13B4
OUT2X               13BC
OUT4X               13C4
OUT8X               13CC
PARAM               135E
PARAM1              1366
PARAM3              138A
PARAM4              138E
PARAM5              139A
PARAM6              139E
PARAMTR             106
PASS                21C5
PASSCH2             1238
PASSCH3             1256
PASSM               21BA
PRI_ER              18C4
PS1                 118C
PS2                 1196
PSPACE              143C
PSTRING             118A
PUTCHAR             16DC
PUTSTAR             125A
PUTSTARS            1268
RAMCLEARERROR       106C
RAMERRORMESSAGE     2361
RAMTEST             1036
RAMWRITEERROR       109A
RANGE               15A6
REGNAME             1E0E
REG_MD1             1A98
REG_MD2             1AAE
REG_MD3             1ABE
REG_MD4             1ADC
REG_MD5             1AE8
REG_MOD             1A7A
RESET               1000
RESPONSE            80000
REST1               198C
RESTORE             197C
SEARCH              12E4
SETACIA             1164
SET_DCB             15C8
SIMMODE             C0
SKIP                16D6
SPACE               20
SRCH2               12FE
SRCH3               1302
SRCH4               130A
SRCH6               1314
SRCH7               131E
STACK               4400
STAR                10B
ST_DCB1             15D8
ST_DCB2             15DC
SUBTRACT            10EC
SUBTRACTINGERROR    1124
SUBTRACTINGERRORMESSAGE  22BD
TAIL                1D55
TIDY                1276
TIDY1               127C
TIDY2               1288
TIDY3               1292
TIDY4               129C
TIDY5               12A6
TIDY6               12B2
TINYWA1_1           21CC
TINYWA1_2           21E5
TINYWA1_3           2212
TINYWA1_4           222A
TINYWA1_5           2261
TINYWA1_6           227A
TRACE               19A0
TRAP_0              1738
TRAP_14             4E4E
TSK_T               11A
USERNA              21B1
UTAB                10E
U_CASE              10C
WAIT                57
WORD                1352
WRITERAM            1058
X_UN                1AEC
_00000000           1252
_00000001           1256
_BANNER             1C3A
_CHR                239C
_COMMAND            1C28
_EXECUTE            12B8
_GETLINE            11A0
_GETPASS            11D6
_GO                 1956
_HELP               1B82
_LOAD               144A
_LOGON              1AFC
_LSCH               1B60
_MAIN               1C28
_MAINSTART          1C16
_NEWLINE            117A
_PSTRING            118A
_TIDY               1276
